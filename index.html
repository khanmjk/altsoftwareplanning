<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Architecture Visualization Tool</title>
    <!-- Include D3.js for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Basic styling */
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { text-align: center; }
        .menu, .edit-menu { text-align: center; margin-bottom: 20px; }
        .menu button, .edit-menu button { margin: 5px; padding: 10px 20px; font-size: 16px; }
        #visualization, #teamVisualization { max-width: 800px; margin: 20px auto; }
        svg { width: 100%; height: 600px; border: 1px solid #ccc; }
        #teamTable { width: 100%; border-collapse: collapse; margin-top: 20px; }
        #teamTable th, #teamTable td { border: 1px solid #ccc; padding: 8px; text-align: left; vertical-align: top; }
        .node text { pointer-events: none; font-size: 12px; }
        .tooltip { position: absolute; text-align: left; width: auto; max-width: 300px; padding: 5px; font: 12px sans-serif; background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; pointer-events: none; }
        .legend { font-size: 12px; display: flex; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; margin-right: 15px; margin-bottom: 5px; }
        .team-edit {margin-bottom: 15px;padding: 10px;border: 1px solid #ccc;}
    
          #returnHomeButton {
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 10px 15px;
          font-size: 14px;
          z-index: 1000;
          }
          .team-edit {
              margin-bottom: 15px;
              border: 1px solid #ccc;
          }
          
          .team-edit h4 {
              margin: 0;
              padding: 10px;
              background-color: #f2f2f2;
          }
          
          .team-details {
              padding: 10px;
              display: none;
          }
          .service-edit {
              margin-bottom: 15px;
              border: 1px solid #ccc;
          }
          
          .service-edit h4 {
              margin: 0;
              padding: 10px;
              background-color: #e6f7ff;
              cursor: pointer;
          }
          
          .service-details {
              padding: 10px;
              display: none;
          }
          
          .api-edit {
              margin-left: 20px;
              margin-bottom: 10px;
              border: 1px solid #ddd;
              padding: 10px;
          }    
          /* Adjust SVG size for service visualization */
          #serviceSvg {
              width: 100%;
              height: 600px;
              border: 1px solid #ccc;
          }
          
          /* Adjust tooltip styling if necessary */
          .tooltip {
              position: absolute;
              text-align: left;
              width: auto;
              max-width: 300px;
              padding: 5px;
              font: 12px sans-serif;
              background: rgba(255, 255, 255, 0.9);
              border: 1px solid #ccc;
              pointer-events: none;
              z-index: 1000;
          }
          /* Dependency visualization styles */
          .node circle {
              fill: #fff;
              stroke: steelblue;
              stroke-width: 2px;
          }
          
          .node text {
              font: 12px sans-serif;
          }
          
          .link {
              fill: none;
              stroke: #ccc;
              stroke-width: 2px;
          }
          
          .tooltip {
              position: absolute;
              text-align: left;
              width: auto;
              max-width: 300px;
              padding: 10px;
              font: 12px sans-serif;
              background: rgba(255, 255, 255, 0.9);
              border: 1px solid #ccc;
              border-radius: 5px;
              pointer-events: none;
              z-index: 1000;
          }
          #serviceDependenciesTable {
              margin-top: 20px;
          }
          
          #serviceDependenciesTable table {
              width: 100%;
              border-collapse: collapse;
          }
          
          #serviceDependenciesTable th, #serviceDependenciesTable td {
              border: 1px solid #ccc;
              padding: 8px;
              text-align: left;
          }
          
          #serviceDependenciesTable th {
              background-color: #f2f2f2;
          }
          
          #serviceDependenciesTable tr:nth-child(even) {
              background-color: #f9f9f9;
          }
          
          #serviceDependenciesTable tr:hover {
              background-color: #e9e9e9;
          }          
          .platform-deps-container {
              display: flex;
              align-items: center;
          }
          .current-deps, .other-deps {
              flex: 1;
              margin: 0 10px;
          }
          .platform-deps-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          .platform-deps-buttons button {
              margin: 5px 0;
          }
          .platform-deps-container select {
              width: 100%;
              min-height: 100px;
          }          
          .service-deps-container {
              display: flex;
              align-items: center;
              margin-bottom: 10px;
          }
          
          .current-service-deps, .other-services {
              flex: 1;
              margin: 0 10px;
          }
          
          .service-deps-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          
          .service-deps-buttons button {
              margin: 5px 0;
          }
          
          .service-deps-container select {
              width: 100%;
              min-height: 100px;
          }
          /* Styles for Dependent APIs */
          .dependent-apis-container {
              display: flex;
              align-items: center;
              margin-bottom: 10px;
          }
          
          .current-dependent-apis, .other-apis {
              flex: 1;
              margin: 0 10px;
          }
          
          .dependent-apis-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          
          .dependent-apis-buttons button {
              margin: 5px 0;
          }
          
          .dependent-apis-container select {
              width: 100%;
              min-height: 100px;
          }          
          /* Add styles for new views */
          #organogramView, #engineerTableView {
              max-width: 90%; /* Allow wider view */
              margin: 20px auto;
          }
          
          #organogramSvg {
              width: 100%;
              height: 700px; /* Adjust as needed */
              border: 1px solid #ccc;
              background-color: #f9f9f9; /* Light background */
          }
          
          /* Styles for Organogram Nodes/Links (Example) */
          .organogram-link {
            fill: none;
            stroke: #555;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
          }
          
          .organogram-node circle { /* Example using circles */
            stroke: steelblue;
            stroke-width: 1.5px;
          }
           .organogram-node rect { /* Example using rectangles */
            stroke: steelblue;
            stroke-width: 1.5px;
            fill: #fff;
          }
          
          .organogram-node text {
            font: 10px sans-serif;
            /* Adjust text anchor and position based on layout */
          }
          
           /* Styles for Engineer Table */
           #engineerTable th, #engineerTable td {
               border: 1px solid #ccc;
               padding: 8px;
               text-align: left;
           }
           #engineerTable th {
               background-color: #f2f2f2;
           }
            #engineerTable th[data-sort-key]:hover { /* Indicate sortable */
               background-color: #e0e0e0;
               text-decoration: underline;
            }
          #engineerTable tr:nth-child(even) {
              background-color: #f9f9f9;
          }          
          /* Also add some basic CSS for visual feedback (place within the <style> tag) */
          /* Add styles for drag-and-drop feedback */
          #planningTableBody tr.dragging {
              opacity: 0.5;
              border: 2px dashed #ccc;
          }
          #planningTableBody tr.drag-over {
              border-top: 2px solid blue; /* Highlight where it will drop */
          }          
          
          
          /* Add any additional styles as needed */          
    </style>
</head>
<body>

<!-- Updated Heading with ID -->
<h1 id="pageTitle">Architecture Visualization Tool</h1>
<p id="systemDescription">Load a previously saved system or create a new system</p>

<!-- Menu for loading systems 
<div class="menu">
    <button onclick="showSavedSystems()">Load Saved System</button>
</div>
-->

<!-- Edit System Button -->
<div class="edit-menu" style="display: none;">
    <button id="editSystemButton" onclick="enterEditMode()">Edit System</button>
    <button id="viewOrgChartButton" onclick="showOrganogramView()">View Org Chart</button>
    <button id="viewEngineerListButton" onclick="showEngineerTableView()">View Engineer List</button>
    <button id="manageYearPlanButton" onclick="showPlanningView()">Manage Year Plan</button>
    <button id="deleteSystemButton" onclick="deleteSystem()">Delete System</button>
</div>

<!-- Visualization Section -->
<div id="visualization" style="display:none;">
    <h2>System Visualization</h2>
    <svg id="systemSvg" style="width: 800px; height: 800px;"></svg>
    <!-- Legend -->
    <div id="legend"></div>
</div>

<!-- Team Relationships Visualization -->
<div id="teamVisualization" style="display:none;">
    <h2>Team Relationships Visualization</h2>
    <svg id="teamSvg" style="width: 800px; height: 800px;"></svg>
    <!-- Legend -->
    <div id="teamLegend"></div>
</div>

<!-- Service Relationships Visualization -->
<div id="serviceRelationshipsVisualization" style="display:none;">
    <h2>Service Relationships Visualization</h2>
    <select id="serviceSelection" onchange="updateServiceVisualization()">
        <!-- Options will be populated dynamically -->
    </select>
    <svg id="serviceSvg"></svg>
    <!-- Legend -->
    <div id="serviceLegend"></div>
</div>

<!-- Upstream/Downstream Visualization -->
<div id="dependencyVisualization" style="display:none;">
    <h2>Service Dependency Visualization</h2>
    <select id="dependencyServiceSelection" onchange="updateDependencyVisualization()">
        <!-- Options will be populated dynamically -->
    </select>
    <svg id="dependencySvg" style="width: 800px; height: 600px;"></svg>
    <!-- Legend -->
    <div id="dependencyLegend"></div>
</div>

<!-- Team Breakdown Table -->
<div id="teamBreakdown" style="display:none;">
    <h2>Team Breakdown</h2>
    <p id="levelKey" style="font-size: 0.9em; color: #555; margin-bottom: 10px;"></p> <table id="teamTable">
        <thead> <tr>
                <th>Senior Manager</th> <th>SDM</th>
                <th>Team Identity</th>
                <th>Team Name</th>
                <th>PMT</th>
                <th>Funded HC</th>
                <th>BIS</th>
                <th>Gap to Goal</th> <th>Engineers (Level)</th>
                <th>Services Owned</th>
            </tr>
        </thead>
        <tbody>
            </tbody>
        <tfoot> <tr>
                <th colspan="5" style="text-align: right; font-weight: bold;">Totals:</th> <td id="totalFundedHC" style="font-weight: bold;"></td>
                <td id="totalBIS" style="font-weight: bold;"></td>
                <td id="totalGap" style="font-weight: bold;"></td>
                <td colspan="2"></td> </tr>
             <tr> <td colspan="10" id="gapNote" style="text-align: right; font-style: italic; font-size: 0.9em; padding-top: 5px;"></td>
            </tr>
        </tfoot>
    </table>
</div>

<div id="serviceDependenciesTable" style="display:none;">
    <h2>Service Dependencies Table</h2>
    <table>
        <thead>
        <tr>
            <th>Service Name</th>
            <th>Description</th>
            <th>Owning Team</th>
            <th>Upstream Dependencies (Services Depended On)</th>
            <th>Platform Dependencies</th>
            <th>Downstream Dependencies (Services That Depend On This Service)</th>
        </tr>
        </thead>
        <tbody>
            <!-- Rows will be populated dynamically -->
        </tbody>
    </table>
</div>


<!-- System Edit Form -->
<div id="systemEditForm" style="display:none;">
    <h2>Edit System</h2>
    <form id="editSystemForm">
        <label>System Name:</label><br>
        <input type="text" id="systemNameInput"><br><br>
        <label>System Description:</label><br>
        <textarea id="systemDescriptionInput" rows="3" cols="50"></textarea><br><br>
        <button type="button" onclick="saveSystemDetails()">Save System Details</button>
    </form>

    <!-- Services Management Section -->
    <h3>Services</h3>
    <div id="editServicesManagement">
        <!-- Services will be listed here -->
    </div>
    <button type="button" onclick="addNewService()">Add New Service</button><br><br>
    
    <!-- Teams Management Section -->
    <h3>Teams</h3>
    <div id="teamsManagement">
        <!-- Teams will be listed here -->
    </div>
    <button id="addNewTeamButton" type="button" onclick="addNewTeam()">Add New Team</button><br><br>

    <!-- Buttons to Save or Cancel -->
    <button type="button" onclick="saveAllChanges()">Save All Changes</button>
    <button type="button" onclick="exitEditMode()">Cancel</button>
</div>

<!-- 09/28 Added code for Create New system workflow -->
<!-- Menu for loading systems and creating new systems -->
<div class="menu">
    <button onclick="showSavedSystems()">Load Saved System</button>
    <button onclick="createNewSystem()">Create New Software System</button>
    <!-- Add the Reset to Defaults button -->
    <button onclick="resetToDefaults()">Reset to Defaults</button>    
</div>

<!-- Return to Home Button -->
<button id="returnHomeButton" onclick="returnToHome()">Return to Home</button>

<!-- added some new views 8th april 25 -->
<div id="organogramView" style="display:none; margin-top: 20px;">
    <h2>Organization Chart</h2>
    <div id="organogramToolbar" style="margin-bottom: 10px;">
        </div>
    <div id="organogramContent" style="border: 1px solid #ccc; padding: 15px;">
        </div>
    </div>

<div id="engineerTableView" style="display:none; margin-top: 20px;">
    <h2 id="engineerTableHeading">Engineer Resource List</h2> <p style="font-size: 0.9em; color: #555;">Click column headers to sort.</p>
    <table id="engineerTable" style="width: 100%; border-collapse: collapse; margin-top: 10px;">
        <thead>
            <tr>
                <th data-sort-key="name" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Engineer Name &#x2195;</th>
                <th data-sort-key="level" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Level &#x2195;</th>
                <th data-sort-key="teamName" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Team Name &#x2195;</th>
                <th data-sort-key="sdmName" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">SDM Name &#x2195;</th>
                <th data-sort-key="srMgrName" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Senior Manager Name &#x2195;</th>
            </tr>
        </thead>
        <tbody>
            </tbody>
    </table>
</div>

<div id="planningView" style="display:none; margin-top: 20px;">
    <h2 id="planningViewTitle">Yearly Planning View</h2>
    <div id="planningCapacitySummary" style="margin-bottom: 15px; font-weight: bold;">
        </div>
   <div style="margin-bottom: 15px;">
        <button type="button" id="savePlanButton" style="padding: 8px 12px; background-color: #007bff; color: white; border: none; cursor: pointer;">Save Current Plan Order & Estimates</button>
    </div>        
    <div id="planningTableContainer">
        </div>
    <div id="addInitiativeSection" style="margin-top: 20px; padding: 15px; border: 1px solid #ccc;">
    <div id="addInitiativeSection" style="margin-top: 20px; padding: 15px; border: 1px solid #ccc;">
        <h3>Add New Initiative</h3>
        <div style="margin-bottom: 10px;">
            <label for="newInitiativeTitle" style="display: block;">Title:</label>
            <input type="text" id="newInitiativeTitle" placeholder="Initiative Title" style="width: 90%;">
        </div>
        <div style="margin-bottom: 10px;">
            <label for="newInitiativeDescription" style="display: block;">Description:</label>
            <textarea id="newInitiativeDescription" placeholder="Description" rows="2" style="width: 90%;"></textarea>
        </div>
         <div style="margin-bottom: 10px;">
            <label for="newInitiativeGoalId" style="display: block;">Related Business Goal ID (Optional):</label>
            <input type="text" id="newInitiativeGoalId" placeholder="Optional: Business Goal ID" style="width: 90%;">
        </div>

        <hr>
        <h4>Team Assignments:</h4>
        <div id="newInitiativeAssignmentsDisplay" style="margin-bottom: 10px; min-height: 30px; background-color: #f8f9fa; padding: 5px; border: 1px solid #eee;">
            </div>
        <div style="display: flex; align-items: center; margin-bottom: 10px;">
             <label for="newInitiativeTeamSelect" style="margin-right: 5px;">Team:</label>
             <select id="newInitiativeTeamSelect" style="margin-right: 10px;">
                 <option value="">-- Select Team --</option>
             </select>
             <label for="newInitiativeSdeYears" style="margin-right: 5px;">SDE Years:</label>
             <input type="number" id="newInitiativeSdeYears" step="0.25" min="0" placeholder="e.g., 1.5" style="width: 80px; margin-right: 10px;">
             <button type="button" id="addTeamAssignmentButton">Add Assignment</button>
        </div>

        <hr>
        <button type="button" id="addInitiativeButton" style="padding: 10px 15px; font-size: 16px; background-color: #28a745; color: white; border: none; cursor: pointer;">Add Initiative to Plan</button>
        </div>
    </div>
</div>

<script>
/* JavaScript Code */
/* global variables */
/** Define a unique key for local storage **/
const LOCAL_STORAGE_KEY = 'architectureVisualization_systems';
let currentSystemData = null;
let newServiceData = {};
let uniqueEngineers = [];
const Modes = {
    NAVIGATION: 'navigation',
    BROWSING: 'browsing',
    EDITING: 'editing',
    CREATING: 'creating',
    PLANNING: 'planning' 
};
let currentMode = Modes.NAVIGATION;

/** Sample Data for StreamView **/

/** Define Senior Managers for StreamView **/
const sampleSeniorManagersDataStreamView = [
    { seniorManagerId: 'srMgr1', seniorManagerName: 'Director Dave' },
    { seniorManagerId: 'srMgr2', seniorManagerName: 'VP Victoria' }
];

/** Updated SDMs Data for StreamView (with seniorManagerId) **/
const sampleSDMsDataStreamView = [
    { sdmId: 'sdm1', sdmName: 'Alice Johnson', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm2', sdmName: 'Emily Clark', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm3', sdmName: 'Carol Davis', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm4', sdmName: 'Grace Lee', seniorManagerId: 'srMgr2' },
    { sdmId: 'sdm5', sdmName: 'Ian Turner', seniorManagerId: 'srMgr2' },
    { sdmId: 'sdm6', sdmName: 'Karen Adams', seniorManagerId: 'srMgr2' },
    { sdmId: 'sdm7', sdmName: 'Natalie Green', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm8', sdmName: 'Zoe King', seniorManagerId: 'srMgr2' }
];

/** Updated Teams Data for StreamView (with fundedHeadcount, buildersInSeats, engineers array) **/
const sampleTeamsDataStreamView = [
    {
        teamId: 'team1',
        teamName: 'User Experience Team',
        teamIdentity: 'UX Avengers',
        fundedHeadcount: 7,
        buildersInSeats: 5,
        engineers: [
            { name: 'Alice Johnson', level: 4 },
            { name: 'Mark Evans', level: 3 },
            { name: 'Sophia Lee', level: 3 },
            { name: 'John Doe', level: 2 },
            { name: 'Emma Davis', level: 1 }
        ],
        sdmId: 'sdm1',
        pmtId: 'pmt1'
    },
    {
        teamId: 'team2',
        teamName: 'Streaming Team',
        teamIdentity: 'Stream Spartans',
        fundedHeadcount: 5,
        buildersInSeats: 4,
        engineers: [
            { name: 'Emily Clark', level: 5 },
            { name: 'Daniel Thompson', level: 3 },
            { name: 'Olivia Brown', level: 2 },
            { name: 'Liam Wilson', level: 2 }
        ],
        sdmId: 'sdm2',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team3',
        teamName: 'Content Team',
        teamIdentity: 'Content Crusaders',
        fundedHeadcount: 4,
        buildersInSeats: 3,
        engineers: [
            { name: 'Carol Davis', level: 4 },
            { name: 'Kevin Moore', level: 2 },
            { name: 'Isabella Martinez', level: 2 }
        ],
        sdmId: 'sdm3',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team4',
        teamName: 'Recommendation Team',
        teamIdentity: 'Recommenders of Olympus',
        fundedHeadcount: 6,
        buildersInSeats: 4,
        engineers: [
            { name: 'Grace Lee', level: 4 },
            { name: 'Ethan Harris', level: 3 },
            { name: 'Mia Turner', level: 2 },
            { name: 'Noah Walker', level: 1 }
        ],
        sdmId: 'sdm4',
        pmtId: 'pmt3'
    },
    {
        teamId: 'team5',
        teamName: 'Finance Team',
        teamIdentity: 'Finance Falcons',
        fundedHeadcount: 4,
        buildersInSeats: 3,
        engineers: [
            { name: 'Ian Turner', level: 5 },
            { name: 'Charlotte Adams', level: 3 },
            { name: 'Benjamin Scott', level: 3 }
        ],
        sdmId: 'sdm5',
        pmtId: 'pmt3'
    },
    {
        teamId: 'team6',
        teamName: 'Communication Team',
        teamIdentity: 'Notification Ninjas',
        fundedHeadcount: 3,
        buildersInSeats: 2,
        engineers: [
            { name: 'Karen Adams', level: 3 },
            { name: 'Lucas Wright', level: 2 }
        ],
        sdmId: 'sdm6',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team7',
        teamName: 'Analytics Team',
        teamIdentity: 'Data Dragons',
        fundedHeadcount: 5,
        buildersInSeats: 3,
        engineers: [
            { name: 'Natalie Green', level: 4 },
            { name: 'Andrew Hall', level: 3 },
            { name: 'Ella Young', level: 2 }
        ],
        sdmId: 'sdm7',
        pmtId: 'pmt4'
    },
    {
        teamId: 'team8',
        teamName: 'Search Team',
        teamIdentity: 'Search Spartans',
        fundedHeadcount: 3,
        buildersInSeats: 2,
        engineers: [
            { name: 'Zoe King', level: 3 },
            { name: 'Michael Baker', level: 2 }
        ],
        sdmId: 'sdm8',
        pmtId: 'pmt1'
    }
];

const samplePMTsDataStreamView = [
    { pmtId: 'pmt1', pmtName: 'Bob Smith' },
    { pmtId: 'pmt2', pmtName: 'Frank Thompson' },
    { pmtId: 'pmt3', pmtName: 'Jane Parker' },
    { pmtId: 'pmt4', pmtName: 'Owen Clark' }
];

//Service Name
//Upstreams: List of services the current service depends on.
//Downstreams: List of services that depend on the current service.
//Platform Dependencies: List of platforms the current service depends on.
//Upstreams: For a given service, upstreams are the services listed in its serviceDependencies.
//Downstreams: For a given service, downstreams are the services that include its name in their serviceDependencies.	

const sampleServicesDataStreamView = [
    {
      serviceName: 'User Management Service',
      serviceDescription: 'Handles user registration, authentication, profiles, and account settings.',
      owningTeamId: 'team1',
      apis: [
          {
              apiName: 'Register API',
              apiDescription: 'Allows new users to sign up.',
              dependentApis: []
          },
          {
              apiName: 'Login API',
              apiDescription: 'Authenticates users and starts a session.',
              dependentApis: []
          },
          {
              apiName: 'Profile API',
              apiDescription: 'Manages user profiles and account settings.',
              dependentApis: []
          },
          {
              apiName: 'Logout API',
              apiDescription: 'Ends the user session.',
              dependentApis: []
          }
      ],
      serviceDependencies: [],
      platformDependencies: ['Auth0', 'AWS DynamoDB']
  },
  {
      serviceName: 'Content Delivery Service',
      serviceDescription: 'Manages content streaming and delivery to users.',
      owningTeamId: 'team2',
      apis: [
          {
              apiName: 'Stream Content API',
              apiDescription: 'Streams selected content to the user.',
              dependentApis: ['Subscription API', 'Profile API']
          },
          {
              apiName: 'Adaptive Bitrate API',
              apiDescription: 'Adjusts streaming quality based on network conditions.',
              dependentApis: []
          },
          {
              apiName: 'Content Caching API',
              apiDescription: 'Manages caching of frequently accessed content.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['Content Management Service', 'User Management Service', 'Billing and Subscription Service'],
      platformDependencies: ['AWS CloudFront', 'AWS S3']
  },
  {
      serviceName: 'Content Management Service',
      serviceDescription: 'Handles content ingestion, metadata, and catalog management.',
      owningTeamId: 'team3',
      apis: [
          {
              apiName: 'Content Ingestion API',
              apiDescription: 'Ingests new content into the platform.',
              dependentApis: []
          },
          {
              apiName: 'Metadata API',
              apiDescription: 'Manages content metadata like titles, descriptions, genres.',
              dependentApis: []
          },
          {
              apiName: 'Catalog API',
              apiDescription: 'Provides the catalog of available content.',
              dependentApis: []
          }
      ],
      serviceDependencies: [],
      platformDependencies: ['AWS S3', 'AWS Lambda']
  },
  {
      serviceName: 'Recommendation Engine Service',
      serviceDescription: 'Provides personalized content recommendations to users based on viewing history and preferences.',
      owningTeamId: 'team4',
      apis: [
          {
              apiName: 'Recommendations API',
              apiDescription: 'Retrieves recommended content for a user.',
              dependentApis: ['User Behavior Tracking API', 'Metadata API']
          },
          {
              apiName: 'User Behavior Tracking API',
              apiDescription: 'Tracks user interactions and viewing history.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Content Management Service', 'Analytics Service'],
      platformDependencies: ['AWS Machine Learning', 'Apache Spark']
  },
  {
      serviceName: 'Billing and Subscription Service',
      serviceDescription: 'Manages user subscriptions, billing, and payment processing.',
      owningTeamId: 'team5',
      apis: [
          {
              apiName: 'Subscription API',
              apiDescription: 'Manages user subscription plans.',
              dependentApis: []
          },
          {
              apiName: 'Payment Processing API',
              apiDescription: 'Processes payments securely.',
              dependentApis: ['Email Notification API']
          },
          {
              apiName: 'Invoice API',
              apiDescription: 'Generates invoices and billing statements.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Notification Service'],
      platformDependencies: ['Stripe API', 'AWS RDS']
  },
  {
      serviceName: 'Notification Service',
      serviceDescription: 'Sends notifications, emails, and in-app messages to users.',
      owningTeamId: 'team6',
      apis: [
          {
              apiName: 'Email Notification API',
              apiDescription: 'Sends email notifications to users.',
              dependentApis: []
          },
          {
              apiName: 'Push Notification API',
              apiDescription: 'Sends push notifications to user devices.',
              dependentApis: ['Profile API']
          },
          {
              apiName: 'In-App Messaging API',
              apiDescription: 'Displays messages within the app.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Billing and Subscription Service'],
      platformDependencies: ['AWS SNS', 'Firebase Cloud Messaging']
  },
  {
      serviceName: 'Analytics Service',
      serviceDescription: 'Collects and analyzes data on user engagement, content performance, and platform metrics.',
      owningTeamId: 'team7',
      apis: [
          {
              apiName: 'Data Collection API',
              apiDescription: 'Collects data from various services.',
              dependentApis: []
          },
          {
              apiName: 'Reporting API',
              apiDescription: 'Provides analytical reports and dashboards.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Content Delivery Service', 'Recommendation Engine Service'],
      platformDependencies: ['AWS Redshift', 'Tableau']
  },
  {
      serviceName: 'Search Service',
      serviceDescription: 'Enables users to search for content across the platform.',
      owningTeamId: 'team8',
      apis: [
          {
              apiName: 'Search API',
              apiDescription: 'Allows users to search for content by title, genre, etc.',
              dependentApis: []
          },
          {
              apiName: 'Autocomplete API',
              apiDescription: 'Provides search suggestions as users type.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['Content Management Service', 'User Management Service'],
      platformDependencies: ['Elasticsearch']
  }
];

/** Updated System Data for StreamView (including seniorManagers and yearlyInitiatives) **/
const sampleSystemDataStreamView = {
    systemName: 'StreamView',
    systemDescription: 'StreamView is a video streaming platform that provides personalized content to users worldwide.',
    seniorManagers: sampleSeniorManagersDataStreamView,
    teams: sampleTeamsDataStreamView,
    sdms: sampleSDMsDataStreamView,
    pmts: samplePMTsDataStreamView,
    services: sampleServicesDataStreamView,
    platformDependencies: [], // Will be built dynamically on load
    yearlyInitiatives: [
        // --- Protected Initiatives ---
        {
            initiativeId: 'init-sv-ktlo', title: 'KTLO / Operational Excellence', description: 'Ongoing bug fixes, refactoring, library updates, minor enhancements.', relatedBusinessGoalId: 'eng-excellence', isProtected: true,
            assignments: [ // Assign estimate to all teams
                { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.75 }, { teamId: 'team4', sdeYears: 1.25 },
                { teamId: 'team5', sdeYears: 0.75 }, { teamId: 'team6', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }
            ]
        },
        {
            initiativeId: 'init-sv-oncall', title: 'On-Call / Production Support', description: 'Dedicated capacity for handling live site issues and production incidents.', relatedBusinessGoalId: 'ops-stability', isProtected: true,
            assignments: [ // Assign 1 SDE Year to all teams
                 { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 1.0 }, { teamId: 'team4', sdeYears: 1.0 },
                 { teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 1.0 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 1.0 }
            ]
        },
        {
            initiativeId: 'init-sv-security', title: 'Mandatory Security Hardening (Compliance)', description: 'Address critical security vulnerabilities and ensure compliance (e.g., SOC2, GDPR).', relatedBusinessGoalId: 'compliance', isProtected: true,
            assignments: [
                { teamId: 'team1', sdeYears: 0.5 }, // User Management
                { teamId: 'team5', sdeYears: 0.75 }, // Billing/Finance
                // Add infra/platform team if one existed, assume team2 handles some platform aspects
                { teamId: 'team2', sdeYears: 0.5 } // Content Delivery/Platform
            ]
        },
        // --- Feature/Product Initiatives (Examples) ---
        { initiativeId: 'init-sv-001', title: 'AV1 Codec Support', description: 'Implement AV1 codec for improved streaming efficiency.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 2.5 }, { teamId: 'team3', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-002', title: 'Tiered Subscription Model', description: 'Launch new subscription tiers (Basic, Premium, Family).', relatedBusinessGoalId: 'revenue-growth', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 3.0 }, { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-003', title: 'Recommendation Algorithm V3', description: 'Develop and deploy next-gen recommendation engine.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 4.0 }, { teamId: 'team7', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-004', title: 'Expand CDN to South America', description: 'Set up CDN infrastructure in SA region.', relatedBusinessGoalId: 'global-expansion', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-005', title: 'User Profile Enhancements', description: 'Add customizable avatars and viewing preferences.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-006', title: 'Content Search Facets', description: 'Improve search with filters for genre, rating, year.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-007', title: 'Offline Viewing Improvements', description: 'Enhance download stability and management.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-008', title: 'A/B Testing Framework', description: 'Build internal framework for feature A/B testing.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 2.0 }] },
        { initiativeId: 'init-sv-009', title: 'Parental Controls V2', description: 'Granular controls per profile and content rating.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-010', title: 'Interactive Content POC', description: 'Proof-of-concept for choose-your-own-adventure style content.', relatedBusinessGoalId: 'innovation', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 0.75 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-011', title: 'Payment Gateway Integration (New Region)', description: 'Add local payment options for APAC.', relatedBusinessGoalId: 'global-expansion', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-012', title: 'Real-time Analytics Dashboard', description: 'Internal dashboard for viewing concurrency and errors.', relatedBusinessGoalId: 'ops-stability', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-013', title: 'Watch Party Feature', description: 'Allow users to watch content synchronously with friends.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.5 }, { teamId: 'team6', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-014', title: 'Metadata Enrichment AI', description: 'Use AI to auto-tag content metadata.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team3', sdeYears: 1.5 }, { teamId: 'team4', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-015', title: 'GDPR Data Deletion Automation', description: 'Automate user data deletion requests for GDPR.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.75 }, { teamId: 'team7', sdeYears: 0.25 }] },
        { initiativeId: 'init-sv-016', title: 'Improved Subtitle Customization', description: 'Allow users to change subtitle font, size, color.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-017', title: 'Search Performance Optimization', description: 'Reduce search latency by 50%.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-018', title: 'Gift Subscriptions', description: 'Allow users to purchase subscriptions for others.', relatedBusinessGoalId: 'revenue-growth', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 0.25 }] },
        { initiativeId: 'init-sv-019', title: 'Video Player Accessibility Audit & Fixes', description: 'Ensure player meets WCAG AA standards.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.75 }] },
        { initiativeId: 'init-sv-020', title: 'Reduce Streaming Startup Time', description: 'Optimize playback start time for users.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-021', title: 'Content Partner Reporting Portal', description: 'Allow content partners to view performance data.', relatedBusinessGoalId: 'partnerships', isProtected: false, assignments: [{ teamId: 'team3', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-022', title: 'Personalized Push Notifications', description: 'Send targeted notifications based on viewing habits.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team6', sdeYears: 1.0 }, { teamId: 'team4', sdeYears: 0.5 }] }
    ]
};

/** Sample Data for ConnectPro **/

/** Define Senior Managers for ConnectPro **/
const sampleSeniorManagersDataContactCenter = [
    { seniorManagerId: 'srMgrCC1', seniorManagerName: 'Senior Sam' }
    // Only one senior manager for this example
];

/** Updated SDMs Data for ConnectPro (with seniorManagerId) **/
const contactCenterSDMsData = [
    { sdmId: 'sdm1', sdmName: 'Alex Johnson', seniorManagerId: 'srMgrCC1' },
    { sdmId: 'sdm2', sdmName: 'Matthew Jackson', seniorManagerId: 'srMgrCC1' },
    { sdmId: 'sdm3', sdmName: 'Ryan King', seniorManagerId: 'srMgrCC1' },
    { sdmId: 'sdm4', sdmName: 'Laura Turner', seniorManagerId: 'srMgrCC1' }
];

const contactCenterPMTsData = [
    { pmtId: 'pmt1', pmtName: 'Karen Davis' },          // Shared between team1 and team8
    { pmtId: 'pmt2', pmtName: 'Patricia Thompson' },    // Shared among team2, team3, team6
    { pmtId: 'pmt3', pmtName: 'Angela Green' },         // Shared between team4 and team5
    { pmtId: 'pmt4', pmtName: 'Stephanie Roberts' }     // PMT for team7
];

/** Updated Teams Data for ConnectPro (with fundedHeadcount, buildersInSeats, engineers array) **/
const contactCenterTeamsData = [
    {
        teamId: 'team1',
        teamName: 'Customer Experience Team',
        teamIdentity: 'CX Warriors',
        fundedHeadcount: 6,
        buildersInSeats: 5,
        engineers: [
            { name: 'Alex Johnson', level: 4 }, // Assuming SDM might be L4+
            { name: 'Emily Smith', level: 3 },
            { name: 'David Lee', level: 3 },
            { name: 'Sarah Brown', level: 2 },
            { name: 'Michael Wilson', level: 1 }
        ],
        sdmId: 'sdm1',
        pmtId: 'pmt1'
    },
    {
        teamId: 'team2',
        teamName: 'Case Management Team',
        teamIdentity: 'Case Titans',
        fundedHeadcount: 5,
        buildersInSeats: 4,
        engineers: [
            { name: 'Jessica Taylor', level: 4 },
            { name: 'Daniel Moore', level: 3 },
            { name: 'Amy Anderson', level: 2 },
            { name: 'James Thomas', level: 2 }
        ],
        sdmId: 'sdm1',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team3',
        teamName: 'Routing and Agent Tools Team', // Note: Original had 7 names, split into team3/4
        teamIdentity: 'Routing Rangers',
        fundedHeadcount: 5, // Adjusted
        buildersInSeats: 4, // Adjusted
        engineers: [
            { name: 'Matthew Jackson', level: 5 }, // Assuming SDM L5
            { name: 'Ashley White', level: 3 },
            { name: 'Joshua Harris', level: 2 },
            { name: 'Andrew Garcia', level: 2 } // Moved Andrew here
        ],
        sdmId: 'sdm2',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team4',
        teamName: 'Agent Tools Team', // Note: Original had 7 names, split into team3/4
        teamIdentity: 'Agent Aces',
        fundedHeadcount: 4, // Adjusted
        buildersInSeats: 3, // Adjusted
        engineers: [
             // Andrew Garcia moved to team3
            { name: 'Megan Clark', level: 3 },
            { name: 'Steven Lewis', level: 2 },
            { name: 'Nicole Young', level: 1 }
        ],
        sdmId: 'sdm2', // Still under Matthew Jackson
        pmtId: 'pmt3'
    },
    {
        teamId: 'team5',
        teamName: 'Communication Channels Team',
        teamIdentity: 'Comm Mandalorians',
        fundedHeadcount: 6,
        buildersInSeats: 5,
        engineers: [
            { name: 'Ryan King', level: 4 }, // Assuming SDM L4
            { name: 'Samantha Wright', level: 3 },
            { name: 'Brandon Lopez', level: 3 },
            { name: 'Rachel Hill', level: 2 },
            { name: 'Justin Scott', level: 2 }
        ],
        sdmId: 'sdm3',
        pmtId: 'pmt3'
    },
    {
        teamId: 'team6',
        teamName: 'Skills Management Team',
        teamIdentity: 'Skill Masters',
        fundedHeadcount: 3,
        buildersInSeats: 2,
        engineers: [
            { name: 'Kimberly Adams', level: 3 },
            { name: 'Jonathan Baker', level: 2 }
        ],
        sdmId: 'sdm3',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team7',
        teamName: 'Analytics and Configuration Team', // Note: Original had 5 names, split into team7/8
        teamIdentity: 'Data Wizards',
        fundedHeadcount: 4, // Adjusted
        buildersInSeats: 3, // Adjusted
        engineers: [
            { name: 'Jason Carter', level: 4 },
            { name: 'Melissa Mitchell', level: 3 },
            { name: 'Kevin Perez', level: 2 }
            // Laura Turner and Eric Phillips moved to team8
        ],
        sdmId: 'sdm4',
        pmtId: 'pmt4'
    },
    {
        teamId: 'team8',
        teamName: 'Configuration Team', // Note: Original had 5 names, split into team7/8
        teamIdentity: 'Config Ninjas',
        fundedHeadcount: 3, // Adjusted
        buildersInSeats: 2, // Adjusted
        engineers: [
            { name: 'Laura Turner', level: 4 }, // Assuming SDM L4
            { name: 'Eric Phillips', level: 3 }
        ],
        sdmId: 'sdm4', // Still under Laura Turner
        pmtId: 'pmt1'
    }
];


const sampleServicesDataConnectPro = [
    {
        serviceName: 'Customer Portal Service',
        serviceDescription: 'Allows customers to raise support tickets and track their status.',
        owningTeamId: 'team1',
        apis: [
            {
                apiName: 'Ticket Submission API',
                apiDescription: 'Enables customers to submit support tickets.',
                dependentApis: []
            },
            {
                apiName: 'Ticket Tracking API',
                apiDescription: 'Allows customers to check the status of their tickets.',
                dependentApis: []
            }
        ],
        serviceDependencies: [],
        platformDependencies: ['AWS Cognito', 'AWS S3']
    },
    {
        serviceName: 'Case Management Service',
        serviceDescription: 'Manages the lifecycle of support tickets within the system.',
        owningTeamId: 'team2',
        apis: [
            {
                apiName: 'Case Creation API',
                apiDescription: 'Creates a new case in the system.',
                dependentApis: []
            },
            {
                apiName: 'Case Update API',
                apiDescription: 'Updates case details and status.',
                dependentApis: []
            },
            {
                apiName: 'Case Assignment API',
                apiDescription: 'Assigns cases to agents based on skills and availability.',
                dependentApis: ['Skills Assignment API']
            }
        ],
        serviceDependencies: ['Customer Portal Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS DynamoDB']
    },
    {
        serviceName: 'Routing Service',
        serviceDescription: 'Routes incoming interactions to appropriate agents.',
        owningTeamId: 'team3', // Owned by team3
        apis: [
            {
                apiName: 'Interaction Routing API',
                apiDescription: 'Routes voice, email, and chat interactions.',
                dependentApis: ['Skill Matching API', 'Agent Login API']
            },
            {
                apiName: 'Skill Matching API',
                apiDescription: 'Matches interactions to agents based on skills.',
                dependentApis: ['Skills Evaluation API']
            }
        ],
        serviceDependencies: ['Communication Channels Service', 'Skills Management Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS Lambda']
    },
    {
        serviceName: 'Agent Desktop Service',
        serviceDescription: 'Provides agents with tools to handle customer interactions.',
        owningTeamId: 'team4', 
        apis: [
            {
                apiName: 'Agent Login API',
                apiDescription: 'Authenticates agents and starts their session.',
                dependentApis: []
            },
            {
                apiName: 'Interaction Handling API',
                apiDescription: 'Manages ongoing interactions with customers.',
                dependentApis: ['Case Retrieval API']
            },
            {
                apiName: 'Case Retrieval API',
                apiDescription: 'Retrieves case details for agents.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service'],
        platformDependencies: ['AWS AppSync']
    },
    {
        serviceName: 'Communication Channels Service',
        serviceDescription: 'Handles voice calls, emails, and chat messages.',
        owningTeamId: 'team5',
        apis: [
            {
                apiName: 'Voice Call API',
                apiDescription: 'Manages voice call connections.',
                dependentApis: []
            },
            {
                apiName: 'Email Processing API',
                apiDescription: 'Processes incoming and outgoing emails.',
                dependentApis: []
            },
            {
                apiName: 'Chat Messaging API',
                apiDescription: 'Manages live chat sessions.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Routing Service', 'Agent Desktop Service'],
        platformDependencies: ['Amazon Connect', 'AWS SES', 'Amazon Lex']
    },
    {
        serviceName: 'Skills Management Service',
        serviceDescription: 'Manages agent skills and competencies.',
        owningTeamId: 'team6',
        apis: [
            {
                apiName: 'Skills Assignment API',
                apiDescription: 'Assigns skills to agents.',
                dependentApis: []
            },
            {
                apiName: 'Skills Evaluation API',
                apiDescription: 'Evaluates agent performance in skills.',
                dependentApis: []
            }
        ],
        serviceDependencies: [],
        platformDependencies: ['AWS Machine Learning']
    },
    {
        serviceName: 'Reporting and Analytics Service',
        serviceDescription: 'Provides reports on contact center performance.',
        owningTeamId: 'team7',
        apis: [
            {
                apiName: 'Performance Metrics API',
                apiDescription: 'Retrieves metrics on agent and center performance.',
                dependentApis: []
            },
            {
                apiName: 'Historical Data API',
                apiDescription: 'Accesses historical interaction data.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS Redshift', 'Amazon QuickSight']
    },
    {
        serviceName: 'Business Configuration Service',
        serviceDescription: 'Allows administrators to configure business rules and settings.',
        owningTeamId: 'team8', 
        apis: [
            {
                apiName: 'Settings API',
                apiDescription: 'Manages system-wide settings.',
                dependentApis: []
            },
            {
                apiName: 'Rules Engine API',
                apiDescription: 'Defines routing and assignment rules.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service', 'Agent Desktop Service', 'Communication Channels Service', 'Skills Management Service'],
        platformDependencies: ['AWS CloudFormation']
    }
];

/** Updated System Data for ConnectPro (including seniorManagers and yearlyInitiatives) **/
const sampleSystemDataContactCenter = {
    systemName: 'ConnectPro',
    systemDescription: 'ConnectPro is a cloud-based contact center solution that streamlines customer interactions across multiple channels.',
    seniorManagers: sampleSeniorManagersDataContactCenter,
    teams: contactCenterTeamsData,
    sdms: contactCenterSDMsData,
    pmts: contactCenterPMTsData,
    services: sampleServicesDataConnectPro,
    platformDependencies: [], // Will be built dynamically on load
    yearlyInitiatives: [
        // --- Protected Initiatives ---
        {
            initiativeId: 'init-cc-ktlo', title: 'KTLO / Operational Excellence', description: 'Ongoing bug fixes, refactoring, library updates, minor enhancements.', relatedBusinessGoalId: 'eng-excellence', isProtected: true,
            assignments: [ // Assign estimate to all teams
                { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.75 }, { teamId: 'team4', sdeYears: 0.75 },
                { teamId: 'team5', sdeYears: 1.25 }, { teamId: 'team6', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }
            ]
        },
        {
            initiativeId: 'init-cc-oncall', title: 'On-Call / Production Support', description: 'Dedicated capacity for handling live site issues and production incidents.', relatedBusinessGoalId: 'ops-stability', isProtected: true,
            assignments: [ // Assign 1 SDE Year to all teams
                 { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 1.0 }, { teamId: 'team4', sdeYears: 1.0 },
                 { teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 1.0 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 1.0 }
            ]
        },
        {
            initiativeId: 'init-cc-security', title: 'Mandatory Security Audit & Remediation', description: 'Address findings from annual security audit and maintain compliance.', relatedBusinessGoalId: 'compliance', isProtected: true,
            assignments: [
                { teamId: 'team1', sdeYears: 0.5 }, // Customer Portal
                { teamId: 'team4', sdeYears: 0.75 }, // Agent Desktop
                { teamId: 'team5', sdeYears: 0.5 }, // Comm Channels (sensitive data)
                { teamId: 'team8', sdeYears: 0.5 }  // Config / Infra
            ]
        },
        // --- Feature/Product Initiatives (Examples) ---
        { initiativeId: 'init-cc-001', title: 'Omnichannel Support (Chat)', description: 'Integrate live chat channel support.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 2.0 }, { teamId: 'team4', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-002', title: 'AI-Powered Agent Assist (KB Suggestions)', description: 'Suggest relevant knowledge base articles to agents in real-time.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 2.5 }, { teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-cc-003', title: 'Upgrade Reporting Engine', description: 'Migrate reporting to new platform for better performance.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 3.0 }] },
        { initiativeId: 'init-cc-004', title: 'Salesforce CRM Integration V1', description: 'Basic integration to sync contact data and case creation.', relatedBusinessGoalId: 'integration', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }, { teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-005', title: 'Customer Portal Self-Service KB', description: 'Allow customers to search knowledge base via portal.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.5 }] },
        { initiativeId: 'init-cc-006', title: 'Advanced Routing Rules (Time-based)', description: 'Allow configuration of time-of-day routing.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team3', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-007', title: 'Agent Performance Dashboard', description: 'New dashboard in agent desktop showing key metrics.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 1.0 }, { teamId: 'team7', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-008', title: 'Skills-Based Routing Enhancements', description: 'Add proficiency levels to skill matching.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team6', sdeYears: 1.5 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-009', title: 'Email Channel Integration', description: 'Add support for email as an interaction channel.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.5 }, { teamId: 'team4', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-010', title: 'Voice Call Recording & Playback', description: 'Implement secure call recording and retrieval.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 2.0 }, { teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-011', title: 'Case Prioritization Engine', description: 'Automatically prioritize cases based on SLA or sentiment.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }, { teamId: 'team7', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-012', title: 'Configuration Change History', description: 'Track who changed what configuration when.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 1.0 }] },
        { initiativeId: 'init-cc-013', title: 'CTI Screen Pop Improvements', description: 'Customize screen pop data based on call context.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 1.0 }, { teamId: 'team5', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-014', title: 'Sentiment Analysis POC', description: 'Proof-of-concept for analyzing sentiment in chat/email.', relatedBusinessGoalId: 'innovation', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-cc-015', title: 'Supervisor Barge-In/Listen-In', description: 'Allow supervisors to monitor or join live calls.', relatedBusinessGoalId: 'quality-assurance', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.5 }, { teamId: 'team4', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-016', title: 'Customer Satisfaction Survey (CSAT)', description: 'Implement post-interaction CSAT surveys.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-017', title: 'Agent Skill Self-Assessment', description: 'Allow agents to update their skill profiles.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team6', sdeYears: 0.75 }, { teamId: 'team4', sdeYears: 0.25 }] },
        { initiativeId: 'init-cc-018', title: 'Knowledge Base Article Versioning', description: 'Track changes and history for KB articles.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.5 }] }, // Assuming portal team owns KB UI
        { initiativeId: 'init-cc-019', title: 'Real-time Queue Dashboard', description: 'Dashboard showing queue lengths, wait times.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.25 }] },
        { initiativeId: 'init-cc-020', title: 'Automated Case Closure Rules', description: 'Configure rules to auto-close inactive cases.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 0.75 }, { teamId: 'team8', sdeYears: 0.25 }] },
        { initiativeId: 'init-cc-021', title: 'Bulk User Import/Update', description: 'Allow admins to manage agents in bulk.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-022', title: 'PCI Compliance for Call Recordings', description: 'Ensure call recording storage meets PCI standards.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }] }
    ]
};

window.onload = function() {
    console.log("!!! Window on load !!!!");
    
    currentMode = Modes.NAVIGATION;
    // Initialize UI accordingly
};

/** Save Sample Systems to Local Storage **/

function saveSampleSystemsToLocalStorage() {
    if (!localStorage.getItem(LOCAL_STORAGE_KEY)) {
        const systems = {
            'StreamView': sampleSystemDataStreamView,
            'ConnectPro': sampleSystemDataContactCenter
        };
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));
    }
}


// Call the function to save sample systems on page load
saveSampleSystemsToLocalStorage();

/** Show Saved Systems **/

function showSavedSystems() {
    // Retrieve the systems from local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    const systemNames = Object.keys(systems);

    // If no systems are saved, alert the user
    if (systemNames.length === 0) {
        alert('No saved systems found.');
        return;
    }

    // Create a list of systems for the user to select from
    let systemListHtml = '<h2>Select a System to Load</h2><ul>';
    systemNames.forEach(systemName => {
        systemListHtml += `<li><a href="#" onclick="loadSavedSystem('${systemName}')">${systemName}</a></li>`;
    });
    systemListHtml += '</ul>';

    // Display the list in a modal or in a div
    let systemListDiv = document.createElement('div');
    systemListDiv.id = 'systemListDiv';
    systemListDiv.innerHTML = systemListHtml;

    // Add a close button
    let closeButton = document.createElement('button');
    closeButton.innerText = 'Close';
    closeButton.onclick = function() {
        document.body.removeChild(systemListDiv);
    };
    systemListDiv.appendChild(closeButton);

    // Style the div
    systemListDiv.style.position = 'fixed';
    systemListDiv.style.top = '50%';
    systemListDiv.style.left = '50%';
    systemListDiv.style.transform = 'translate(-50%, -50%)';
    systemListDiv.style.backgroundColor = '#fff';
    systemListDiv.style.padding = '20px';
    systemListDiv.style.border = '1px solid #ccc';
    systemListDiv.style.zIndex = '1000';

    // Append the div to the body
    document.body.appendChild(systemListDiv);
}

function buildGlobalPlatformDependencies() {
    const platformDepsSet = new Set();

    // Iterate over services to collect platform dependencies
    currentSystemData.services.forEach(service => {
        if (service.platformDependencies) {
            service.platformDependencies.forEach(dep => {
                platformDepsSet.add(dep);
            });
        }
    });

    // Convert the set to an array and assign to currentSystemData
    currentSystemData.platformDependencies = Array.from(platformDepsSet);
}

/** Load Saved System **/

function loadSavedSystem(systemName) {
    currentMode = Modes.BROWSING;
    
    // Retrieve the systems from local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    const systemData = systems[systemName];

    // **Add console log to see what's in local storage**
    console.log('Loaded systems from local storage:', systems);
    
    if (!systemData) {
        alert('System not found.');
        return;
    }

    // **Add console log to verify currentSystemData**
    console.log('Loaded currentSystemData:', currentSystemData);
    
    // Remove the system list div
    const systemListDiv = document.getElementById('systemListDiv');
    if (systemListDiv) {
        document.body.removeChild(systemListDiv);
    }

    // Clear previous content
    d3.selectAll('.tooltip').remove(); // Remove any existing tooltips
    //document.getElementById('teamTable').innerHTML = `
    //    <tr>
     //       <th>SDM</th>
     //       <th>Team Identity</th>
     //       <th>Team Name</th>
    //       <th>PMT</th>
     //       <th>Size of Team</th>
     //       <th>Engineer Names</th>
     //       <th>Services Owned</th>
     //   </tr>
    //`;
    document.getElementById('legend').innerHTML = '';
    document.getElementById('teamLegend').innerHTML = '';
    
    document.getElementById('organogramView').style.display = 'none';
    document.getElementById('engineerTableView').style.display = 'none';

    currentSystemData = systemData; // Store the current system data

    // **Add console log to verify currentSystemData**
    console.log('Selected system to load:', currentSystemData);
    
    // Re-initialize uniqueEngineers based on currentSystemData
    uniqueEngineers = [];
    currentSystemData.teams.forEach(team => {
        const engineers = team.engineerNames ? team.engineerNames.split(',').map(name => name.trim()) : [];
        engineers.forEach(engineerName => {
            uniqueEngineers.push({ engineerName, teamId: team.teamId });
        });
    });


   // Ensure platformDependencies is initialized
   if (!currentSystemData.platformDependencies) {
       currentSystemData.platformDependencies = [];
   }
    // Build global platform dependencies list
    buildGlobalPlatformDependencies();
    
    // Update the page title and description
    document.getElementById('pageTitle').innerText = currentSystemData.systemName;
    document.getElementById('systemDescription').innerText = currentSystemData.systemDescription || '';
    
    
    
    // Hide the menu
    document.querySelector('.menu').style.display = 'none';

    // Show the "Edit System" button
    document.querySelector('.edit-menu').style.display = 'block';

    // Display visualization and team breakdown sections
    document.getElementById('visualization').style.display = 'block';
    document.getElementById('teamVisualization').style.display = 'block';
    document.getElementById('teamBreakdown').style.display = 'block';

    // ** Show the new service relationships visualization **
    document.getElementById('serviceRelationshipsVisualization').style.display = 'block';

    // Show the new dependency visualization section
    document.getElementById('dependencyVisualization').style.display = 'block';    

    // Populate the service selection drop-down
    populateServiceSelection();
    
    // Generate the network graph
    generateVisualization(systemData);
    // Generate the team relationships visualization
    generateTeamVisualization(systemData);
    // Generate the team breakdown table
    generateTeamTable(systemData);

    // Generate the initial service relationships visualization (All Services View)
    updateServiceVisualization();

    // Populate the service selection for the dependency visualization
    populateDependencyServiceSelection();

    // Generate the initial dependency visualization
    updateDependencyVisualization();    
    
    //show the services dependency table
    generateServiceDependenciesTable();
    // Show the Service Dependencies Table
    document.getElementById('serviceDependenciesTable').style.display = 'block';    
    
    // Debugging: Log currentSystemData after loading
    console.log('Loaded currentSystemData:', currentSystemData);
    
}


/** Generate System Visualization **/

function generateVisualization(systemData) {
    let svg = d3.select('#systemSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // Set SVG dimensions
    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    // Append a group element that will contain all the graph elements
    let graphGroup = svg.append('g');

    // Define the zoom behavior
    let zoom = d3.zoom()
        .scaleExtent([0.5, 5])
        .on('zoom', zoomed);

    // Apply the zoom behavior to the SVG
    svg.call(zoom);

    // Define the zoomed function
    function zoomed(event) {
        graphGroup.attr('transform', event.transform);
    }

    // Define node radius
    const radius = 10;

    // Prepare nodes and links data
    let nodes = [];
    let links = [];
    let nodeMap = {};

    // Create a color scale based on teams
    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = systemData.teams.map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Create nodes for services and APIs
    systemData.services.forEach(service => {
        let teamId = service.owningTeamId || 'unassigned';
        let nodeColor = teamColorScale(teamId);

        nodes.push({ id: service.serviceName, type: 'service', teamId: teamId, color: nodeColor });
        nodeMap[service.serviceName] = { id: service.serviceName, type: 'service' };

        service.apis.forEach(api => {
            nodes.push({ id: api.apiName, type: 'api', teamId: teamId, color: nodeColor });
            nodeMap[api.apiName] = { id: api.apiName, type: 'api' };
            // Link API to its service
            links.push({
                source: api.apiName,
                target: service.serviceName,
                type: 'api-service'
            });
        });
    });

    // Add platform dependencies as nodes
    systemData.services.forEach(service => {
        service.platformDependencies.forEach(platform => {
            if (!nodeMap[platform]) {
                nodes.push({ id: platform, type: 'platform', color: '#a04040' }); // Platforms have their own color
                nodeMap[platform] = { id: platform, type: 'platform' };
            }
            // Link service to platform
            links.push({
                source: service.serviceName,
                target: platform,
                type: 'platform-dependency'
            });
        });
    });

    // Create links based on service dependencies
    systemData.services.forEach(service => {
        // Service dependencies
        service.serviceDependencies.forEach(dependency => {
            if (nodeMap[dependency]) {
                links.push({
                    source: service.serviceName,
                    target: dependency,
                    type: 'service-dependency'
                });
            }
        });
        // API dependencies
        service.apis.forEach(api => {
            api.dependentApis.forEach(depApi => {
                if (nodeMap[depApi]) {
                    links.push({
                        source: api.apiName,
                        target: depApi,
                        type: 'api-dependency'
                    });
                }
            });
        });
    });

    // Calculate the number of nodes
    const nodeCount = nodes.length;

    // Adjust force strengths based on node count
    let chargeStrength = -300;
    let linkDistance = 100;

    if (nodeCount > 100) {
        chargeStrength = -100;
        linkDistance = 30;
    } else if (nodeCount > 50) {
        chargeStrength = -200;
        linkDistance = 50;
    }

    // Set up the simulation
    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(linkDistance))
        .force('charge', d3.forceManyBody().strength(chargeStrength))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 20));

    // Add links to the graphGroup
    let link = graphGroup.append('g')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-dasharray', d => {
            if (d.type === 'api-service') return '2,2';
            else if (d.type === 'service-dependency') return '5,5';
            else if (d.type === 'platform-dependency') return '10,5';
            else if (d.type === 'api-dependency') return '3,3';
            else return '1,0';
        })
        .attr('stroke-width', 1.5);

    // Add nodes to the graphGroup
    let node = graphGroup.append('g')
        .attr('stroke', '#fff')
        .attr('stroke-width', 1.5)
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', radius)
        .attr('fill', d => d.color)
        .call(drag(simulation));

    // Add labels to the graphGroup
    let labels = graphGroup.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 12)
        .attr('dy', 4)
        .text(d => d.id);

    // Tooltip
    let tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let info = '';
        if (d.type === 'service') {
            let service = systemData.services.find(s => s.serviceName === d.id);
            let team = systemData.teams.find(t => t.teamId === service.owningTeamId);
            info = `<strong>Service Name:</strong> ${service.serviceName}<br>
                    <strong>Description:</strong> ${service.serviceDescription}<br>
                    <strong>Team:</strong> ${team ? `${team.teamName} (${team.teamIdentity})` : 'Unassigned'}`;
        } else if (d.type === 'api') {
            let api;
            let serviceName;
            systemData.services.forEach(service => {
                service.apis.forEach(a => {
                    if (a.apiName === d.id) {
                        api = a;
                        serviceName = service.serviceName;
                    }
                });
            });
            info = `<strong>API Name:</strong> ${api.apiName}<br>
                    <strong>Description:</strong> ${api.apiDescription}<br>
                    <strong>Service:</strong> ${serviceName}`;
        } else if (d.type === 'platform') {
            info = `<strong>Platform Dependency:</strong> ${d.id}`;
        }
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5);
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    // Add legend for teams
    let legendData = systemData.teams.map(team => ({
        teamIdentity: team.teamIdentity,
        color: teamColorScale(team.teamId)
    }));

    let legend = d3.select('#legend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item');

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
}
/** Generate Team Relationships Visualization **/

function generateTeamVisualization(systemData) {
    let svg = d3.select('#teamSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // Set SVG dimensions
    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    // Define node radius
    const radius = 20;
    
    // Prepare nodes and links data
    let nodes = [];
    let links = [];
    let nodeMap = {};

    // Create a color scale for teams
    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = systemData.teams.map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Map teamId to services
    let teamServicesMap = {};
    systemData.services.forEach(service => {
        let teamId = service.owningTeamId;
        if (teamId) { // Ensure teamId is valid
            if (!teamServicesMap[teamId]) {
                teamServicesMap[teamId] = [];
            }
            teamServicesMap[teamId].push(service.serviceName);
        }
    });

    // Create nodes for teams
    systemData.teams.forEach(team => {
        if (team.teamId) { // Ensure teamId is valid
            nodes.push({
                id: team.teamId,
                name: team.teamIdentity,
                type: 'team',
                color: teamColorScale(team.teamId),
                services: teamServicesMap[team.teamId] || []
            });
            nodeMap[team.teamId] = { id: team.teamId };
        }
    });

    // Create links based on service dependencies
    let teamDependencies = {};

    systemData.services.forEach(service => {
        let owningTeamId = service.owningTeamId;
        if (owningTeamId && systemData.teams.some(t => t.teamId === owningTeamId)) { // Ensure owningTeamId is valid
            if (service.serviceDependencies.length > 0) {
                service.serviceDependencies.forEach(dependentServiceName => {
                    let dependentService = systemData.services.find(s => s.serviceName === dependentServiceName);
                    if (dependentService) {
                        let dependentTeamId = dependentService.owningTeamId;
                        if (dependentTeamId && owningTeamId !== dependentTeamId && systemData.teams.some(t => t.teamId === dependentTeamId)) {
                            let linkKey = owningTeamId + '-' + dependentTeamId;
                            if (!teamDependencies[linkKey]) {
                                teamDependencies[linkKey] = true;
                                links.push({
                                    source: owningTeamId,
                                    target: dependentTeamId,
                                    type: 'team-dependency'
                                });
                            }
                        }
                    }
                });
            }
        }
    });

    // Set up the simulation
    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 30));

    // Add links to the SVG
    let link = svg.append('g')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-width', 2);

    // Add nodes to the SVG
    let node = svg.append('g')
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', 20)
        .attr('fill', d => d.color)
        .call(drag(simulation));

    // Add labels to nodes
    let labels = svg.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 0)
        .attr('dy', 4)
        .attr('text-anchor', 'middle')
        .text(d => d.name);

    // Tooltip
    let tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let team = systemData.teams.find(t => t.teamId === d.id);
        let sdm = systemData.sdms.find(s => s.sdmId === team.sdmId);
        let pmt = systemData.pmts.find(p => p.pmtId === team.pmtId);
        let services = d.services.join(', ') || 'None';
        let info = `<strong>Team Identity:</strong> ${team.teamIdentity}<br>
                    <strong>Team Name:</strong> ${team.teamName}<br>
                    <strong>SDM:</strong> ${sdm ? sdm.sdmName : 'N/A'}<br>
                    <strong>PMT:</strong> ${pmt ? pmt.pmtName : 'N/A'}<br>
                    <strong>Size of Team:</strong> ${team.sizeOfTeam}<br>
                    <strong>Engineer Names:</strong> ${team.engineerNames}<br>
                    <strong>Services Owned:</strong> ${services}`;
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5);
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    // Add legend for teams
    let legendData = systemData.teams.map(team => ({
        teamIdentity: team.teamIdentity,
        color: teamColorScale(team.teamId)
    }));

    let legend = d3.select('#teamLegend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item');

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
}

//** Generate Team Breakdown Table **/
/** REVISED Generate Team Breakdown Table - Fix Engineer String Format **/
function generateTeamTable(systemData) {
    // **Debugging:** Log the incoming team data to check structure
    // console.log("Generating Team Table with data:", JSON.stringify(systemData, null, 2));

    let teamTable = document.getElementById('teamTable');
    let tableBody = teamTable.querySelector('tbody');
    if (!tableBody) {
        tableBody = document.createElement('tbody');
        teamTable.appendChild(tableBody);
    }
    tableBody.innerHTML = ''; // Clear existing content from tbody only

    // --- Defensive checks for core data ---
    if (!systemData || !systemData.teams || !Array.isArray(systemData.teams)) {
        console.error("generateTeamTable: Invalid or missing systemData.teams");
        let row = tableBody.insertRow();
        let cell = row.insertCell();
        cell.colSpan = 10; // Adjusted colspan
        cell.textContent = "Error: Team data is missing or invalid.";
        cell.style.color = 'red';
        return;
    }
    const services = systemData.services || [];
    const sdms = systemData.sdms || [];
    const pmts = systemData.pmts || [];
    const seniorManagers = systemData.seniorManagers || [];
    // --------------------------------------

    // --- Totals Initialization ---
    let totalFundedHC = 0;
    let totalBIS = 0;
    // ---------------------------

    // --- Helper Functions for Lookups ---
    const getSeniorManagerName = (srMgrId) => {
        if (!srMgrId) return 'No Senior Manager';
        const srMgr = seniorManagers.find(s => s.seniorManagerId === srMgrId);
        return srMgr ? srMgr.seniorManagerName : `Unknown (${srMgrId})`;
    };
    const getSdmName = (sdmId) => {
        if (!sdmId) return 'No SDM';
        const sdm = sdms.find(s => s.sdmId === sdmId);
        return sdm ? sdm.sdmName : `Unknown (${sdmId})`;
    };
    const getPmtName = (pmtId) => {
        if (!pmtId) return 'N/A';
        const pmt = pmts.find(p => p.pmtId === pmtId);
        return pmt ? pmt.pmtName : `Unknown (${pmtId})`;
    };
    // -----------------------------------

    // --- Map teamId to services ---
    let teamServicesMap = {};
    services.forEach(service => {
        let teamId = service.owningTeamId;
        if (teamId) {
            if (!teamServicesMap[teamId]) teamServicesMap[teamId] = [];
            teamServicesMap[teamId].push(service.serviceName);
        }
    });
    // -----------------------------

    // --- Group teams by Senior Manager -> SDM ---
    let groupedData = {};
    systemData.teams.forEach(team => {
        if (!team) return;

        const sdm = sdms.find(s => s.sdmId === team.sdmId);
        const srMgrId = sdm ? (sdm.seniorManagerId || 'no-sr-mgr') : 'no-sdm';
        const sdmId = team.sdmId || 'no-sdm';

        if (!groupedData[srMgrId]) {
            groupedData[srMgrId] = {};
        }
        if (!groupedData[srMgrId][sdmId]) {
            groupedData[srMgrId][sdmId] = [];
        }
        groupedData[srMgrId][sdmId].push(team);
    });
    // -------------------------------------------

    // --- Populate Table Body ---
    for (const srMgrId in groupedData) {
        const srMgrData = groupedData[srMgrId];
        const srMgrNameDisplay = (srMgrId === 'no-sr-mgr' || srMgrId === 'no-sdm') ? 'No Assigned Senior Manager' : getSeniorManagerName(srMgrId);
        let isFirstRowForSrMgr = true;
        let srMgrRowspan = 0;

        for (const sdmId in srMgrData) {
            srMgrRowspan += srMgrData[sdmId].length;
        }

        for (const sdmId in srMgrData) {
            const teams = srMgrData[sdmId];
            const sdmNameDisplay = (sdmId === 'no-sdm') ? 'No Assigned SDM' : getSdmName(sdmId);
            let isFirstRowForSdm = true;

            teams.forEach((team) => {
                if (!team) return;

                let row = tableBody.insertRow();

                if (isFirstRowForSrMgr) {
                    let srMgrCell = row.insertCell();
                    srMgrCell.innerText = srMgrNameDisplay;
                    srMgrCell.rowSpan = srMgrRowspan;
                    srMgrCell.style.verticalAlign = 'top';
                    isFirstRowForSrMgr = false;
                }

                if (isFirstRowForSdm) {
                    let sdmCell = row.insertCell();
                    sdmCell.innerText = sdmNameDisplay;
                    sdmCell.rowSpan = teams.length;
                    sdmCell.style.verticalAlign = 'top';
                    isFirstRowForSdm = false;
                }

                row.insertCell().innerText = team.teamIdentity || 'N/A';
                row.insertCell().innerText = team.teamName || 'N/A';
                row.insertCell().innerText = getPmtName(team.pmtId);

                const funded = team.fundedHeadcount ?? 0;
                const bis = team.buildersInSeats ?? 0;
                const gap = funded - bis;
                row.insertCell().innerText = funded;
                row.insertCell().innerText = bis;
                let gapCell = row.insertCell();
                gapCell.innerText = gap;
                gapCell.style.color = gap < 0 ? 'red' : (gap > 0 ? 'orange' : 'green');

                totalFundedHC += funded;
                totalBIS += bis;

                // Engineers (Name and Level)
                let engineersCell = row.insertCell();
                if (team.engineers && Array.isArray(team.engineers) && team.engineers.length > 0) {
                    engineersCell.innerHTML = team.engineers
                        .map(eng => {
                            if (typeof eng !== 'object' || eng === null) return 'Invalid Eng Data';
                            const name = eng.name || 'Unnamed';
                            const level = eng.level ?? '?';
                            // --- USE STANDARD STRING CONCATENATION ---
                            return name + ' (L' + level + ')';
                            // -----------------------------------------
                        })
                        .join('<br>');
                } else {
                    engineersCell.innerText = 'None';
                }
                engineersCell.style.whiteSpace = 'pre-line';

                // Services Owned
                let servicesOwnedCell = row.insertCell();
                servicesOwnedCell.innerText = team.teamId && teamServicesMap[team.teamId] ? teamServicesMap[team.teamId].join(', ') : 'None';
            }); // End teams.forEach
        } // End sdmId loop
    } // End srMgrId loop
    // -------------------------

    // --- Populate Footer Totals ---
    const totalGap = totalFundedHC - totalBIS;
    document.getElementById('totalFundedHC').innerText = totalFundedHC;
    document.getElementById('totalBIS').innerText = totalBIS;
    document.getElementById('totalGap').innerText = totalGap;
    document.getElementById('totalGap').style.color = totalGap < 0 ? 'red' : (totalGap > 0 ? 'orange' : 'green');

    let gapNoteText = `Overall Gap: ${totalGap} engineer(s). `;
    if (totalGap > 0) {
        gapNoteText += `(Need to hire ${totalGap})`;
    } else if (totalGap < 0) {
        gapNoteText += `(Over headcount by ${Math.abs(totalGap)})`;
    } else {
        gapNoteText += `(Fully staffed to funded count)`;
    }
    document.getElementById('gapNote').innerText = gapNoteText;
    // ---------------------------

    // --- Populate Level Key ---
    const levelKeyElement = document.getElementById('levelKey');
    if (levelKeyElement) {
        levelKeyElement.innerHTML = `Level Key: L1=SDE 1 (Junior), L2=SDE 2 (Intermediate), L3=SDE 3 (Senior), L4=Principal SDE, L5=Senior Principal SDE`;
    }
    // ------------------------
}

/** Enter Edit Mode **/

function enterEditMode(creatingNewSystem) {
     if (creatingNewSystem === true) {
          currentMode = Modes.CREATING;
     }
      else {
        currentMode = Modes.EDITNG;
     }
     
    // Show the system edit form
    showSystemEditForm(currentSystemData);
}

/** Show System Edit Form **/

function showSystemEditForm(systemData) {
    // Show the form
    document.getElementById('systemEditForm').style.display = 'block';
    // Hide other sections
    document.getElementById('visualization').style.display = 'none';
    document.getElementById('teamVisualization').style.display = 'none';
    document.getElementById('teamBreakdown').style.display = 'none';
    document.querySelector('.edit-menu').style.display = 'none';
    document.querySelector('.menu').style.display = 'none'; 
    document.getElementById('serviceRelationshipsVisualization').style.display = 'none';
    document.getElementById('dependencyVisualization').style.display = 'none';    
    document.getElementById('serviceDependenciesTable').style.display = 'none';    
    document.getElementById('organogramView').style.display = 'none';
    document.getElementById('engineerTableView').style.display = 'none';

    // Populate system name and description
    document.getElementById('systemNameInput').value = systemData.systemName || '';
    console.log("*** 0 document.getElementById('systemNameInput').value",document.getElementById('systemNameInput').value);
    
    document.getElementById('systemDescriptionInput').value = systemData.systemDescription || '';

    // Populate services
    displayServicesForEditing(systemData.services || [], 'editServicesManagement');

    // Populate teams
    displayTeamsForEditing(systemData.teams || []);
    
}

/** Helper to create Label + Input pairs */
function createInputLabelPair(id, labelText, value, type = 'text', index, field) {
    let div = document.createElement('div');
    div.style.marginBottom = '10px';
    let label = document.createElement('label');
    label.htmlFor = id;
    label.innerText = labelText;
    label.style.display = 'block';

    let input;
    if (type === 'textarea') {
         input = document.createElement('textarea');
         input.rows = 2;
         input.style.width = '90%';
    } else {
         input = document.createElement('input');
         input.type = type;
         if (type === 'number') {
             input.min = 0;
         }
         input.style.width = '90%';
    }
    input.id = id;
    input.value = value;
    input.setAttribute('data-team-index', index); // Keep team index for context
    input.setAttribute('data-field', field);

    input.addEventListener('change', (event) => {
         const teamIndex = parseInt(event.target.getAttribute('data-team-index'));
         const fieldName = event.target.getAttribute('data-field');
         let V = event.target.value;
         if (event.target.type === 'number') {
             V = parseInt(V);
             if (isNaN(V)) V = 0;
         }
         // Ensure teams array and index are valid before updating
         if (currentSystemData && currentSystemData.teams && teamIndex >= 0 && teamIndex < currentSystemData.teams.length) {
            currentSystemData.teams[teamIndex][fieldName] = V;
         } else {
             console.warn(`Could not update team data for index ${teamIndex}, field ${fieldName}`);
         }
    });

    div.appendChild(label);
    div.appendChild(input);
    return div;
}
// -----------------------------------

/** Helper to display Senior Manager Assignment UI within SDM section */
function displaySeniorManagerAssignment(sdmSectionContainer, teamIndex, currentSdmId) {
    // Find the specific container using teamIndex (or could use sdmId if unique)
    let srMgrContainer = sdmSectionContainer.querySelector(`#srMgrAssignmentContainer_${teamIndex}`);
    if (!srMgrContainer) {
         console.error("Could not find Sr Mgr container for team index", teamIndex);
         return;
     }
    srMgrContainer.innerHTML = ''; // Clear previous content
    srMgrContainer.style.paddingLeft = '20px'; // Indent slightly

    // Ensure global data is available
    const allSdms = currentSystemData.sdms || [];
    const allSeniorManagers = currentSystemData.seniorManagers || [];

    const currentSdm = allSdms.find(sdm => sdm && sdm.sdmId === currentSdmId);

    if (!currentSdm) {
        srMgrContainer.innerText = 'Assign an SDM to manage Senior Manager assignment.';
        return; // No SDM assigned, nothing to show
    }

    let title = document.createElement('h6');
    title.innerText = `Senior Manager for SDM: ${currentSdm.sdmName}`;
    srMgrContainer.appendChild(title);

    const currentSrMgr = allSeniorManagers.find(sr => sr && sr.seniorManagerId === currentSdm.seniorManagerId);

    const srMgrDualList = createDualListContainer( // Call global helper
        teamIndex, // Pass teamIndex for context if needed by callbacks
        'Current Sr. Mgr:', 'Available Sr. Mgrs:',
        currentSrMgr ? [{ value: currentSrMgr.seniorManagerId, text: currentSrMgr.seniorManagerName }] : [],
        allSeniorManagers.filter(sr => sr && sr.seniorManagerId !== currentSdm.seniorManagerId)
                         .map(sr => ({ value: sr.seniorManagerId, text: sr.seniorManagerName })), // Map to value/text
        `currentSrMgr_${currentSdmId}`, // Field names specific to this SDM
        `availableSrMgrs_${currentSdmId}`,
        (movedSrMgrId, direction) => { // Callback on Sr Mgr move
            // Find the SDM in the main data again to modify it
            const sdmToUpdate = currentSystemData.sdms.find(s => s.sdmId === currentSdmId);
            if (sdmToUpdate) {
                 sdmToUpdate.seniorManagerId = (direction === 'add') ? movedSrMgrId : null;
                 console.log(`Set Sr Mgr for SDM ${currentSdmId} to ${sdmToUpdate.seniorManagerId}`);
             } else {
                 console.warn("Could not find SDM to update Sr Mgr for:", currentSdmId);
             }
        },
        false, // singleSelectLeft = true for current Sr Mgr (set multiSelectLeft to false)
        true, // Allow adding new Sr Mgrs
        'Enter New Sr. Manager Name',
        (newSrMgrName) => { // Callback for adding new Sr Mgr
            if (!newSrMgrName || newSrMgrName.trim() === '') return null;
            newSrMgrName = newSrMgrName.trim();
            let existingSrMgr = (currentSystemData.seniorManagers || []).find(s => s && s.seniorManagerName.toLowerCase() === newSrMgrName.toLowerCase()); // check s
            if (existingSrMgr) {
                alert(`Senior Manager "${newSrMgrName}" already exists.`);
                return null;
            }
            const newSrMgrId = 'srMgr-' + Date.now();
            const newSrMgr = { seniorManagerId: newSrMgrId, seniorManagerName: newSrMgrName };
            if (!currentSystemData.seniorManagers) currentSystemData.seniorManagers = []; // Ensure array exists
            currentSystemData.seniorManagers.push(newSrMgr); // Add to main data
            // We might need to update the local 'allSeniorManagers' if it's used elsewhere before a full refresh
            console.log("Added new Senior Manager:", newSrMgr);
            return { value: newSrMgrId, text: newSrMgrName }; // Return for UI update
        }
    );
    srMgrContainer.appendChild(srMgrDualList);
 }
// -----------------------------------

/** Helper to create Dual List Selectors */
function createDualListContainer(contextIndex, leftLabel, rightLabel, currentOptions, availableOptions, leftField, rightField, moveCallback, multiSelectLeft = true, allowAddNew = false, addNewPlaceholder = '', addNewCallback = null) {
    let container = document.createElement('div');
    container.className = 'dual-list-container';
    container.style.display = 'flex';
    container.style.alignItems = 'center';
    container.style.marginBottom = '10px';

    // Left List (Current)
    let leftDiv = document.createElement('div');
    leftDiv.style.flex = '1'; leftDiv.style.marginRight = '5px';
    let currentLabel = document.createElement('label');
    currentLabel.innerText = leftLabel; currentLabel.style.display = 'block';
    let currentSelect = document.createElement('select');
    currentSelect.multiple = multiSelectLeft; currentSelect.size = 5; currentSelect.style.width = '100%';
    currentSelect.setAttribute('data-list-context-index', contextIndex);
    currentSelect.setAttribute('data-field', leftField);
    (currentOptions || []).forEach(opt => currentSelect.appendChild(new Option(opt.text, opt.value)));
    leftDiv.appendChild(currentLabel); leftDiv.appendChild(currentSelect);

    // Buttons
    let buttonsDiv = document.createElement('div');
    buttonsDiv.style.display = 'flex'; buttonsDiv.style.flexDirection = 'column'; buttonsDiv.style.alignItems = 'center'; buttonsDiv.style.margin = '0 5px';
    let removeBtn = document.createElement('button'); removeBtn.type = 'button'; removeBtn.innerHTML = '&gt;'; removeBtn.title = 'Remove selected item(s)'; removeBtn.style.marginBottom = '5px';
    let addBtn = document.createElement('button'); addBtn.type = 'button'; addBtn.innerHTML = '&lt;'; addBtn.title = 'Add selected item(s)';

    // Right List (Available)
    let rightDiv = document.createElement('div');
    rightDiv.style.flex = '1'; rightDiv.style.marginLeft = '5px';
    let availableLabel = document.createElement('label');
    availableLabel.innerText = rightLabel; availableLabel.style.display = 'block';
    let availableSelect = document.createElement('select');
    availableSelect.multiple = true; availableSelect.size = 5; availableSelect.style.width = '100%';
    availableSelect.setAttribute('data-list-context-index', contextIndex);
    availableSelect.setAttribute('data-field', rightField);
    (availableOptions || []).forEach(opt => availableSelect.appendChild(new Option(opt.text, opt.value)));
    rightDiv.appendChild(availableLabel); rightDiv.appendChild(availableSelect);

    // Add New Item Input/Button
    let addNewContainer = null;
    if (allowAddNew && addNewCallback) {
        addNewContainer = document.createElement('div'); addNewContainer.style.marginTop = '5px'; addNewContainer.style.display = 'flex';
        let addNewInput = document.createElement('input'); addNewInput.type = 'text'; addNewInput.placeholder = addNewPlaceholder; addNewInput.style.flexGrow = '1'; addNewInput.style.marginRight = '5px';
        let addNewBtn = document.createElement('button'); addNewBtn.type = 'button'; addNewBtn.innerText = 'Add';
        addNewBtn.onclick = (e) => {
            e.preventDefault();
            const newItemData = addNewCallback(addNewInput.value);
            if (newItemData && newItemData.value && newItemData.text) {
                 const exists = Array.from(availableSelect.options).some(opt => opt.value === newItemData.value) || Array.from(currentSelect.options).some(opt => opt.value === newItemData.value);
                 if (!exists) { availableSelect.appendChild(new Option(newItemData.text, newItemData.value)); }
                 else if (!newItemData.preventAdd) { console.warn("Item already exists in lists:", newItemData.text); }
                 addNewInput.value = '';
             } else if (newItemData && newItemData.preventAdd) { addNewInput.value = ''; }
        };
        addNewContainer.appendChild(addNewInput); addNewContainer.appendChild(addNewBtn);
        rightDiv.appendChild(addNewContainer);
    }

    // Button Actions
    removeBtn.onclick = (e) => {
         e.preventDefault();
        Array.from(currentSelect.selectedOptions).forEach(option => { availableSelect.appendChild(option); moveCallback(option.value, 'remove', contextIndex); });
    };
    addBtn.onclick = (e) => {
         e.preventDefault();
        Array.from(availableSelect.selectedOptions).forEach(option => {
             if (!multiSelectLeft) {
                 while (currentSelect.options.length > 0) { let existingOption = currentSelect.options[0]; availableSelect.appendChild(existingOption); moveCallback(existingOption.value, 'remove', contextIndex); }
             }
             currentSelect.appendChild(option); moveCallback(option.value, 'add', contextIndex);
        });
    };

    buttonsDiv.appendChild(addBtn); buttonsDiv.appendChild(removeBtn);
    container.appendChild(leftDiv); container.appendChild(buttonsDiv); container.appendChild(rightDiv);
    return container;
} // --- End createDualListContainer ---

/** Display Teams for Editing **/
/** REVISED Display Teams for Editing - Calls Global Helpers */
function displayTeamsForEditing(teams, expandedIndex = -1) {
    const teamsDiv = document.getElementById('teamsManagement');
    teamsDiv.innerHTML = ''; // Clear existing content

    // Pre-fetch global lists
    const allServices = (currentSystemData.services || []).map(service => ({
        value: service.serviceName,
        text: service.serviceName,
        owningTeamId: service.owningTeamId || null
    }));
    const allSdms = currentSystemData.sdms || [];
    const allPmts = currentSystemData.pmts || [];
    const allSeniorManagers = currentSystemData.seniorManagers || [];

    // Calculate Available Engineers map
    let allEngineerNamesMap = new Map();
    (currentSystemData.teams || []).forEach(t => {
        (t.engineers || []).forEach(eng => {
            if (eng && eng.name) {
                if (!allEngineerNamesMap.has(eng.name)) {
                    allEngineerNamesMap.set(eng.name, new Set());
                }
                allEngineerNamesMap.get(eng.name).add(t.teamId);
            }
        });
    });

    (teams || []).forEach((team, index) => {
        if (!team) {
            console.warn("Skipping invalid team object at index", index);
            return;
        }

        let teamDiv = document.createElement('div');
        teamDiv.className = 'team-edit';
        teamDiv.setAttribute('data-team-render-index', index);

        // Header (collapsible)
        let teamHeader = document.createElement('h4');
        teamHeader.style.cursor = 'pointer';
        let indicator = document.createElement('span');
        indicator.innerText = (index === expandedIndex) ? '- ' : '+ ';
        teamHeader.appendChild(indicator);
        teamHeader.appendChild(document.createTextNode(`Team: ${team.teamIdentity || team.teamName || 'New Team'}`));

        let teamDetails = document.createElement('div');
        teamDetails.className = 'team-details';
        teamDetails.style.display = (index === expandedIndex) ? 'block' : 'none';

        // --- Modified Onclick Handler ---
        teamHeader.onclick = () => {
            const content = teamDetails;
            const isCurrentlyCollapsed = content.style.display === 'none' || content.style.display === '';
            content.style.display = isCurrentlyCollapsed ? 'block' : 'none';
            indicator.innerText = isCurrentlyCollapsed ? '- ' : '+ ';

            // Refresh Available Services when EXPANDING
            if (isCurrentlyCollapsed) {
                 console.log("Refreshing available services for team:", team.teamName || team.teamIdentity);
                 const latestAllServices = (currentSystemData.services || []).map(service => ({
                    value: service.serviceName, text: service.serviceName, owningTeamId: service.owningTeamId || null
                 }));
                 const currentServicesSelect = content.querySelector("select[data-field='currentServices']");
                 const availableServicesSelect = content.querySelector("select[data-field='availableServices']");

                 if (currentServicesSelect && availableServicesSelect) {
                    const currentlyAssignedServices = Array.from(currentServicesSelect.options).map(opt => opt.value);
                    availableServicesSelect.innerHTML = '';
                    latestAllServices.forEach(svcOption => {
                        if (!currentlyAssignedServices.includes(svcOption.value)) {
                             availableServicesSelect.appendChild(new Option(svcOption.text, svcOption.value));
                        }
                    });
                    console.log("Available services list updated.");
                 } else {
                      console.warn("Could not find service select lists to refresh for team index", index);
                 }
                  // Also refresh Sr Mgr assignment display on expand, in case SDM changed
                  displaySeniorManagerAssignment(teamDetails.querySelector(`#sdmSection_${index}`), index, team.sdmId); // Pass the SDM section container
            }
        }; // --- End MODIFIED Onclick Handler ---


        // --- Basic Info Inputs ---
        teamDetails.appendChild(createInputLabelPair(`teamIdentity_${index}`, 'Team Identity:', team.teamIdentity || '', 'text', index, 'teamIdentity'));
        teamDetails.appendChild(createInputLabelPair(`teamName_${index}`, 'Team Name:', team.teamName || '', 'text', index, 'teamName'));
        teamDetails.appendChild(createInputLabelPair(`teamDescription_${index}`, 'Team Description:', team.teamDescription || '', 'textarea', index, 'teamDescription'));
        // -------------------------

        // --- Services Owned ---
        const currentServices = allServices.filter(s => s.owningTeamId === team.teamId);
        const availableServices = allServices.filter(s => s.owningTeamId !== team.teamId);
        const servicesContainer = createDualListContainer( // Call global helper
            index, 'Services Owned:', 'Available Services:',
            currentServices, availableServices,
            'currentServices', 'availableServices',
            (movedOptionValue, direction, contextIndex) => {
                const service = currentSystemData.services.find(s => s.serviceName === movedOptionValue);
                const targetTeam = currentSystemData.teams[contextIndex];
                if (service && targetTeam) {
                    service.owningTeamId = (direction === 'add') ? targetTeam.teamId : null;
                }
            }
        );
        teamDetails.appendChild(servicesContainer);
        teamDetails.appendChild(document.createElement('br'));
        // -------------------------------------------

        // --- SDM Assignment & Senior Manager Assignment ---
        const sdmSection = document.createElement('div');
        sdmSection.id = `sdmSection_${index}`; // Give ID for Sr Mgr refresh targeting
        sdmSection.style.border = '1px dashed #ccc'; sdmSection.style.padding = '10px'; sdmSection.style.marginBottom = '10px';
        let sdmSectionTitle = document.createElement('h5'); sdmSectionTitle.innerText = 'SDM Assignment'; sdmSection.appendChild(sdmSectionTitle);

        const currentSdm = allSdms.find(sdm => sdm && sdm.sdmId === team.sdmId);
        const sdmContainer = createDualListContainer( // Call global helper
            index, 'Current SDM:', 'Available SDMs:',
            currentSdm ? [{ value: currentSdm.sdmId, text: currentSdm.sdmName }] : [],
            allSdms.filter(sdm => sdm && sdm.sdmId !== team.sdmId).map(sdm => ({ value: sdm.sdmId, text: sdm.sdmName })),
            'currentSdm', 'availableSdms',
            (movedOptionValue, direction, contextIndex) => {
                 const targetTeam = currentSystemData.teams[contextIndex];
                 if(targetTeam){
                    const newSdmId = (direction === 'add') ? movedOptionValue : null;
                    targetTeam.sdmId = newSdmId;
                    // Refresh Sr. Mgr section using the specific sdmSection container
                    displaySeniorManagerAssignment(sdmSection, contextIndex, newSdmId);
                 }
            },
            false, true, 'Enter New SDM Name',
            (newSdmName) => {
                 if (!newSdmName || newSdmName.trim() === '') return null; newSdmName = newSdmName.trim();
                 let existingSdm = allSdms.find(s => s && s.sdmName.toLowerCase() === newSdmName.toLowerCase());
                 if (existingSdm) { alert(`SDM "${newSdmName}" already exists.`); return null; }
                 const newSdmId = 'sdm-' + Date.now(); const newSdm = { sdmId: newSdmId, sdmName: newSdmName, seniorManagerId: null };
                 currentSystemData.sdms.push(newSdm); allSdms.push(newSdm); // Update local cache too
                 console.log("Added new SDM:", newSdm);
                 return { value: newSdmId, text: newSdmName };
            }
        );
        sdmSection.appendChild(sdmContainer);

        let srMgrAssignmentContainer = document.createElement('div'); srMgrAssignmentContainer.id = `srMgrAssignmentContainer_${index}`; srMgrAssignmentContainer.style.marginTop = '10px';
        sdmSection.appendChild(srMgrAssignmentContainer); // Add placeholder

        teamDetails.appendChild(sdmSection); teamDetails.appendChild(document.createElement('br'));

        displaySeniorManagerAssignment(sdmSection, index, team.sdmId); // Initial population
        // ---------------------------------------------------

        // --- PMT Assignment ---
         const currentPmt = allPmts.find(pmt => pmt && pmt.pmtId === team.pmtId);
         const pmtContainer = createDualListContainer( // Call global helper
             index, 'Current PMT:', 'Available PMTs:',
             currentPmt ? [{ value: currentPmt.pmtId, text: currentPmt.pmtName }] : [],
             allPmts.filter(pmt => pmt && pmt.pmtId !== team.pmtId).map(pmt => ({ value: pmt.pmtId, text: pmt.pmtName })),
             'currentPmt', 'availablePmts',
             (movedOptionValue, direction, contextIndex) => {
                 const targetTeam = currentSystemData.teams[contextIndex];
                 if(targetTeam) targetTeam.pmtId = (direction === 'add') ? movedOptionValue : null;
             },
             false, true, 'Enter New PMT Name',
             (newPmtName) => {
                 if (!newPmtName || newPmtName.trim() === '') return null; newPmtName = newPmtName.trim();
                 let existingPmt = allPmts.find(p => p && p.pmtName.toLowerCase() === newPmtName.toLowerCase());
                 if (existingPmt) { alert(`PMT "${newPmtName}" already exists.`); return null; }
                 const newPmtId = 'pmt-' + Date.now(); const newPmt = { pmtId: newPmtId, pmtName: newPmtName };
                 currentSystemData.pmts.push(newPmt); allPmts.push(newPmt); // Update local cache
                 console.log("Added new PMT:", newPmt); return { value: newPmtId, text: newPmtName };
             }
         );
         teamDetails.appendChild(pmtContainer); teamDetails.appendChild(document.createElement('br'));
        // -------------------------------------------

        // --- Headcount ---
        teamDetails.appendChild(createInputLabelPair(`fundedHeadcount_${index}`, 'Funded Headcount:', team.fundedHeadcount ?? 0, 'number', index, 'fundedHeadcount'));
        let bisDiv = document.createElement('div'); bisDiv.style.marginTop = '10px';
        let bisLabel = document.createElement('label'); bisLabel.innerText = 'Builders In Seats (BIS): ';
        let bisValueSpan = document.createElement('span'); bisValueSpan.id = `bisValue_${index}`; bisValueSpan.innerText = team.engineers?.length ?? 0; team.buildersInSeats = team.engineers?.length ?? 0; bisValueSpan.style.fontWeight = 'bold';
        bisDiv.appendChild(bisLabel); bisDiv.appendChild(bisValueSpan);
        teamDetails.appendChild(bisDiv); teamDetails.appendChild(document.createElement('br'));
        // -----------------

        // --- Engineer Assignment ---
        let engineersSectionTitle = document.createElement('h5'); engineersSectionTitle.innerText = 'Engineer Assignment'; engineersSectionTitle.style.marginTop = '15px'; teamDetails.appendChild(engineersSectionTitle);
        const currentEngineerOptions = (team.engineers || []).map(eng => ({ value: eng.name, text: eng.name }));
        const availableEngineerOptions = Array.from(allEngineerNamesMap.keys()).filter(name => !(team.engineers || []).some(eng => eng.name === name)).map(name => ({ value: name, text: name }));
        const engineerContainer = createDualListContainer( // Call global helper
            index, 'Current Engineers:', 'Available Engineers:', currentEngineerOptions, availableEngineerOptions,
            'currentEngineers', 'availableEngineers',
            (movedEngineerName, direction, contextIndex) => {
                const currentTeam = currentSystemData.teams[contextIndex]; if (!currentTeam) return;
                if (direction === 'add') {
                    // Remove engineer from other teams first
                    currentSystemData.teams.forEach(otherTeam => {
                        if (otherTeam.teamId !== currentTeam.teamId && otherTeam.engineers) {
                            const initialLength = otherTeam.engineers.length;
                            otherTeam.engineers = otherTeam.engineers.filter(eng => eng.name !== movedEngineerName);
                            if (otherTeam.engineers.length < initialLength) { // If removed, update BIS
                                otherTeam.buildersInSeats = otherTeam.engineers.length;
                                // TODO: Optionally update the UI for the *other* team's BIS count immediately
                                // const otherBisSpan = document.querySelector(`[data-team-render-index='${/* find other team index */}'] #bisValue_${/* other team index */}`);
                                // if (otherBisSpan) otherBisSpan.innerText = otherTeam.buildersInSeats;
                                console.log(`Removed ${movedEngineerName} from team ${otherTeam.teamId}`);
                            }
                        }
                    });
                    // Add engineer to current team if not already present
                    if (!currentTeam.engineers.some(eng => eng.name === movedEngineerName)) { currentTeam.engineers.push({ name: movedEngineerName, level: 1 }); console.log(`Added ${movedEngineerName} to team ${currentTeam.teamId}`); }
                } else { // Remove from current team
                    currentTeam.engineers = currentTeam.engineers.filter(eng => eng.name !== movedEngineerName); console.log(`Removed ${movedEngineerName} from team ${currentTeam.teamId}`);
                }
                // Update BIS display for the current team
                currentTeam.buildersInSeats = currentTeam.engineers.length; const bisValSpan = document.getElementById(`bisValue_${contextIndex}`); if (bisValSpan) bisValSpan.innerText = currentTeam.buildersInSeats;
            },
            true, true, 'Enter New Engineer Name',
            (newEngineerName) => {
                 if (!newEngineerName || newEngineerName.trim() === '') return null; newEngineerName = newEngineerName.trim();
                 if (allEngineerNamesMap.has(newEngineerName)) { alert(`Engineer "${newEngineerName}" already exists...`); return null; }
                 team.engineers.push({ name: newEngineerName, level: 1 }); allEngineerNamesMap.set(newEngineerName, new Set([team.teamId])); // Update global map
                 team.buildersInSeats = team.engineers.length; const bisValSpan = document.getElementById(`bisValue_${index}`); if (bisValSpan) bisValSpan.innerText = team.buildersInSeats; console.log("Added new engineer:", newEngineerName);
                 const currentEngSelect = engineerContainer.querySelector("select[data-field='currentEngineers']"); if(currentEngSelect) currentEngSelect.appendChild(new Option(newEngineerName, newEngineerName));
                 return { preventAdd: true };
            }
        );
        engineerContainer.id = `engineersList_${index}`; teamDetails.appendChild(engineerContainer);
        let levelEditNote = document.createElement('p'); levelEditNote.style.fontSize = '0.8em'; levelEditNote.style.color = 'grey'; levelEditNote.innerText = '(Note: Engineer levels default to L1. Level editing NYI.)';
        teamDetails.appendChild(levelEditNote); teamDetails.appendChild(document.createElement('br'));
        // -----------------------------------------


        // --- Action Buttons ---
        let saveButton = document.createElement('button'); saveButton.type = 'button'; saveButton.innerText = 'Save Team Changes'; saveButton.onclick = () => saveTeamChanges(index); teamDetails.appendChild(saveButton);
        let deleteButton = document.createElement('button'); deleteButton.type = 'button'; deleteButton.innerText = 'Delete Team'; deleteButton.style.marginLeft = '10px'; deleteButton.style.color = 'red'; deleteButton.onclick = () => deleteTeam(index); teamDetails.appendChild(deleteButton);
        // --------------------

        teamDiv.appendChild(teamHeader); teamDiv.appendChild(teamDetails); teamsDiv.appendChild(teamDiv);
    }); // End teams.forEach
} // --- End displayTeamsForEditing ---


function updateTeamSize(teamIndex, newSize) {
    currentSystemData.teams[teamIndex].sizeOfTeam = newSize;

    // Update the UI element for "Size of Team"
    const teamDiv = document.querySelectorAll('.team-edit')[teamIndex];
    const sizeInput = teamDiv.querySelector('input[data-field="sizeOfTeam"]');
    sizeInput.value = newSize;

    // **Update sizeOfTeam in currentSystemData**
    currentSystemData.teams[teamIndex].sizeOfTeam = newSize;
}

function updateAvailableEngineersInOtherTeams(engineerName, assignedTeamId) {
    // Loop through all teams
    currentSystemData.teams.forEach((team, idx) => {
        // Skip the team where the engineer was just added or removed
        if (team.teamId === assignedTeamId) {
            return;
        }

        const teamDiv = document.querySelectorAll('.team-edit')[idx];
        const availableEngineersSelect = teamDiv.querySelector('select[data-field="availableEngineers"]');
        const currentEngineersSelect = teamDiv.querySelector('select[data-field="currentEngineers"]');

        if (assignedTeamId) {
            // Remove from availableEngineersSelect
            const option = Array.from(availableEngineersSelect.options).find(opt => opt.value === engineerName);
            if (option) {
                availableEngineersSelect.removeChild(option);
            }
        } else {
            // Add to availableEngineersSelect if not already present
            const optionExists = Array.from(availableEngineersSelect.options).some(opt => opt.value === engineerName);
            const inCurrentEngineers = Array.from(currentEngineersSelect.options).some(opt => opt.value === engineerName);
            if (!optionExists && !inCurrentEngineers) {
                let option = document.createElement('option');
                option.value = engineerName;
                option.text = engineerName;
                availableEngineersSelect.appendChild(option);
            }
        }
    });
}

function updateAvailableServicesInOtherTeams(serviceName, assignedTeamId) {
    // Loop through all teams
    currentSystemData.teams.forEach((team, idx) => {
        // Skip the team where the service was just added or removed
        if (team.teamId === assignedTeamId) {
            return;
        }

        const teamDiv = document.querySelectorAll('.team-edit')[idx];
        const availableServicesSelect = teamDiv.querySelector('select[data-field="availableServices"]');
        const currentServicesSelect = teamDiv.querySelector('select[data-field="currentServices"]');

        if (assignedTeamId) {
            // Remove from availableServicesSelect
            const option = Array.from(availableServicesSelect.options).find(opt => opt.value === serviceName);
            if (option) {
                availableServicesSelect.removeChild(option);
            }
        } else {
            // Add to availableServicesSelect if not already present
            const optionExists = Array.from(availableServicesSelect.options).some(opt => opt.value === serviceName);
            const inCurrentServices = Array.from(currentServicesSelect.options).some(opt => opt.value === serviceName);
            if (!optionExists && !inCurrentServices) {
                let option = document.createElement('option');
                option.value = serviceName;
                option.text = serviceName;
                availableServicesSelect.appendChild(option);
            }
        }
    });
}

function removeServiceFromPreviousTeam(serviceName, prevTeamId) {
    const prevTeamIndex = currentSystemData.teams.findIndex(t => t.teamId === prevTeamId);
    if (prevTeamIndex !== -1) {
        const prevTeamDiv = document.querySelectorAll('.team-edit')[prevTeamIndex];
        const prevCurrentServicesSelect = prevTeamDiv.querySelector('select[data-field="currentServices"]');
        const prevOption = Array.from(prevCurrentServicesSelect.options).find(opt => opt.value === serviceName);
        if (prevOption) {
            prevCurrentServicesSelect.removeChild(prevOption);
            // Add to availableServicesSelect of previous team
            const prevAvailableServicesSelect = prevTeamDiv.querySelector('select[data-field="availableServices"]');
            prevAvailableServicesSelect.appendChild(prevOption.cloneNode(true));
        }
    }
}

function removeEngineerFromPreviousTeam(engineerName, prevTeamId) {
    const prevTeamIndex = currentSystemData.teams.findIndex(t => t.teamId === prevTeamId);
    if (prevTeamIndex !== -1) {
        const prevTeamDiv = document.querySelectorAll('.team-edit')[prevTeamIndex];
        const prevCurrentEngineersSelect = prevTeamDiv.querySelector('select[data-field="currentEngineers"]');
        const prevOption = Array.from(prevCurrentEngineersSelect.options).find(opt => opt.value === engineerName);
        if (prevOption) {
            prevCurrentEngineersSelect.removeChild(prevOption);
            // Update uniqueEngineers
            const engineer = uniqueEngineers.find(e => e.engineerName === engineerName);
            if (engineer) engineer.teamId = null;
        }
    }
}

function validateTeamChanges() {
    // Check for engineers assigned to multiple teams
    const engineerAssignments = {};
    currentSystemData.teams.forEach(team => {
        const teamEngineers = team.engineerNames ? team.engineerNames.split(',').map(name => name.trim()) : [];
        teamEngineers.forEach(engineerName => {
            if (engineerName) {
                if (engineerAssignments[engineerName]) {
                    engineerAssignments[engineerName].push(team.teamName || team.teamIdentity || 'Unnamed Team');
                } else {
                    engineerAssignments[engineerName] = [team.teamName || team.teamIdentity || 'Unnamed Team'];
                }
            }
        });
    });

    const conflictingEngineers = Object.entries(engineerAssignments).filter(([_, teams]) => teams.length > 1);

    // Check for services owned by multiple teams
    const serviceAssignments = {};
    currentSystemData.services.forEach(service => {
        if (service.owningTeamId) {
            if (serviceAssignments[service.serviceName]) {
                serviceAssignments[service.serviceName].push(service.owningTeamId);
            } else {
                serviceAssignments[service.serviceName] = [service.owningTeamId];
            }
        }
    });

    const conflictingServices = Object.entries(serviceAssignments).filter(([_, teams]) => teams.length > 1);

    let validationErrors = '';

    if (conflictingEngineers.length > 0) {
        validationErrors += 'The following engineers are assigned to multiple teams:\n';
        conflictingEngineers.forEach(([engineerName, teams]) => {
            validationErrors += `- ${engineerName}: ${teams.join(', ')}\n`;
        });
    }

    if (conflictingServices.length > 0) {
        validationErrors += 'The following services are owned by multiple teams:\n';
        conflictingServices.forEach(([serviceName, teamIds]) => {
            const teamNames = teamIds.map(teamId => {
                const team = currentSystemData.teams.find(t => t.teamId === teamId);
                return team ? (team.teamName || team.teamIdentity || 'Unnamed Team') : 'Unknown Team';
            });
            validationErrors += `- ${serviceName}: ${teamNames.join(', ')}\n`;
        });
    }

    if (validationErrors) {
        alert('Validation Errors:\n' + validationErrors);
        return false;
    }

    return true;
}


/** Updated Save Team Changes **/
/** Updated Save Team Changes - Includes Collapse Logic & Validation Call **/
function saveTeamChanges(index) {
    // Get the specific team object
    if (!currentSystemData || !currentSystemData.teams || index >= currentSystemData.teams.length) {
        console.error("Cannot save team, invalid index or data:", index);
        return;
    }
    const team = currentSystemData.teams[index];

    // --- Data is assumed to be updated by input listeners and dual-list callbacks ---

    // Recalculate Builders In Seats just to be sure it matches the array
    team.buildersInSeats = team.engineers ? team.engineers.length : 0;

    // Validate required fields for this team
    if (!team.teamIdentity || !team.teamName) {
        alert('Team Identity and Team Name are required.');
        return; // Don't proceed if basic info missing
    }

    // *** Add cross-team validation before saving system state ***
    if (!validateEngineerAssignments()) { // Call validation function
        return; // Stop saving if validation fails
    }
    // *********************************************************

    console.log("Saving changes for team (via saveSystemChanges):", JSON.stringify(team, null, 2));

    // --- Save the entire system data to local storage ---
    saveSystemChanges(); // This function now also includes validation internally

    // --- Update related UI elements ---
    generateTeamTable(currentSystemData); // Update main Team Breakdown table
    generateTeamVisualization(currentSystemData); // Update Team Visualization

    alert(`Changes for team "${team.teamName || team.teamIdentity}" potentially saved (system state saved).`);

    // --- Collapse the edit section after saving attempt ---
    const teamDivs = document.querySelectorAll('#teamsManagement .team-edit');
    if (index < teamDivs.length) {
         const teamDiv = teamDivs[index];
         const teamDetails = teamDiv.querySelector('.team-details');
         const indicator = teamDiv.querySelector('h4 > span');
         // Check if elements exist before modifying
         if (teamDetails) teamDetails.style.display = 'none';
         if (indicator) indicator.innerText = '+ ';
     }
    // -----------------------------------------------------
}


/** Display Services for Editing **/

/** REVISED Display Services for Editing - Refresh on Add Platform Dep **/
function displayServicesForEditing(services, containerId, expandedIndex = -1) {
    const servicesDiv = document.getElementById(containerId);
    servicesDiv.innerHTML = ''; // Clear existing content

    // Get a list of existing teams for the owning team selection
    const teamOptions = (currentSystemData.teams || []).map(team => ({ // Added default empty array
        teamId: team.teamId,
        teamIdentity: team.teamIdentity
    }));

    // Ensure platformDependencies is initialized and rebuilt
    if (!currentSystemData.platformDependencies) {
        currentSystemData.platformDependencies = [];
    }

    (services || []).forEach((service, index) => { // Added default empty array
        if (!service) return; // Skip potentially null entries if array was modified externally

        let serviceDiv = document.createElement('div');
        serviceDiv.className = 'service-edit';
        serviceDiv.setAttribute('data-service-index', index); // Add index for easier selection

        // Header (collapsible)
        let serviceHeader = document.createElement('h4');
        // Ensure serviceName exists before using it
        const headerText = service.serviceName || 'New Service';
        serviceHeader.style.cursor = 'pointer';
        let indicator = document.createElement('span');
        indicator.innerText = (index === expandedIndex) ? '- ' : '+ '; // Set initial state based on expandedIndex
        serviceHeader.appendChild(indicator);
        serviceHeader.appendChild(document.createTextNode(`Service: ${headerText}`));

        // Details container
        let serviceDetails = document.createElement('div');
        serviceDetails.className = 'service-details';
        serviceDetails.style.display = (index === expandedIndex) ? 'block' : 'none'; // Set initial state

        // Toggle Functionality - Modified to refresh lists on expand
        serviceHeader.onclick = () => {
            const content = serviceDetails; // Use variable already defined
            const isCurrentlyCollapsed = content.style.display === 'none' || content.style.display === '';
            content.style.display = isCurrentlyCollapsed ? 'block' : 'none';
            indicator.innerText = isCurrentlyCollapsed ? '- ' : '+ ';

            // Refresh available lists only when expanding
            if (isCurrentlyCollapsed) {
                console.log("Refreshing lists on expand for service:", service.serviceName);
                // Refresh Available Platform Dependencies
                const otherPlatDepsSelect = content.querySelector('select[data-field="availablePlatformDependencies"]');
                const currentPlatDepsSelect = content.querySelector('select[data-field="currentPlatformDependencies"]');
                if (otherPlatDepsSelect && currentPlatDepsSelect) {
                    const currentPlatDeps = Array.from(currentPlatDepsSelect.options).map(opt => opt.value);
                    otherPlatDepsSelect.innerHTML = ''; // Clear
                     (currentSystemData.platformDependencies || []).forEach(dep => {
                        if (!currentPlatDeps.includes(dep)) {
                            otherPlatDepsSelect.appendChild(new Option(dep, dep));
                        }
                    });
                }

                // Refresh Available Service Dependencies
                const otherSvcDepsSelect = content.querySelector('select[data-field="availableServiceDependencies"]');
                const currentSvcDepsSelect = content.querySelector('select[data-field="currentServiceDependencies"]');
                if (otherSvcDepsSelect && currentSvcDepsSelect) {
                    const currentSvcDeps = Array.from(currentSvcDepsSelect.options).map(opt => opt.value);
                    otherSvcDepsSelect.innerHTML = ''; // Clear
                     (currentSystemData.services || []).forEach(otherSvc => {
                        if (otherSvc.serviceName !== service.serviceName && !currentSvcDeps.includes(otherSvc.serviceName)) {
                            otherSvcDepsSelect.appendChild(new Option(otherSvc.serviceName, otherSvc.serviceName));
                        }
                    });
                }

                // Refresh Available APIs for each API within this service
                const apiEditDivs = content.querySelectorAll('.api-edit');
                const allApisList = (currentSystemData.services || []).flatMap(s => (s.apis || []).map(a => a.apiName));
                apiEditDivs.forEach((apiDiv, apiIdx) => {
                     const currentApiName = service.apis[apiIdx]?.apiName; // Get current API name
                     const otherApiDepsSelect = apiDiv.querySelector('select[data-field="availableApis"]');
                     const currentApiDepsSelect = apiDiv.querySelector('select[data-field="currentDependentApis"]');
                     if (otherApiDepsSelect && currentApiDepsSelect && currentApiName) {
                         const currentApiDeps = Array.from(currentApiDepsSelect.options).map(opt => opt.value);
                         otherApiDepsSelect.innerHTML = ''; // Clear
                         allApisList.forEach(apiName => {
                             if (apiName !== currentApiName && !currentApiDeps.includes(apiName)) {
                                 otherApiDepsSelect.appendChild(new Option(apiName, apiName));
                             }
                         });
                     }
                 });
            }
        };

        // --- Service Name & Description ---
        let nameLabel = document.createElement('label');
        nameLabel.innerText = 'Service Name:';
        let nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = service.serviceName || '';
        nameInput.setAttribute('data-service-index', index);
        nameInput.setAttribute('data-field', 'serviceName');
        nameInput.addEventListener('change', handleServiceInputChange); // Use shared handler
        serviceDetails.appendChild(nameLabel); serviceDetails.appendChild(document.createElement('br'));
        serviceDetails.appendChild(nameInput); serviceDetails.appendChild(document.createElement('br'));

        let descLabel = document.createElement('label');
        descLabel.innerText = 'Service Description:';
        let descTextarea = document.createElement('textarea');
        descTextarea.rows = 2; descTextarea.style.width = '90%';
        descTextarea.value = service.serviceDescription || '';
        descTextarea.setAttribute('data-service-index', index);
        descTextarea.setAttribute('data-field', 'serviceDescription');
        descTextarea.addEventListener('change', handleServiceInputChange); // Use shared handler
        serviceDetails.appendChild(descLabel); serviceDetails.appendChild(document.createElement('br'));
        serviceDetails.appendChild(descTextarea); serviceDetails.appendChild(document.createElement('br'));
        // -----------------------------------

        // --- Platform Dependencies ---
        const currentPlatDeps = (service.platformDependencies || []).map(dep => ({ value: dep, text: dep }));
        const availablePlatDeps = (currentSystemData.platformDependencies || []).filter(dep => !(service.platformDependencies || []).includes(dep)).map(dep => ({ value: dep, text: dep }));
        const platformContainer = createDualListContainer(
            index, 'Current Platform Deps:', 'Available Platform Deps:',
            currentPlatDeps, availablePlatDeps,
            'currentPlatformDependencies', 'availablePlatformDependencies',
            (movedDep, direction, serviceIdx) => { // Callback updates data model directly
                const targetService = currentSystemData.services[serviceIdx];
                if (!targetService.platformDependencies) targetService.platformDependencies = [];
                if (direction === 'add') {
                    if (!targetService.platformDependencies.includes(movedDep)) targetService.platformDependencies.push(movedDep);
                } else {
                    targetService.platformDependencies = targetService.platformDependencies.filter(d => d !== movedDep);
                }
            },
            true, true, 'Enter New Platform Dependency', // multiSelectLeft = true, allowAddNew = true
            (newDepName) => { // Add New Callback for Platform Deps (Simplified like SDM/PMT)
                        const textInput = platformContainer.querySelector('input[type="text"]'); // Get input relative to this dual list
                        if (!newDepName || newDepName.trim() === '') {
                            if(textInput) textInput.value = ''; // Clear input even if empty
                            return null;
                        }
                        newDepName = newDepName.trim();

                        // Ensure global platform dependencies array exists
                        if (!currentSystemData.platformDependencies) {
                            currentSystemData.platformDependencies = [];
                        }

                        const alreadyExistsGlobally = currentSystemData.platformDependencies.includes(newDepName);

                        // Find the specific select lists for THIS service instance to check if already visible
                        const currentPlatDepsSelect = platformContainer.querySelector('select[data-field="currentPlatformDependencies"]');
                        const availablePlatDepsSelect = platformContainer.querySelector('select[data-field="availablePlatformDependencies"]');

                        if (!currentPlatDepsSelect || !availablePlatDepsSelect) {
                             console.error("Could not find platform dependency select lists for service index:", index);
                             if(textInput) textInput.value = '';
                             return null;
                         }

                        const inCurrentList = Array.from(currentPlatDepsSelect.options).some(opt => opt.value === newDepName);
                        const inAvailableList = Array.from(availablePlatDepsSelect.options).some(opt => opt.value === newDepName);

                        if (inCurrentList || inAvailableList) {
                             alert(`Platform dependency "${newDepName}" is already listed for this service.`);
                             if(textInput) textInput.value = '';
                             return null; // Already present for this service, do nothing more
                         }

                        // If it doesn't exist globally, add it to the global data list
                        if (!alreadyExistsGlobally) {
                            currentSystemData.platformDependencies.push(newDepName);
                            console.log("Added new global platform dependency to data:", newDepName);
                        } else {
                            console.log(`"${newDepName}" already exists globally.`);
                        }

                        // --- ALWAYS RETURN THE ITEM ---
                        // Let createDualListContainer handle adding it to the 'Available' list for *this instance*.
                        // The fact it's in currentSystemData.platformDependencies ensures it's available later.
                        if (textInput) textInput.value = ''; // Clear the input field
                        return { value: newDepName, text: newDepName };
                    }
        );
        serviceDetails.appendChild(platformContainer);
        serviceDetails.appendChild(document.createElement('br'));
        // ---------------------------

         // --- Service Dependencies ---
         const currentSvcDeps = (service.serviceDependencies || []).map(dep => ({ value: dep, text: dep }));
         const availableSvcDeps = (currentSystemData.services || [])
             .filter(s => s.serviceName !== service.serviceName && !(service.serviceDependencies || []).includes(s.serviceName))
             .map(s => ({ value: s.serviceName, text: s.serviceName }));
         const serviceDepContainer = createDualListContainer(
             index, 'Current Service Deps:', 'Available Services:',
             currentSvcDeps, availableSvcDeps,
             'currentServiceDependencies', 'availableServiceDependencies',
             (movedSvc, direction, serviceIdx) => { // Callback updates data model directly
                 const targetService = currentSystemData.services[serviceIdx];
                 if (!targetService.serviceDependencies) targetService.serviceDependencies = [];
                 if (direction === 'add') {
                     if (!targetService.serviceDependencies.includes(movedSvc)) targetService.serviceDependencies.push(movedSvc);
                 } else {
                     targetService.serviceDependencies = targetService.serviceDependencies.filter(d => d !== movedSvc);
                 }
             },
             true // multiSelectLeft = true
             // Cannot add new *services* from here, only from main 'Add New Service' button
         );
         serviceDetails.appendChild(serviceDepContainer);
         serviceDetails.appendChild(document.createElement('br'));
        // ------------------------

        // --- APIs Section ---
        let apisContainer = document.createElement('div');
        apisContainer.className = 'apis-container';
        let apisLabel = document.createElement('h5');
        apisLabel.innerText = 'APIs:'; apisLabel.style.marginTop = '15px';
        apisContainer.appendChild(apisLabel);

        const allApisList = (currentSystemData.services || []).flatMap(s => (s.apis || []).map(a => a.apiName));

        (service.apis || []).forEach((api, apiIndex) => {
            let apiDiv = document.createElement('div');
            apiDiv.className = 'api-edit';

            let apiNameLabel = document.createElement('label'); apiNameLabel.innerText = 'API Name:';
            let apiNameInput = document.createElement('input'); apiNameInput.type = 'text'; apiNameInput.value = api.apiName || '';
            apiNameInput.setAttribute('data-service-index', index); apiNameInput.setAttribute('data-api-index', apiIndex); apiNameInput.setAttribute('data-field', 'apiName');
            apiNameInput.addEventListener('change', handleApiInputChange); // Use shared handler
            apiDiv.appendChild(apiNameLabel); apiDiv.appendChild(document.createElement('br'));
            apiDiv.appendChild(apiNameInput); apiDiv.appendChild(document.createElement('br'));

            let apiDescLabel = document.createElement('label'); apiDescLabel.innerText = 'API Description:';
            let apiDescTextarea = document.createElement('textarea'); apiDescTextarea.rows = 2; apiDescTextarea.style.width = '90%'; apiDescTextarea.value = api.apiDescription || '';
            apiDescTextarea.setAttribute('data-service-index', index); apiDescTextarea.setAttribute('data-api-index', apiIndex); apiDescTextarea.setAttribute('data-field', 'apiDescription');
            apiDescTextarea.addEventListener('change', handleApiInputChange); // Use shared handler
            apiDiv.appendChild(apiDescLabel); apiDiv.appendChild(document.createElement('br'));
            apiDiv.appendChild(apiDescTextarea); apiDiv.appendChild(document.createElement('br'));

            // API Dependencies Dual List
            const currentApiDeps = (api.dependentApis || []).map(dep => ({ value: dep, text: dep }));
            const availableApiDeps = allApisList
                .filter(aName => aName !== api.apiName && !(api.dependentApis || []).includes(aName))
                .map(aName => ({ value: aName, text: aName }));
            const apiDepsContainer = createDualListContainer(
                 apiIndex, // Context is the API index within the service
                 'Current API Deps:', 'Available APIs:',
                 currentApiDeps, availableApiDeps,
                 'currentDependentApis', 'availableApis',
                 (movedApi, direction, currentApiIndex) => { // Callback updates data model directly
                     const targetService = currentSystemData.services[index]; // Outer service index
                     const targetApi = targetService?.apis[currentApiIndex];
                     if (targetApi) {
                         if (!targetApi.dependentApis) targetApi.dependentApis = [];
                         if (direction === 'add') {
                             if (!targetApi.dependentApis.includes(movedApi)) targetApi.dependentApis.push(movedApi);
                         } else {
                             targetApi.dependentApis = targetApi.dependentApis.filter(d => d !== movedApi);
                         }
                     }
                 },
                 true // multiSelectLeft = true
                 // Cannot add *new* APIs here, only via the service's 'Add New API' button
             );
             apiDiv.appendChild(apiDepsContainer);
             apiDiv.appendChild(document.createElement('br'));


            let deleteApiButton = document.createElement('button'); deleteApiButton.type = 'button'; deleteApiButton.innerText = 'Delete API';
            deleteApiButton.onclick = () => deleteApi(index, apiIndex, containerId); // Pass containerId
            apiDiv.appendChild(deleteApiButton);

            apisContainer.appendChild(apiDiv);
        });

        let addApiButton = document.createElement('button'); addApiButton.type = 'button'; addApiButton.innerText = 'Add New API';
        addApiButton.onclick = () => addNewApi(index, containerId); // Pass containerId
        apisContainer.appendChild(addApiButton);
        serviceDetails.appendChild(apisContainer);
        serviceDetails.appendChild(document.createElement('br'));
        // --------------------

        // --- Action Buttons ---
        let deleteServiceButton = document.createElement('button'); deleteServiceButton.type = 'button'; deleteServiceButton.innerText = 'Delete Service';
        deleteServiceButton.style.color = 'red'; deleteServiceButton.style.marginLeft = '10px';
        deleteServiceButton.onclick = () => { if (confirm('Are you sure?')) deleteService(index, containerId); }; // Pass containerId
        serviceDetails.appendChild(deleteServiceButton);

        let saveServiceButton = document.createElement('button'); saveServiceButton.type = 'button'; saveServiceButton.innerText = 'Save Service Changes';
        saveServiceButton.style.marginLeft = '10px';
        saveServiceButton.onclick = () => saveServiceChanges(index); // Saves only this service's state from currentSystemData
        serviceDetails.appendChild(saveServiceButton);
        // --------------------

        serviceDiv.appendChild(serviceHeader);
        serviceDiv.appendChild(serviceDetails);
        servicesDiv.appendChild(serviceDiv);
    }); // End services.forEach

    // --- Shared Event Handlers for Inputs ---
    function handleServiceInputChange(event) {
        const serviceIndex = parseInt(event.target.getAttribute('data-service-index'));
        const field = event.target.getAttribute('data-field');
        const value = event.target.value;
        if (serviceIndex >= 0 && serviceIndex < currentSystemData.services.length) {
            currentSystemData.services[serviceIndex][field] = value;
            // If service name changed, update the header
            if (field === 'serviceName') {
                 const header = event.target.closest('.service-edit')?.querySelector('h4');
                 if (header) {
                     const indicatorSpan = header.querySelector('span');
                     header.textContent = `Service: ${value || 'New Service'}`; // Recreate text
                     if(indicatorSpan) header.insertBefore(indicatorSpan, header.firstChild); // Add indicator back
                 }
            }
        }
    }

     function handleApiInputChange(event) {
        const serviceIndex = parseInt(event.target.getAttribute('data-service-index'));
        const apiIndex = parseInt(event.target.getAttribute('data-api-index'));
        const field = event.target.getAttribute('data-field');
        const value = event.target.value;
        if (serviceIndex >= 0 && serviceIndex < currentSystemData.services.length &&
            apiIndex >= 0 && apiIndex < currentSystemData.services[serviceIndex].apis.length) {
            currentSystemData.services[serviceIndex].apis[apiIndex][field] = value;
        }
    }
    // ------------------------------------

    // --- Helper to find current expanded service index ---
     function findExpandedServiceIndex(containerId = 'editServicesManagement') { // Default containerId
         const servicesContainerDiv = document.getElementById(containerId);
         if (!servicesContainerDiv) {
             console.warn("findExpandedServiceIndex: Could not find container with ID:", containerId);
             return -1;
         }
         const serviceDetailDivs = servicesContainerDiv.querySelectorAll('.service-details'); // Use class selector
         for (let i = 0; i < serviceDetailDivs.length; i++) {
             // Check the display style directly
             if (serviceDetailDivs[i].style.display === 'block') {
                 // Find the parent service-edit div to get the index attribute
                 const parentEditDiv = serviceDetailDivs[i].closest('.service-edit');
                 if (parentEditDiv) {
                     const indexAttr = parentEditDiv.getAttribute('data-service-index');
                     if (indexAttr !== null) {
                         return parseInt(indexAttr); // Return the index from the attribute
                     }
                 }
             }
         }
         return -1; // Not found or none expanded
     }

} // --- End displayServicesForEditing ---

function saveServiceChanges(serviceIndex) {
    // Perform validation (optional)
    const service = currentSystemData.services[serviceIndex];
    if (!service.serviceName || service.serviceName.trim() === '') {
        alert('Service name cannot be empty.');
        return;
    }

    const serviceEditDivs = document.querySelectorAll('.service-edit');
    const currentServiceDiv = serviceEditDivs[serviceIndex];

    // Update Platform Dependencies
    const currentDepsSelect = currentServiceDiv.querySelector('select[data-field="currentPlatformDependencies"]');
    const selectedDependencies = Array.from(currentDepsSelect.options).map(option => option.value);
    service.platformDependencies = selectedDependencies;

    // Update Service Dependencies
    const currentServiceDepsSelect = currentServiceDiv.querySelector('select[data-field="currentServiceDependencies"]');
    const selectedServiceDependencies = Array.from(currentServiceDepsSelect.options).map(option => option.value);
    service.serviceDependencies = selectedServiceDependencies;

    // **Update APIs and their Dependent APIs**
    const apisContainer = currentServiceDiv.querySelector('.apis-container');
    const apiEditDivs = apisContainer.querySelectorAll('.api-edit');

    service.apis.forEach((api, apiIndex) => {
        const apiDiv = apiEditDivs[apiIndex];

        // Update API fields
        const apiNameInput = apiDiv.querySelector('input[data-field="apiName"]');
        api.apiName = apiNameInput.value;

        const apiDescTextarea = apiDiv.querySelector('textarea[data-field="apiDescription"]');
        api.apiDescription = apiDescTextarea.value;

        // Update Dependent APIs
        const currentDependentApisSelect = apiDiv.querySelector('select[data-field="currentDependentApis"]');
        const selectedDependentApis = Array.from(currentDependentApisSelect.options).map(option => option.value);
        api.dependentApis = selectedDependentApis;
    });

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    systems[currentSystemData.systemName] = currentSystemData;
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    alert('Service changes saved.');

    // **Update the Team Breakdown and Service Dependencies Tables**
    generateTeamTable(currentSystemData);
    generateServiceDependenciesTable();
    
    // Optionally collapse the service details or provide additional feedback
}

/** Add New Service in Edit Form **/
function addNewEditService() {
    // Create a new service object with default values
    const newService = {
        serviceName: 'New Service',
        serviceDescription: '',
        owningTeamId: '',
        apis: [],
        serviceDependencies: [],
        platformDependencies: []
    };

    // Add to the system data
    if (!currentSystemData.services) {
        currentSystemData.services = [];
    }
    currentSystemData.services.push(newService);

    // Refresh the service editing display for the edit form
    displayServicesForEditing(currentSystemData.services, 'editServicesManagement');
}

/** Add New Service **/

/** REVISED Add New Service - Simplified Refresh Call **/
function addNewService() {
    // Create a new service object with default values
    const newService = {
        serviceName: 'New Service ' + ((currentSystemData.services?.length || 0) + 1),
        serviceDescription: '',
        owningTeamId: null,
        apis: [],
        serviceDependencies: [],
        platformDependencies: []
    };

    // Add to the system data
    if (!currentSystemData.services) {
        currentSystemData.services = [];
    }
    currentSystemData.services.push(newService);
    console.log("Added new service to data:", newService); // Log data addition

    // --- Refresh BOTH Service and Team editing displays ---
    // Call display functions WITHOUT trying to preserve expanded index for now
    console.log("Refreshing service editors...");
    try {
        displayServicesForEditing(currentSystemData.services, 'editServicesManagement');
    } catch (error) {
         console.error("Error during displayServicesForEditing:", error);
         alert("Error refreshing service list. Check console.");
         return; // Stop if service display fails
    }


    console.log("Refreshing team editors...");
    try {
         displayTeamsForEditing(currentSystemData.teams);
     } catch (error) {
         console.error("Error during displayTeamsForEditing:", error);
         alert("Error refreshing team list. Check console.");
         return; // Stop if team display fails
     }
    console.log("UI refresh attempt complete after adding service.");
    // ------------------------------------------------------
}

/** Delete Service **/

function deleteService(serviceIndex, containerId) {
    // Remove the service from the system data
    currentSystemData.services.splice(serviceIndex, 1);

    // **Update the Team Breakdown and Service Dependencies Tables**
    generateTeamTable(currentSystemData);
    generateServiceDependenciesTable();
    
    // Refresh the service editing display
    displayServicesForEditing(currentSystemData.services, containerId,serviceIndex);
}

/** Add New API **/

/** REVISED Add New API - Refresh UI **/
function addNewApi(serviceIndex, containerId = 'editServicesManagement') { // Added containerId parameter
    // Find the service
    if (!currentSystemData || !currentSystemData.services || serviceIndex >= currentSystemData.services.length) {
        console.error("Cannot add API, invalid service index:", serviceIndex);
        return;
    }
    const service = currentSystemData.services[serviceIndex];

    // Create a new API object with default values
    const newApi = {
        apiName: 'New API ' + ((service.apis?.length || 0) + 1), // Slightly more unique default name
        apiDescription: '',
        dependentApis: []
    };

    // Add to the service's APIs
    if (!service.apis) {
        service.apis = [];
    }
    service.apis.push(newApi);

    // --- Refresh the service editing display ---
    // Re-rendering ensures all 'Available APIs' lists are updated
    console.log(`Refreshing service editors after adding new API to service index ${serviceIndex}...`);
    displayServicesForEditing(currentSystemData.services, containerId, serviceIndex); // Try to re-expand the current service
    // -----------------------------------------
}

/** Delete API **/

function deleteApi(serviceIndex, apiIndex, containerId) {
    // Remove the API from the service's APIs
    currentSystemData.services[serviceIndex].apis.splice(apiIndex, 1);

    // Refresh the service editing display
    displayServicesForEditing(currentSystemData.services, containerId, serviceIndex);
}


/** Add New Team **/

/** Updated Add New Team **/
function addNewTeam() {
    // Generate a unique teamId (simple approach for now)
    const newTeamId = 'team-' + Date.now();

    // Create a new team object with the updated default structure
    const newTeam = {
        teamId: newTeamId,
        teamName: '', // Blank initially
        teamIdentity: '', // Blank initially
        teamDescription: '', // Added field
        fundedHeadcount: 0, // Default funded HC
        buildersInSeats: 0, // Default BIS (no engineers yet)
        engineers: [], // Start with an empty array for engineers
        sdmId: null, // No default SDM assigned
        pmtId: null  // No default PMT assigned
        // Removed sdmName, pmtName as they are derived via IDs
    };

    // Add to the system data
    if (!currentSystemData.teams) {
        currentSystemData.teams = [];
    }
    currentSystemData.teams.push(newTeam);

    // Get the index of the newly added team
    const newTeamIndex = currentSystemData.teams.length - 1;

    // Refresh the team editing display and expand the new team
    // Pass -1 if displayTeamsForEditing doesn't handle expansion correctly, or pass newTeamIndex
    displayTeamsForEditing(currentSystemData.teams, newTeamIndex);
}

/** Delete Team **/

function deleteTeam(index) {
    const team = currentSystemData.teams[index];
    const confirmDelete = confirm(`Are you sure you want to delete the team "${team.teamName}"? This action cannot be undone.`);
    if (confirmDelete) {
        // Remove the team from currentSystemData.teams
        currentSystemData.teams.splice(index, 1);

        // Update services that reference this team
        currentSystemData.services.forEach(service => {
            if (service.owningTeamId === team.teamId) {
                service.owningTeamId = null;
            }
        });

        // Update uniqueEngineers array
        uniqueEngineers = uniqueEngineers.filter(engineer => engineer.teamId !== team.teamId);

        // Update team assignments in engineers
        currentSystemData.teams.forEach(t => {
            if (t.teamId !== team.teamId) {
                const engineers = t.engineerNames ? t.engineerNames.split(',').map(name => name.trim()) : [];
                t.engineerNames = engineers.filter(name => {
                    const engineer = uniqueEngineers.find(e => e.engineerName === name);
                    return engineer && engineer.teamId === t.teamId;
                }).join(', ');
            }
        });

        // Save changes to local storage
        saveSystemChanges();
        
        // Notify the user
        alert(`Team "${team.teamName}" has been deleted.`);

        // Refresh the teams editing interface
        displayTeamsForEditing(currentSystemData.teams);

        // Update other UI components
        generateTeamTable(currentSystemData);
        generateTeamVisualization(currentSystemData);
        generateServiceDependenciesTable();
        populateServiceSelection();
        populateDependencyServiceSelection();
        updateServiceVisualization();
        updateDependencyVisualization();
    }
}

/** Save System Details **/

function saveSystemDetails() {
    // Get updated system name and description
    console.log("*** 1 document.getElementById('systemNameInput').value",document.getElementById('systemNameInput').value);    
    console.log("*** 2 document.getElementById('systemDescriptionInput'",document.getElementById('systemDescriptionInput').value);    
    
    const systemNameInput = document.getElementById('systemNameInput');
    const systemDescriptionTextarea = document.getElementById('systemDescriptionInput');

    console.log("*** 3 systemNameInput = ", systemNameInput.value);
    console.log("*** 4 systemDescriptionTextarea = ", systemDescriptionTextarea.value);  
  
    const oldSystemName = currentSystemData.systemName;
    const newSystemName = systemNameInput.value.trim();

    if (!newSystemName) {
        alert('System name cannot be empty.');
        return;
    }

    currentSystemData.systemName = newSystemName;
    currentSystemData.systemDescription = systemDescriptionTextarea.value.trim();

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');

    systems[newSystemName] = currentSystemData;

    console.log('Saving to local storage:', systems);

    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    alert('System details saved, please continue to update the services and teams. Note: If you changed the system name, it is treated as a new system');

    if (currentMode == Modes.EDITING) {
      // Update UI components
      generateTeamTable(currentSystemData);
      generateServiceDependenciesTable();
      updateServiceVisualization();
      updateDependencyVisualization();
    }
}

/** Save All Changes **/

/** REVISED Save All Changes - Handles Creation and Updates */
function saveAllChanges() {
//    if (currentMode !== Modes.CREATING && currentMode !== Modes.EDITING) {
//         alert('Not in creation or edit mode. No changes to save.');
//         return;
//    }

    // --- Get Final System Name and Description from Form ---
    const systemNameInput = document.getElementById('systemNameInput');
    const systemDescriptionTextarea = document.getElementById('systemDescriptionInput');
    const finalSystemName = systemNameInput.value.trim();
    const finalSystemDescription = systemDescriptionTextarea.value.trim();

    if (!finalSystemName) {
        alert('System Name cannot be empty. Please enter a name before saving.');
        systemNameInput.focus(); // Focus the input field
        return;
    }
    // Basic check for description, can be optional
    if (!finalSystemDescription) {
         if (!confirm('System Description is empty. Save anyway?')) {
             systemDescriptionTextarea.focus();
             return;
         }
    }
    // --------------------------------------------------

    // --- Update currentSystemData with final name/desc ---
    // This ensures the object being saved has the correct top-level info
    const oldSystemNameKey = currentSystemData.systemName; // Store the name *before* updating
    currentSystemData.systemName = finalSystemName;
    currentSystemData.systemDescription = finalSystemDescription;
    console.log(`Attempting to save system as: "${finalSystemName}"`);
    // -----------------------------------------------------

    // --- Perform Validation ---
    // Ensure engineer assignments are valid before saving
    if (!validateEngineerAssignments()) {
         // If validation fails, revert name/desc change in the data object
         // to avoid potential mismatches if user cancels or tries again.
         currentSystemData.systemName = oldSystemNameKey;
         currentSystemData.systemDescription = document.getElementById('systemDescriptionInput').value; // Or revert based on how it was before validation
         return; // Stop the save
    }
    // Add other validation checks here if needed (e.g., required fields for teams/services)
    // ------------------------
    
    // --- Save to Local Storage ---
    try {
        const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');

         // Check if renaming an existing system or creating a new one
         if (currentMode === Modes.EDITING && oldSystemNameKey && oldSystemNameKey !== finalSystemName) {
             // If the name changed during editing, remove the old entry
             if (systems[oldSystemNameKey]) {
                 delete systems[oldSystemNameKey];
                 console.log(`Removed old system entry for key: "${oldSystemNameKey}" due to rename.`);
             }
         }
         // Check if overwriting another system with the new name (relevant for 'Create New' if name exists)
         if (systems[finalSystemName] && (currentMode === Modes.CREATING || oldSystemNameKey !== finalSystemName)) {
            if (!confirm(`A system named "${finalSystemName}" already exists. Overwrite it?`)) {
                // Revert data object name change before cancelling
                currentSystemData.systemName = oldSystemNameKey;
                currentSystemData.systemDescription = document.getElementById('systemDescriptionInput').value; // Revert desc too
                return; // User cancelled overwrite
            }
         }


        // Save the current data under the final name
        systems[finalSystemName] = currentSystemData;
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

        alert(`System "${finalSystemName}" saved successfully.`);

        // --- Post-Save Actions ---
        if (currentMode === Modes.CREATING) {
             // After successfully creating, switch to Browse mode for the new system
             currentMode = Modes.Browse;
             // Optionally reload the view for the newly saved system
             loadSavedSystem(finalSystemName); // Load it properly
        } else {
             // If editing, maybe exit edit mode or refresh views
              exitEditMode(); // Go back to Browse mode
        }
        // -----------------------

    } catch (error) {
        console.error("Error saving system to local storage:", error);
        alert("An error occurred while trying to save the system. Please check the console for details.");
         // Revert data object name change on error
         currentSystemData.systemName = oldSystemNameKey;
         currentSystemData.systemDescription = document.getElementById('systemDescriptionInput').value;
    }
    // -------------------------
}

/** Exit Edit Mode **/

function exitEditMode() {
    if (currentMode === Modes.CREATING) {
        if (confirm('Are you sure you want to cancel creating the new system? All unsaved changes will be lost.')) {
            currentMode = Modes.NAVIGATION;
            currentSystemData = null;
            // Clear the UI and return to navigation mode
            returnToHome();
        }
    } else {
      // Hide the edit form
      document.getElementById('systemEditForm').style.display = 'none';
  
      // Show the visualizations
      document.getElementById('visualization').style.display = 'block';
      document.getElementById('teamVisualization').style.display = 'block';
      document.getElementById('teamBreakdown').style.display = 'block';
  
      // Update the page title and description
      document.getElementById('pageTitle').innerText = currentSystemData.systemName;
      document.getElementById('systemDescription').innerText = currentSystemData.systemDescription || '';
      
      document.getElementById('organogramView').style.display = 'none';
      document.getElementById('engineerTableView').style.display = 'none';
      
      // Show the "Edit System" button
      document.querySelector('.edit-menu').style.display = 'block';
  
      loadSavedSystem(currentSystemData.systemName);    
      currentMode = Modes.BROWSING;
    }
}

/** 09/28 Worked on CreateNewSystem workflows **/
/** Updated function to handle "Create New Software System" button click **/
function createNewSystem() {
    currentMode = Modes.CREATING;

    // Default Senior Managers Data
    const defaultSeniorManagersData = [
        { seniorManagerId: 'srMgr1', seniorManagerName: 'Enter Sr. Manager Name Here' }
    ];

    // Default SDMs Data (with seniorManagerId)
    const defaultSDMsData = [
        { sdmId: 'sdm1', sdmName: 'Enter SDM Name Here', seniorManagerId: 'srMgr1' } // Added seniorManagerId
    ];

    // Default PMTs Data
    const defaultPMTsData = [
        { pmtId: 'pmt1', pmtName: 'Enter PMT Name Here' }
    ];

    // Default Teams Data (using new structure)
    const defaultTeamsData = [
        {
            teamId: 'team1', // Will be regenerated on save if needed, but useful for default service
            teamName: 'Enter Team Name Here',
            teamIdentity: 'Enter Team Identity Here',
            teamDescription: 'Enter Team Description Here...', // Added description field based on usage elsewhere
            fundedHeadcount: 1, // Example default
            buildersInSeats: 1, // Matches the single default engineer
            engineers: [ // Changed from engineerNames string to engineers array
                { name: 'Enter Engineer Name Here', level: 2 } // Example default engineer with level
            ],
            sdmId: 'sdm1', // Reference to the default SDM
            pmtId: 'pmt1'  // Reference to the default PMT
        }
    ];

    // Default Services Data
    const defaultServicesData = [
        {
            serviceName: 'Enter Service Name Here',
            serviceDescription: 'Enter Service Description Here...',
            owningTeamId: 'team1', // Reference to the default Team
            apis: [
                {
                    apiName: 'Enter API Name Here',
                    apiDescription: 'Enter API Description Here...',
                    dependentApis: []
                }
            ],
            serviceDependencies: [],
            platformDependencies: []
        }
    ];

    // Default System Data (including seniorManagers)
    const defaultSystemData = {
        systemName: '', // Start blank, user must enter in form
        systemDescription: '', // Start blank, user must enter in form
        seniorManagers: defaultSeniorManagersData, // Added
        sdms: defaultSDMsData,
        pmts: defaultPMTsData,
        teams: defaultTeamsData,
        services: defaultServicesData,
        platformDependencies: [], 
        yearlyInitiatives: []
    };

    // Assign to currentSystemData
    currentSystemData = defaultSystemData;

    // Clear the page title and description
    document.getElementById('pageTitle').innerText = 'Create New Software System';
    document.getElementById('systemDescription').innerText = 'Define the new system details, services, and teams below.';

    // Hide the menu and other sections
    document.querySelector('.menu').style.display = 'none';
    document.getElementById('visualization').style.display = 'none';
    document.getElementById('teamVisualization').style.display = 'none';
    document.getElementById('teamBreakdown').style.display = 'none';
    document.getElementById('serviceRelationshipsVisualization').style.display = 'none';
    document.getElementById('dependencyVisualization').style.display = 'none';
    document.getElementById('serviceDependenciesTable').style.display = 'none';
    document.querySelector('.edit-menu').style.display = 'none';
    document.getElementById('systemEditForm').style.display = 'none'; // Hide initially

    document.getElementById('organogramView').style.display = 'none';
    document.getElementById('engineerTableView').style.display = 'none';
    // Display the system information for editing using the standard edit mode function
    enterEditMode(true); // Pass true flag for creation mode
}

/** REVISED Return to Home - Fix errors and hide new views */
function returnToHome() {
    console.log("Returning to home view..."); // Added log
    currentMode = Modes.NAVIGATION;
    currentSystemData = null; // Reset loaded system data

    // --- Hide ALL possible view sections ---
    // Core Views
    const coreViews = ['systemEditForm', 'visualization', 'teamVisualization', 'teamBreakdown', 'serviceRelationshipsVisualization', 'dependencyVisualization', 'serviceDependenciesTable'];
    coreViews.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.style.display = 'none';
    });

     // New Views
     const newViews = ['organogramView', 'engineerTableView', 'planningView'];
     newViews.forEach(id => {
         const element = document.getElementById(id);
         if (element) element.style.display = 'none';
     });

     // Menus
     const editMenu = document.querySelector('.edit-menu');
     if (editMenu) editMenu.style.display = 'none';
     // ----------------------------------------

    // Show the main menu
    const mainMenu = document.querySelector('.menu');
    if (mainMenu) mainMenu.style.display = 'block';

    // Update page title and description
    const pageTitle = document.getElementById('pageTitle');
    if(pageTitle) pageTitle.innerText = "Architecture Visualization Tool";
    const sysDesc = document.getElementById('systemDescription');
    if(sysDesc) sysDesc.innerText = "Load a previously saved system or create a new system...";

     // Clear any potential leftover popups (like the system list)
     const systemListDiv = document.getElementById('systemListDiv');
     if (systemListDiv) {
         document.body.removeChild(systemListDiv);
     }
     // Remove lingering tooltips
     d3.selectAll('.tooltip').remove();

     console.log("Home view displayed.");
}

function resetToDefaults() {
    if (confirm('This will erase all your saved systems and restore the default sample systems. Do you want to proceed?')) {
        // Clear the local storage for systems
        localStorage.removeItem(LOCAL_STORAGE_KEY);

        // Re-initialize with sample systems
        const systems = {
            'StreamView': sampleSystemDataStreamView,
            'ConnectPro': sampleSystemDataContactCenter
        };
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

        alert('Systems have been reset to defaults.');

        // Return to the home page
        returnToHome();
    }
}

function populateServiceSelection() {
    const serviceSelection = document.getElementById('serviceSelection');
    serviceSelection.innerHTML = ''; // Clear existing options

    // Add "All Services View" option
    let allServicesOption = document.createElement('option');
    allServicesOption.value = 'all';
    allServicesOption.text = 'All Services View';
    serviceSelection.appendChild(allServicesOption);

    // Add individual services
    currentSystemData.services.forEach(service => {
        let option = document.createElement('option');
        option.value = service.serviceName;
        option.text = service.serviceName;
        serviceSelection.appendChild(option);
    });
}

function getServiceDependencies(service, collectedServices = {}, visitedServices = {}) {
    if (!service || visitedServices[service.serviceName]) {
        return [];
    }
    visitedServices[service.serviceName] = true;
    collectedServices[service.serviceName] = service;

    // Recursively collect dependencies
    service.serviceDependencies.forEach(depName => {
        const depService = currentSystemData.services.find(s => s.serviceName === depName);
        getServiceDependencies(depService, collectedServices, visitedServices);
    });

    return Object.values(collectedServices);
}

function updateServiceVisualization() {
    const selectedService = document.getElementById('serviceSelection').value;

    // Ensure the service selection is populated with the latest data
    populateServiceSelection();
    
    if (selectedService === 'all') {
        generateServiceVisualization(currentSystemData.services, null); // No service is selected
    } else {
        // Find the selected service and its dependencies
        const selectedServiceData = currentSystemData.services.find(service => service.serviceName === selectedService);
        const relatedServices = getServiceDependencies(selectedServiceData);

        generateServiceVisualization(relatedServices, selectedService);
    }
}

function generateServiceVisualization(services, selectedServiceName) {
    let svg = d3.select('#serviceSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // Prepare nodes and links data
    let nodes = [];
    let links = [];
    let nodeMap = {};
   
    // Set SVG dimensions
    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    // Define node radius
    const radius = 20;
   
    // Create a color scale based on teams
    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = currentSystemData.teams.map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Map service names to services for quick lookup
    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    // Create nodes for services
    services.forEach(service => {
        let teamId = service.owningTeamId || 'unassigned';
        let nodeColor = teamColorScale(teamId);

        // Check if this is the selected service
        let isSelected = service.serviceName === selectedServiceName;

        nodes.push({
            id: service.serviceName,
            type: 'service',
            teamId: teamId,
            color: nodeColor,
            isSelected: isSelected
        });
        nodeMap[service.serviceName] = { id: service.serviceName, type: 'service' };
    });

    // Add platform dependencies as nodes
    services.forEach(service => {
        if (service.platformDependencies) {
            service.platformDependencies.forEach(platform => {
                if (!nodeMap[platform]) {
                    nodes.push({ id: platform, type: 'platform', color: '#a04040', isSelected: false }); // Add isSelected property
                    nodeMap[platform] = { id: platform, type: 'platform' };
                }
                // Link service to platform
                links.push({
                    source: service.serviceName,
                    target: platform,
                    type: 'platform-dependency'
                });
            });
        }
    });

    // Create links based on service dependencies
    services.forEach(service => {
        // Service dependencies
        service.serviceDependencies.forEach(dependency => {
            if (nodeMap[dependency]) {
                links.push({
                    source: service.serviceName,
                    target: dependency,
                    type: 'service-dependency'
                });
            }
        });
    });

    // Set up the simulation
    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 30));

    // **Corrected Node Creation and Attribute Setting**

    let node = svg.append('g')
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', d => d.isSelected ? 25 : 20) // Increase radius for selected node
        .attr('fill', d => d.color)
        .attr('stroke', d => d.isSelected ? 'red' : '#fff') // Change stroke color to red for selected node
        .attr('stroke-width', d => d.isSelected ? 4 : 2) // Increase stroke width for selected node
        .call(drag(simulation));

    // Add labels to nodes
    let labels = svg.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 0)
        .attr('dy', 4)
        .attr('text-anchor', 'middle')
        .text(d => d.id)
        .attr('fill', d => d.isSelected ? 'red' : 'black'); // Change text color to red for selected node

    // Tooltip
    let tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let info = '';
        if (d.type === 'service') {
            let service = serviceMap[d.id];
            let team = currentSystemData.teams.find(t => t.teamId === service.owningTeamId);
            info = `<strong>Service Name:</strong> ${service.serviceName}<br>
                    <strong>Description:</strong> ${service.serviceDescription}<br>
                    <strong>Team:</strong> ${team ? `${team.teamName} (${team.teamIdentity})` : 'Unassigned'}`;
        } else if (d.type === 'platform') {
            info = `<strong>Platform Dependency:</strong> ${d.id}`;
        }
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5);
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    // **Add links to the SVG after nodes are created**
    let link = svg.append('g')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-dasharray', d => {
            if (d.type === 'service-dependency') return '5,5';
            else if (d.type === 'platform-dependency') return '10,5';
            else return '1,0';
        })
        .attr('stroke-width', 2);

    // Add legend for teams
    let legendData = currentSystemData.teams.map(team => ({
        teamIdentity: team.teamIdentity,
        color: teamColorScale(team.teamId)
    }));

    let legend = d3.select('#serviceLegend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item');

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
}

//Create a function to populate the dropdown menu with available services.
function populateDependencyServiceSelection() {
    const serviceSelection = document.getElementById('dependencyServiceSelection');
    serviceSelection.innerHTML = ''; // Clear existing options

    // Add individual services
    currentSystemData.services.forEach(service => {
        let option = document.createElement('option');
        option.value = service.serviceName;
        option.text = service.serviceName;
        serviceSelection.appendChild(option);
    });
}

//We need to build a graph with nodes and links, ensuring that nodes are not duplicated and circular dependencies are handled.
//We use a breadth-first search (BFS) traversal to explore both upstream and downstream services, handling cycles by keeping track of visited services.
//We build nodes and links without duplicating nodes.
//Ensure the edges are defined in the correct direction (from upstream to downstream).
function buildDependencyGraph(serviceName) {
    const nodes = [];
    const links = [];
    const nodeMap = {};

    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    const queue = [];
    const visited = new Set();

    queue.push(serviceName);
    visited.add(serviceName);

    while (queue.length > 0) {
        const currentServiceName = queue.shift();
        const currentService = serviceMap[currentServiceName];

        if (!nodeMap[currentServiceName]) {
            nodes.push({ id: currentServiceName, type: 'service' });
            nodeMap[currentServiceName] = true;
        }

        // Process upstream dependencies
        currentService.serviceDependencies.forEach(depName => {
            if (!nodeMap[depName]) {
                nodes.push({ id: depName, type: 'service' });
                nodeMap[depName] = true;
            }
            // Edge from dependency to current service
            links.push({
                source: depName,
                target: currentServiceName,
                type: 'service-dependency',
            });
            if (!visited.has(depName)) {
                visited.add(depName);
                queue.push(depName);
            }
        });

        // Process platform dependencies
        if (currentService.platformDependencies) {
            currentService.platformDependencies.forEach(platform => {
                if (!nodeMap[platform]) {
                    nodes.push({ id: platform, type: 'platform' });
                    nodeMap[platform] = true;
                }
                // Edge from platform to current service
                links.push({
                    source: platform,
                    target: currentServiceName,
                    type: 'platform-dependency',
                });
            });
        }

        // Process downstream dependents
        currentSystemData.services.forEach(service => {
            if (service.serviceDependencies.includes(currentServiceName)) {
                const dependentName = service.serviceName;
                if (!nodeMap[dependentName]) {
                    nodes.push({ id: dependentName, type: 'service' });
                    nodeMap[dependentName] = true;
                }
                // Edge from current service to dependent
                links.push({
                    source: currentServiceName,
                    target: dependentName,
                    type: 'service-dependency',
                });
                if (!visited.has(dependentName)) {
                    visited.add(dependentName);
                    queue.push(dependentName);
                }
            }
        });
    }

    return { nodes, links };
}

//Create functions to build the data structure representing upstream and downstream dependencies.
function buildDependencyTree(serviceName) {
    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    // Recursive function to get upstream dependencies
    function getUpstream(service, visited = new Set()) {
        if (!service || visited.has(service.serviceName)) return null;
        visited.add(service.serviceName);

        let dependencies = [];
        service.serviceDependencies.forEach(depName => {
            const depService = serviceMap[depName];
            const upstreamNode = getUpstream(depService, visited);
            if (upstreamNode) {
                dependencies.push(upstreamNode);
            } else if (depService) {
                dependencies.push({ name: depService.serviceName, children: [] });
            }
        });

        return { name: service.serviceName, children: dependencies };
    }

    // Recursive function to get downstream dependencies
    function getDownstream(service, visited = new Set()) {
        if (!service || visited.has(service.serviceName)) return null;
        visited.add(service.serviceName);

        let dependents = [];
        currentSystemData.services.forEach(otherService => {
            if (otherService.serviceDependencies.includes(service.serviceName)) {
                const downstreamNode = getDownstream(otherService, visited);
                if (downstreamNode) {
                    dependents.push(downstreamNode);
                } else {
                    dependents.push({ name: otherService.serviceName, children: [] });
                }
            }
        });

        return { name: service.serviceName, children: dependents };
    }

    const rootService = serviceMap[serviceName];

    const upstreamTree = getUpstream(rootService);
    const downstreamTree = getDownstream(rootService);

    // Combine upstream and downstream trees
    const treeData = {
        name: rootService.serviceName,
        children: []
    };

    if (upstreamTree && upstreamTree.children.length > 0) {
        treeData.children.push({
            name: 'Upstream Dependencies',
            direction: 'upstream',
            children: upstreamTree.children
        });
    }

    if (downstreamTree && downstreamTree.children.length > 0) {
        treeData.children.push({
            name: 'Downstream Dependencies',
            direction: 'downstream',
            children: downstreamTree.children
        });
    }

    return treeData;
}

//The function uses a force-directed graph to display service dependencies, handling circular dependencies by linking back to existing nodes.
//Nodes represent services and platforms.
//Links represent dependencies, with arrowheads to indicate direction.
//The graph is interactive, with zoom/pan and node dragging.
//Labels are added to nodes, and tooltips provide additional information
function generateDependencyForceVisualization(selectedServiceName) {
    const svg = d3.select('#dependencySvg');
    svg.selectAll('*').remove(); // Clear existing content

    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    const { nodes, links } = buildDependencyGraph(selectedServiceName);

    // Assign index to links
    links.forEach((link, index) => {
        link.index = index;
    });

    // Create a color scale
    const color = d3.scaleOrdinal()
        .domain(['service', 'platform'])
        .range(['#1f77b4', '#ff7f0e']); // Customize colors as needed

    // Create simulation
    const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collide', d3.forceCollide(40))
        .on('tick', ticked);

    // Add zoom and pan
    const zoom = d3.zoom()
        .scaleExtent([0.1, 5])
        .on('zoom', (event) => {
            container.attr('transform', event.transform);
        });

    svg.call(zoom);

    // Create container for nodes and links
    const container = svg.append('g');

    // Define arrowheads
    svg.append('defs').selectAll('marker')
        .data(['service-dependency', 'platform-dependency'])
        .enter().append('marker')
        .attr('id', d => `arrow-${d}`)
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 25) // Adjusted for larger arrowhead
        .attr('refY', 0)
        .attr('markerWidth', 10) // Increased size
        .attr('markerHeight', 10) // Increased size
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#999');

    // Define arrowheads for legend
    svg.append('defs').selectAll('marker')
        .data(['arrow-service-dependency', 'arrow-platform-dependency'])
        .enter().append('marker')
        .attr('id', d => d)
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 12)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#999');

    // Add links
    const link = container.append('g')
        .attr('stroke', '#999')
        .attr('stroke-opacity', 0.6)
        .selectAll('line')
        .data(links)
        .enter().append('line')
        .attr('stroke-width', 2)
        .attr('marker-end', d => `url(#arrow-${d.type})`)
        .attr('stroke-dasharray', d => {
            if (d.type === 'platform-dependency') return '5,5';
            else return '0';
        });

    // Add nodes
    const node = container.append('g')
        .attr('stroke', '#fff')
        .selectAll('circle')
        .data(nodes)
        .enter().append('circle')
        .attr('r', d => d.id === selectedServiceName ? 15 : 10)
        .attr('fill', d => {
            if (d.id === selectedServiceName) return 'red'; // Highlight selected service
            else if (d.type === 'service') return color('service');
            else return color('platform');
        })
        .attr('stroke-width', d => d.id === selectedServiceName ? 3 : 1.5)
        .call(drag(simulation));

    // Add labels
    const label = container.append('g')
        .selectAll('text')
        .data(nodes)
        .enter().append('text')
        .attr('dy', -15)
        .attr('text-anchor', 'middle')
        .text(d => d.id)
        .attr('font-weight', d => d.id === selectedServiceName ? 'bold' : 'normal')
        .attr('fill', d => d.id === selectedServiceName ? 'red' : 'black');

    // Tooltip
    const tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    // Variables for highlighting
    let highlightedNodes = new Set();
    let highlightedLinks = new Set();

    // Node mouseover event
    node.on('mouseover', function(event, d) {
        let info = '';
        if (d.type === 'service') {
            const service = currentSystemData.services.find(s => s.serviceName === d.id);
            if (service) {
                // Fetch upstreams and downstreams
                const upstreams = service.serviceDependencies;
                const downstreams = currentSystemData.services
                    .filter(s => s.serviceDependencies.includes(service.serviceName))
                    .map(s => s.serviceName);
                // Fetch platform dependencies
                const platformDeps = service.platformDependencies || [];
    
                // Build the tooltip content
                info = `<strong>Service Name:</strong> ${service.serviceName}<br>`;
                info += `<strong>Upstreams:</strong> ${upstreams.length > 0 ? upstreams.join(', ') : 'None'}<br>`;
                info += `<strong>Downstreams:</strong> ${downstreams.length > 0 ? downstreams.join(', ') : 'None'}<br>`;
                info += `<strong>Platform Dependencies:</strong> ${platformDeps.length > 0 ? platformDeps.join(', ') : 'None'}`;
            }
        } else if (d.type === 'platform') {
            info = `<strong>Platform Dependency:</strong> ${d.id}`;
        }
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    
        // Highlight connected nodes and links
        highlightConnected(d);
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    
        // Remove highlighting
        unhighlight();
    });

    // Function to highlight connected nodes and links
    function highlightConnected(d) {
        // Clear previous highlights
        highlightedNodes.clear();
        highlightedLinks.clear();

        // Add the hovered node
        highlightedNodes.add(d.id);

        // Highlight upstream nodes and links
        links.forEach(link => {
            if (link.target.id === d.id) {
                highlightedNodes.add(link.source.id);
                highlightedLinks.add(link.index);
            }
        });

        // Highlight downstream nodes and links
        links.forEach(link => {
            if (link.source.id === d.id) {
                highlightedNodes.add(link.target.id);
                highlightedLinks.add(link.index);
            }
        });

        // Update node styles
        node.style('opacity', n => highlightedNodes.has(n.id) ? 1 : 0.1);
        label.style('opacity', n => highlightedNodes.has(n.id) ? 1 : 0.1);

        // Update link styles
        link.style('opacity', l => highlightedLinks.has(l.index) ? 1 : 0.1);
    }

    // Function to remove highlighting
    function unhighlight() {
        node.style('opacity', 1);
        label.style('opacity', 1);
        link.style('opacity', 1);
    }

    // Add legend
    const legendData = [
        { label: 'Selected Service', color: 'red', shape: 'circle' },
        { label: 'Service', color: color('service'), shape: 'circle' },
        { label: 'Platform', color: color('platform'), shape: 'circle' },
        { label: 'Service Dependency', color: '#999', type: 'line', marker: 'arrow-service-dependency', dash: '0' },
        { label: 'Platform Dependency', color: '#999', type: 'line', marker: 'arrow-platform-dependency', dash: '5,5' }
    ];

    // Create a legend container
    const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', `translate(${20},${20})`);

    // Add legend items
    legendData.forEach((item, index) => {
        const legendRow = legend.append('g')
            .attr('transform', `translate(0, ${index * 20})`);

        if (item.shape === 'circle') {
            // Draw circle
            legendRow.append('circle')
                .attr('r', 6)
                .attr('fill', item.color)
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .attr('cx', 0)
                .attr('cy', 0);
        } else if (item.type === 'line') {
            // Draw line with arrow
            legendRow.append('line')
                .attr('x1', -10)
                .attr('y1', 0)
                .attr('x2', 10)
                .attr('y2', 0)
                .attr('stroke', item.color)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', item.dash)
                .attr('marker-end', `url(#${item.marker})`);
        }

        // Add text
        legendRow.append('text')
            .attr('x', 20)
            .attr('y', 5)
            .text(item.label)
            .attr('text-anchor', 'start')
            .attr('font-size', '12px');
    });

    // Tick function
    function ticked() {
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);

        node
            .attr('cx', d => d.x)
            .attr('cy', d => d.y);

        label
            .attr('x', d => d.x)
            .attr('y', d => d.y - 15);
    }

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }
}


//Create a function to update the visualization when a new service is selected.
function updateDependencyVisualization() {
    const selectedServiceName = document.getElementById('dependencyServiceSelection').value;
    // Ensure the service selection is populated with the latest data
    populateDependencyServiceSelection();
    generateDependencyForceVisualization(selectedServiceName); //forced dependency works best
}


//Create a function to add the legend to the SVG.
//Legend Items: The legend displays the meanings of node colors, shapes, and edge styles.
//Arrowhead Definition: An arrowhead is defined for use in the legend.
function addDependencyLegend(svg) {
    const legendData = [
        { label: 'Selected Service', color: 'red', shape: 'rect' },
        { label: 'Service', color: '#1f77b4', shape: 'rect' },
        { label: 'Platform', color: '#ff7f0e', shape: 'rect' },
        { label: 'Service Dependency', style: 'stroke: #333; stroke-width: 2px;', arrowhead: true },
        { label: 'Platform Dependency', style: 'stroke: #333; stroke-width: 2px; stroke-dasharray: 5,5;', arrowhead: true },
    ];

    const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', 'translate(20, 20)');

    legendData.forEach((item, index) => {
        const legendItem = legend.append('g')
            .attr('transform', `translate(0, ${index * 25})`);

        if (item.shape === 'rect') {
            legendItem.append('rect')
                .attr('x', 0)
                .attr('y', -10)
                .attr('width', 20)
                .attr('height', 20)
                .attr('style', `fill: ${item.color}; stroke: #fff; stroke-width: 1.5px;`);
        } else {
            // Draw line
            const line = legendItem.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', 20)
                .attr('y2', 0)
                .attr('style', item.style);

            if (item.arrowhead) {
                line.attr('marker-end', 'url(#arrowhead)');
            }
        }

        legendItem.append('text')
            .attr('x', 30)
            .attr('y', 5)
            .text(item.label)
            .attr('text-anchor', 'start')
            .attr('font-size', '12px');
    });

    // Define arrowhead for legend lines
    svg.append('defs').append('marker')
        .attr('id', 'arrowhead')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 10)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#333');
}

function generateServiceDependenciesTable() {
    const tbody = document.querySelector('#serviceDependenciesTable tbody');
    tbody.innerHTML = ''; // Clear existing content

    currentSystemData.services.forEach(service => {
        const row = document.createElement('tr');

        // Service Name
        const nameCell = document.createElement('td');
        nameCell.textContent = service.serviceName;
        row.appendChild(nameCell);

        // Description
        const descCell = document.createElement('td');
        descCell.textContent = service.serviceDescription;
        row.appendChild(descCell);

        // Owning Team
        const team = currentSystemData.teams.find(t => t.teamId === service.owningTeamId);
        const teamCell = document.createElement('td');
        teamCell.textContent = team ? team.teamName : 'Unassigned';
        row.appendChild(teamCell);

        // Upstream Dependencies (Services Depended On)
        const upstreamServices = service.serviceDependencies;
        const upstreamCell = document.createElement('td');
        upstreamCell.textContent = upstreamServices.length > 0 ? upstreamServices.join(', ') : 'None';
        row.appendChild(upstreamCell);

        // Platform Dependencies
        const platformDependencies = service.platformDependencies || [];
        const platformCell = document.createElement('td');
        platformCell.textContent = platformDependencies.length > 0 ? platformDependencies.join(', ') : 'None';
        row.appendChild(platformCell);

        // Downstream Dependencies (Services That Depend On This Service)
        const downstreamServices = currentSystemData.services
            .filter(s => s.serviceDependencies.includes(service.serviceName))
            .map(s => s.serviceName);
        const downstreamCell = document.createElement('td');
        downstreamCell.textContent = downstreamServices.length > 0 ? downstreamServices.join(', ') : 'None';
        row.appendChild(downstreamCell);

        tbody.appendChild(row);
    });
}

/** NEW Validation function to check engineer assignments */
function validateEngineerAssignments() {
    if (!currentSystemData || !currentSystemData.teams) {
        console.error("Validation skipped: No team data loaded.");
        return true; // Allow saving if no data? Or return false? Safer to allow.
    }

    const engineerAssignments = new Map(); // Key: engineerName, Value: Set<teamId>
    let isValid = true;
    let errorMessages = [];

    currentSystemData.teams.forEach(team => {
        if (!team || !team.teamId) return; // Skip invalid team entries
        (team.engineers || []).forEach(engineer => {
            if (!engineer || !engineer.name) return; // Skip invalid engineer entries
            const name = engineer.name;
            if (!engineerAssignments.has(name)) {
                engineerAssignments.set(name, new Set());
            }
            engineerAssignments.get(name).add(team.teamId);
        });
    });

    // Check for overallocations
    engineerAssignments.forEach((assignedTeamIds, engineerName) => {
        if (assignedTeamIds.size > 1) {
            isValid = false;
            const teamNames = Array.from(assignedTeamIds).map(tId => {
                const team = currentSystemData.teams.find(t => t.teamId === tId);
                return team ? (team.teamName || team.teamIdentity) : tId;
            }).join(', ');
            errorMessages.push(`Engineer "${engineerName}" is assigned to multiple teams: ${teamNames}.`);
        }
    });

    if (!isValid) {
        alert("Validation Error: Cannot save changes.\n\n" + errorMessages.join("\n"));
    }

    return isValid;
}

/** Updated Save System Changes (used by Save All/Save Team) - Add Validation **/
function saveSystemChanges() {
    // Get updated system name and description (if called directly, maybe redundant)
    const systemNameInput = document.getElementById('systemNameInput');
    const systemDescriptionTextarea = document.getElementById('systemDescriptionInput');
    if (systemNameInput && systemDescriptionTextarea) { // Check if elements exist
         currentSystemData.systemName = systemNameInput.value.trim();
         currentSystemData.systemDescription = systemDescriptionTextarea.value.trim();
    } else if (currentMode === Modes.CREATING || currentMode === Modes.EDITING) {
         // If called during saveAll/saveTeam, these might not be the source of truth anymore
         console.warn("saveSystemChanges called without direct access to system name/desc inputs. Assuming currentSystemData properties are up-to-date.");
    }


    if (!currentSystemData.systemName && (currentMode === Modes.CREATING || currentMode === Modes.EDITING)) {
        alert('System name cannot be empty.');
        return;
    }

    // *** Add validation before saving to local storage ***
    if (!validateEngineerAssignments()) {
        return; // Stop saving if validation fails
    }
    // *********************************************************

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    systems[currentSystemData.systemName] = currentSystemData; // Use potentially updated name as key
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    console.log('System changes saved to local storage.'); // Changed alert to console log

    // Note: UI updates are typically handled by the calling function (like saveTeamChanges or exitEditMode)
}

// Generate a unique ID for new teams
function generateUniqueId() {
    return 'team-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
}

function deleteSystem() {
    if (currentSystemData && currentSystemData.systemName) {
        // Confirm deletion
        if (confirm(`Are you sure you want to delete the system "${currentSystemData.systemName}"? This action cannot be undone.`)) {
            // Remove from local storage
            const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
            delete systems[currentSystemData.systemName];
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

            // Optionally, you might want to remove any other related data

            // Clear current system data and reset the mode
            const deletedSystemName = currentSystemData.systemName; // Store the name before clearing
            currentSystemData = null;
            currentMode = Modes.NAVIGATION;

            // Clear the UI and display the main menu
            returnToHome();

            // Notify the user
            alert(`The system "${deletedSystemName}" has been deleted.`);
        }
    } else {
        alert('No system is currently loaded.');
    }
}

/** Builds hierarchical data for D3 org chart */
function buildHierarchyData() {
    if (!currentSystemData) return null;

    // Create maps for efficient lookup
    const sdmMap = new Map((currentSystemData.sdms || []).map(sdm => [sdm.sdmId, { ...sdm, children: [] }]));
    const srMgrMap = new Map((currentSystemData.seniorManagers || []).map(sr => [sr.seniorManagerId, { ...sr, children: [] }]));

    // Nest SDMs under Senior Managers
    sdmMap.forEach(sdm => {
        if (sdm.seniorManagerId && srMgrMap.has(sdm.seniorManagerId)) {
            srMgrMap.get(sdm.seniorManagerId).children.push(sdm);
        } else {
            // Handle SDMs without a valid Senior Manager (add to a default 'unassigned' Sr Mgr?)
            const unassignedSrMgrKey = 'unassigned-sr-mgr';
            if (!srMgrMap.has(unassignedSrMgrKey)) {
                srMgrMap.set(unassignedSrMgrKey, { seniorManagerId: unassignedSrMgrKey, seniorManagerName: 'Unassigned Senior Manager', children: [] });
            }
             // Only add if SDM itself is valid
            if(sdm && sdm.sdmId) srMgrMap.get(unassignedSrMgrKey).children.push(sdm);
        }
    });

    // Nest Teams under SDMs
    (currentSystemData.teams || []).forEach(team => {
        const teamNode = {
            name: team.teamIdentity || team.teamName, // Use Identity primarily
            type: 'team',
            details: `BIS: ${team.buildersInSeats ?? 'N/A'} / Funded: ${team.fundedHeadcount ?? 'N/A'}`,
            children: (team.engineers || []).map(eng => ({
                name: `${eng.name || 'Unnamed'} (L${eng.level ?? '?'})`,
                type: 'engineer'
            }))
        };

        if (team.sdmId && sdmMap.has(team.sdmId)) {
            sdmMap.get(team.sdmId).children.push(teamNode);
        } else {
            // Handle Teams without a valid SDM
            const unassignedSdmKey = 'unassigned-sdm';
             if (!sdmMap.has(unassignedSdmKey)) {
                 sdmMap.set(unassignedSdmKey, { sdmId: unassignedSdmKey, sdmName: 'Unassigned SDM', children: [] });
                 // Add this unassigned SDM group under the unassigned Sr Mgr group for structure
                 const unassignedSrMgrKey = 'unassigned-sr-mgr';
                 if (!srMgrMap.has(unassignedSrMgrKey)) {
                     srMgrMap.set(unassignedSrMgrKey, { seniorManagerId: unassignedSrMgrKey, seniorManagerName: 'Unassigned Senior Manager', children: [] });
                 }
                  srMgrMap.get(unassignedSrMgrKey).children.push(sdmMap.get(unassignedSdmKey));
             }
             // Only add team if it's valid
            if(team && team.teamId) sdmMap.get(unassignedSdmKey).children.push(teamNode);
        }
    });

    // Define the root node
    const root = {
        name: currentSystemData.systemName || 'Organization',
        type: 'root',
        children: Array.from(srMgrMap.values()) // Use Sr Mgrs as top-level children
    };

    return root;
}

/** Generates the Organogram using HTML structure (Replaces D3 version) */
/** REVISED Generates the Organogram using HTML structure - Fix Team Node String */
function generateOrganogram() {
    const hierarchicalData = buildHierarchyData(); // Reuse data transformation
    const container = document.getElementById('organogramContent');
    if (!hierarchicalData || !container) {
        console.error("No data or container for organogram HTML.");
        if(container) container.innerHTML = '<p style="color: red;">Could not generate organogram data.</p>';
        return;
    }
    container.innerHTML = ''; // Clear previous content

    // Recursive function to build nested HTML (using lists for structure)
    function buildHtmlLevel(node, level) {
        if (!node) return '';

        let html = `<div class="org-level-${level}" style="margin-left: ${level * 25}px; margin-bottom: 5px; padding: 5px; border-left: 2px solid #eee;">`; // Increased indent
        let nodeContent = '';

        // Define content based on node type
        switch(node.type) {
            case 'root':
                nodeContent = `<strong>System: ${node.name || 'N/A'}</strong>`;
                break;
            case 'srMgr':
                 nodeContent = `<strong style="color: #0056b3; font-size: 1.1em;">Sr. Manager: ${node.seniorManagerName || node.name || 'N/A'}</strong>`; // Slightly larger
                break;
            case 'sdm':
                 nodeContent = `<strong style="color: #007bff;">SDM: ${node.sdmName || node.name || 'N/A'}</strong>`;
                break;
            case 'team':
                // *** FIX: Use string concatenation instead of template literal ***
                nodeContent = '<span style="color: #17a2b8;">Team: ' + (node.name || 'N/A') + ' (' + (node.details || '') + ')</span>';
                // *************************************************************
                break;
            case 'engineer':
                nodeContent = `<span style="font-size: 0.9em;">${node.name || 'N/A'}</span>`;
                break;
            default: // Handle unassigned groups etc.
                 nodeContent = `<strong>${node.name || 'Group'}</strong>`;
        }

        html += nodeContent;

        // Recursively add children
        if (node.children && node.children.length > 0) {
             // For teams, display engineers comma-separated below
             if (node.type === 'team') {
                 html += '<div style="margin-left: 15px; font-size: 0.9em; color: #555;">'; // Indent engineers slightly
                 html += node.children.map(child => `<span>${child.name || 'N/A'}</span>`).join(', ');
                 html += '</div>';
             } else {
                 // Standard recursive build for other levels
                  node.children.forEach(child => {
                      // Assign type if missing from buildHierarchyData
                      if (!child.type) {
                          if (level === 0) child.type = 'srMgr';
                          else if (level === 1) child.type = 'sdm';
                          else if (level === 2) child.type = 'team';
                      }
                     html += buildHtmlLevel(child, level + 1);
                  });
             }
        }
        html += `</div>`;
        return html;
    }

    // Start building from the root (level 0)
    container.innerHTML = buildHtmlLevel(hierarchicalData, 0);
}

// Global state for engineer table sorting
let engineerSortState = { key: 'name', ascending: true };

/** Generates the HTML table for engineers */
/** REVISED Generates the HTML table for engineers - Updated Heading */
function generateEngineerTable() {
    if (!currentSystemData || !currentSystemData.teams) {
        console.error("Cannot generate engineer table: No data loaded.");
         // Clear table and show error in heading if possible
         const heading = document.getElementById('engineerTableHeading');
         if(heading) heading.innerText = 'Engineer Resource List (Error: No Data)';
         const tableBody = document.querySelector('#engineerTable tbody');
         if(tableBody) tableBody.innerHTML = '';
        return;
    }

    const tableBody = document.querySelector('#engineerTable tbody');
    const heading = document.getElementById('engineerTableHeading');
    tableBody.innerHTML = ''; // Clear existing rows

    // --- Data Preparation & Totals Calculation ---
    let engineerListData = [];
    let totalBIS = 0;
    let totalFundedHC = 0; // Initialize Funded HC total
    const sdmsMap = new Map((currentSystemData.sdms || []).map(s => [s.sdmId, s]));
    const srMgrsMap = new Map((currentSystemData.seniorManagers || []).map(s => [s.seniorManagerId, s]));

    currentSystemData.teams.forEach(team => {
        const currentBIS = team.buildersInSeats ?? (team.engineers?.length ?? 0); // Use calculated BIS
        const currentFunded = team.fundedHeadcount ?? 0; // Use funded HC
        totalBIS += currentBIS;
        totalFundedHC += currentFunded; // Sum Funded HC

        (team.engineers || []).forEach(eng => {
            if (!eng || !eng.name) return;

            const sdm = team.sdmId ? sdmsMap.get(team.sdmId) : null;
            const srMgr = sdm ? srMgrsMap.get(sdm.seniorManagerId) : null;

            engineerListData.push({
                name: eng.name,
                level: eng.level ?? 'N/A',
                teamName: team.teamName || team.teamIdentity || 'N/A',
                sdmName: sdm ? sdm.sdmName : 'N/A',
                srMgrName: srMgr ? srMgr.seniorManagerName : 'N/A'
            });
        });
    });
    const totalGap = totalFundedHC - totalBIS; // Calculate Gap
    // --------------------------------------------

    // --- Update Heading with All Totals ---
    heading.innerText = `Engineer Resource List (Funded: ${totalFundedHC}, BIS: ${totalBIS}, Gap: ${totalGap})`;
    // Optional: Style heading based on gap
    heading.style.color = totalGap < 0 ? 'red' : (totalGap > 0 ? 'darkorange' : 'green');
    // -------------------------------------

    // --- Sorting (Unchanged from previous version) ---
    engineerListData.sort((a, b) => {
        const key = engineerSortState.key;
        const ascending = engineerSortState.ascending;
        let valA = a[key];
        let valB = b[key];

        if (key === 'level') {
             valA = (typeof valA === 'number') ? valA : -1;
             valB = (typeof valB === 'number') ? valB : -1;
             return ascending ? valA - valB : valB - valA;
         }

         valA = (valA || '').toString().toLowerCase();
         valB = (valB || '').toString().toLowerCase();

         if (valA < valB) return ascending ? -1 : 1;
         if (valA > valB) return ascending ? 1 : -1;
         return 0;
     });
    // -------------

    // --- Populate Table (Unchanged from previous version) ---
    engineerListData.forEach(engData => {
        let row = tableBody.insertRow();
        row.insertCell().textContent = engData.name;
        row.insertCell().textContent = engData.level;
        row.insertCell().textContent = engData.teamName;
        row.insertCell().textContent = engData.sdmName;
        row.insertCell().textContent = engData.srMgrName;
    });
    // --------------------

    // --- Add Sorting Click Handlers (Unchanged from previous version) ---
     document.querySelectorAll('#engineerTable th[data-sort-key]').forEach(th => {
         th.removeEventListener('click', handleSortClick);
         th.addEventListener('click', handleSortClick);

         const key = th.getAttribute('data-sort-key');
         let indicator = ' \u2195';
         if (key === engineerSortState.key) {
             indicator = engineerSortState.ascending ? ' \u25B2' : ' \u25BC';
         }
         th.textContent = th.textContent.replace(/ [\u2195\u25B2\u25BC]/g, '') + indicator;
     });
    // -----------------------------
}

// Keep handleSortClick, showOrganogramView, showEngineerTableView functions as they were.
// Make sure buildHierarchyData also still exists.

/** Handles clicking on sortable table headers */
function handleSortClick(event) {
    const key = event.target.getAttribute('data-sort-key');
    if (!key) return;

    if (engineerSortState.key === key) {
        engineerSortState.ascending = !engineerSortState.ascending; // Toggle direction
    } else {
        engineerSortState.key = key; // Change sort key
        engineerSortState.ascending = true; // Default to ascending
    }
    generateEngineerTable(); // Re-generate table with new sort order
}


/** Shows the Organogram View */
function showOrganogramView() {
    // Hide other views
    document.getElementById('visualization').style.display = 'none';
    document.getElementById('teamVisualization').style.display = 'none';
    document.getElementById('teamBreakdown').style.display = 'none';
    document.getElementById('serviceRelationshipsVisualization').style.display = 'none';
    document.getElementById('dependencyVisualization').style.display = 'none';
    document.getElementById('serviceDependenciesTable').style.display = 'none';
    document.getElementById('systemEditForm').style.display = 'none';
    document.getElementById('engineerTableView').style.display = 'none'; // Hide engineer table

    // Generate and show organogram
    generateOrganogram();
    document.getElementById('organogramView').style.display = 'block';
    document.querySelector('.edit-menu').style.display = 'block'; // Keep view buttons visible
}

/** Shows the Engineer Table View */
function showEngineerTableView() {
    // Hide other views
    document.getElementById('visualization').style.display = 'none';
    document.getElementById('teamVisualization').style.display = 'none';
    document.getElementById('teamBreakdown').style.display = 'none';
    document.getElementById('serviceRelationshipsVisualization').style.display = 'none';
    document.getElementById('dependencyVisualization').style.display = 'none';
    document.getElementById('serviceDependenciesTable').style.display = 'none';
    document.getElementById('systemEditForm').style.display = 'none';
    document.getElementById('organogramView').style.display = 'none'; // Hide organogram

    // Generate and show engineer table
    generateEngineerTable(); // Generate with default sort
    document.getElementById('engineerTableView').style.display = 'block';
    document.querySelector('.edit-menu').style.display = 'block'; // Keep view buttons visible
}

/*** Next sections is code for the Planning Feature **/

/** Handles changes to the 'Protected' checkbox in the planning table */
function handleProtectedChange(event) {
    const checkbox = event.target;
    const initiativeId = checkbox.getAttribute('data-initiative-id');
    const isChecked = checkbox.checked;

    if (!initiativeId) {
        console.error("Could not find initiative ID on checkbox:", checkbox);
        return;
    }

    // Find the initiative in the main data array
    const initiative = currentSystemData.yearlyInitiatives.find(init => init.initiativeId === initiativeId);

    if (initiative) {
        // Update the data model
        initiative.isProtected = isChecked;
        console.log(`Updated 'isProtected' for initiative ${initiativeId} to ${isChecked}`);

        // Re-generate the table to reflect the sort change
        generatePlanningTable();
    } else {
        console.error("Could not find initiative data for ID:", initiativeId);
    }
}

/** Stores the ID of the row being dragged */
let draggedInitiativeId = null;
let draggedRowElement = null; // Store the element itself for styling

/** Handles the start of a drag operation */
function handleDragStart(event) {
    draggedInitiativeId = event.target.getAttribute('data-initiative-id');
    draggedRowElement = event.target; // The TR element being dragged
    event.dataTransfer.setData('text/plain', draggedInitiativeId);
    event.dataTransfer.effectAllowed = 'move';

    // Add visual feedback to the row being dragged
    // Use setTimeout to allow the browser to render the drag image first
    setTimeout(() => {
        if(draggedRowElement) draggedRowElement.classList.add('dragging');
    }, 0);
    console.log(`Drag Start: ${draggedInitiativeId}`);
}

/** Handles dragging over a potential drop target */
function handleDragOver(event) {
    event.preventDefault(); // Necessary to allow dropping
    event.dataTransfer.dropEffect = 'move';

    const targetRow = event.target.closest('tr');
    if (!targetRow || targetRow === draggedRowElement) return; // Don't highlight self

    // Add a class to indicate drop zone (e.g., border)
    targetRow.classList.add('drag-over');
}

/** Handles leaving a potential drop target */
function handleDragLeave(event) {
    const targetRow = event.target.closest('tr');
     if (targetRow) {
        targetRow.classList.remove('drag-over');
    }
}

/** Handles the drop operation */
function handleDrop(event) {
    event.preventDefault();
    const targetRow = event.target.closest('tr');
    targetRow.classList.remove('drag-over'); // Clean up visual indicator

    if (!targetRow || !draggedInitiativeId || targetRow.getAttribute('data-initiative-id') === draggedInitiativeId) {
        console.log("Drop cancelled - invalid target or same item.");
        draggedInitiativeId = null; // Reset dragged item
        return;
    }

    const targetInitiativeId = targetRow.getAttribute('data-initiative-id');
    console.log(`Drop: ${draggedInitiativeId} onto ${targetInitiativeId}`);

    // --- Find initiatives and check protection status ---
    const initiatives = currentSystemData.yearlyInitiatives;
    const draggedIndex = initiatives.findIndex(init => init.initiativeId === draggedInitiativeId);
    const targetIndex = initiatives.findIndex(init => init.initiativeId === targetInitiativeId);

    if (draggedIndex === -1 || targetIndex === -1) {
        console.error("Could not find dragged or target initiative in data array.");
        draggedInitiativeId = null;
        return;
    }

    const draggedInitiative = initiatives[draggedIndex];
    const targetInitiative = initiatives[targetIndex];

    // --- Apply Reordering Constraints ---
    const draggedIsProtected = draggedInitiative.isProtected;
    const targetIsProtected = targetInitiative.isProtected;

    // Constraint 1: Cannot move non-protected above protected
    if (!draggedIsProtected && targetIsProtected && targetIndex < draggedIndex) {
         console.log("Move invalid: Cannot move non-protected item above protected item.");
         alert("Cannot move a non-protected item above a protected item.");
         draggedInitiativeId = null; // Reset
         return;
    }
    // Constraint 2: Cannot move protected below non-protected
    if (draggedIsProtected && !targetIsProtected && targetIndex > draggedIndex) {
         console.log("Move invalid: Cannot move protected item below non-protected item.");
          alert("Cannot move a protected item below non-protected items.");
         draggedInitiativeId = null; // Reset
         return;
    }
    // --- End Constraints ---


    // --- Perform Reorder in the Data Array ---
    // Remove the dragged item
    const [movedItem] = initiatives.splice(draggedIndex, 1);

    // Find the *new* index of the target item after removal
    const newTargetIndex = initiatives.findIndex(init => init.initiativeId === targetInitiativeId);

    // Insert the moved item before the target
    initiatives.splice(newTargetIndex, 0, movedItem);
    console.log("Reordered initiatives array:", initiatives.map(i => i.initiativeId));
    // --- End Reorder ---


    // --- Refresh the Table ---
    generatePlanningTable();
    // --- End Refresh ---

    draggedInitiativeId = null; // Reset dragged item
}

/** Cleans up after drag operation ends (dropped or cancelled) */
function handleDragEnd(event) {
    // Remove the dragging class from the original element
     if (draggedRowElement) {
        draggedRowElement.classList.remove('dragging');
    }
    // Clean up any lingering drag-over styles just in case
    document.querySelectorAll('#planningTableBody tr.drag-over').forEach(row => {
        row.classList.remove('drag-over');
    });

    console.log("Drag End");
    draggedInitiativeId = null;
    draggedRowElement = null;
}

/** Handles changes to SDE Year estimate inputs in the planning table */
function handleEstimateChange(event) {
    const input = event.target;
    const initiativeId = input.getAttribute('data-initiative-id');
    const teamId = input.getAttribute('data-team-id');
    const newValue = parseFloat(input.value);

    if (!initiativeId || !teamId) {
        console.error("Missing initiative or team ID on estimate input:", input);
        return;
    }

    // Validate the input value
    const validatedValue = (!isNaN(newValue) && newValue > 0) ? newValue : 0;

    // Find the initiative
    const initiative = currentSystemData.yearlyInitiatives.find(init => init.initiativeId === initiativeId);
    if (!initiative) {
        console.error("Could not find initiative data for ID:", initiativeId);
        return;
    }

    // Ensure assignments array exists
    if (!initiative.assignments) {
        initiative.assignments = [];
    }

    // Find existing assignment for this team
    const assignmentIndex = initiative.assignments.findIndex(a => a.teamId === teamId);

    if (validatedValue > 0) {
        if (assignmentIndex > -1) {
            // Update existing assignment
            initiative.assignments[assignmentIndex].sdeYears = validatedValue;
            console.log(`Updated estimate for ${initiativeId}, team ${teamId} to ${validatedValue}`);
        } else {
            // Add new assignment
            initiative.assignments.push({ teamId: teamId, sdeYears: validatedValue });
            console.log(`Added estimate for ${initiativeId}, team ${teamId}: ${validatedValue}`);
        }
        // Optionally reformat the input value after successful update
        input.value = validatedValue.toFixed(2);
    } else {
        // Remove assignment if value is 0 or invalid
        if (assignmentIndex > -1) {
            initiative.assignments.splice(assignmentIndex, 1);
            console.log(`Removed assignment for ${initiativeId}, team ${teamId}`);
        }
        // Clear the input field if the value was invalid or zero
        input.value = '';
    }

    // --- Refresh the entire table to recalculate totals and statuses ---
    generatePlanningTable();
    // --- End Refresh ---

    // Optional: Maintain focus if needed, though redraw might make it tricky
    // input.focus(); // Might not work reliably after full redraw
}

/** REVISED - Generates the interactive planning table with data */
function generatePlanningTable() {
    console.log("Generating planning table...");
    const container = document.getElementById('planningTableContainer');
    const capacitySummaryDiv = document.getElementById('planningCapacitySummary');
    container.innerHTML = ''; // Clear previous table
    capacitySummaryDiv.innerHTML = ''; // Clear previous summary

    if (!currentSystemData || !currentSystemData.yearlyInitiatives) {
        container.innerHTML = '<p style="color: orange;">No planning data loaded or initiatives defined for this system.</p>';
        console.warn("No currentSystemData or yearlyInitiatives found.");
        return;
    }

    // --- 1. Calculate Capacity ---
    let totalBIS = 0;
    let totalFundedHC = 0;
    (currentSystemData.teams || []).forEach(team => {
        totalBIS += team.buildersInSeats ?? (team.engineers?.length ?? 0);
        totalFundedHC += team.fundedHeadcount ?? 0;
    });
    capacitySummaryDiv.innerHTML = `Total Capacity - Funded HC: <span style="color: green;">${totalFundedHC.toFixed(2)}</span> SDE Years | BIS: <span style="color: darkorange;">${totalBIS.toFixed(2)}</span> SDE Years`;
    console.log(`Calculated Capacity - Funded: ${totalFundedHC}, BIS: ${totalBIS}`);
    // --- End Calculate Capacity ---

    // --- 2. Prepare Table Structure ---
    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';
    table.id = 'planningTable'; // Add ID

    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');

    // Fixed Headers
    const fixedHeaders = ['Protected', 'Title', 'ID', 'Description', 'Total SDE Years', 'Cumalative SDE Years', 'Capacity Status', 'ATL/BTL'];
    fixedHeaders.forEach(text => {
        const th = document.createElement('th');
        th.textContent = text;
        th.style.border = '1px solid #ccc'; th.style.padding = '8px'; th.style.textAlign = 'left'; th.style.backgroundColor = '#f2f2f2';
        th.style.position = 'sticky'; th.style.top = '0'; // Make headers sticky
        headerRow.appendChild(th);
    });

    // Dynamic Team Headers
    const teams = currentSystemData.teams || [];
    const teamHeaderMap = new Map(); // To easily get teamId by column index later
    teams.forEach((team, index) => {
        const th = document.createElement('th');
        const teamDisplayName = team.teamIdentity || team.teamName || team.teamId;
        th.textContent = teamDisplayName;
        th.title = teamDisplayName; // Add tooltip for potentially long names
        th.setAttribute('data-team-id', team.teamId);
        th.style.border = '1px solid #ccc'; th.style.padding = '8px'; th.style.textAlign = 'center'; th.style.backgroundColor = '#e6f7ff';
        th.style.position = 'sticky'; th.style.top = '0'; // Make headers sticky
        th.style.writingMode = 'vertical-lr';
        th.style.textOrientation = 'mixed';
        th.style.whiteSpace = 'nowrap';
        th.style.minWidth = '35px'; // Adjust width as needed
        th.style.maxWidth = '35px';
        headerRow.appendChild(th);
        teamHeaderMap.set(fixedHeaders.length + index, team.teamId); // Store teamId by column index
    });

    thead.appendChild(headerRow);
    table.appendChild(thead);
    // --- End Table Structure ---

    // --- 3. Sort Initiatives & Populate Body ---
    const tbody = document.createElement('tbody');
    tbody.id = 'planningTableBody';

    // Sort: Protected first, then maintain original relative order (implicit via array order)
    const sortedInitiatives = [...currentSystemData.yearlyInitiatives].sort((a, b) => {
        if (a.isProtected && !b.isProtected) return -1;
        if (!a.isProtected && b.isProtected) return 1;
        return 0; // Maintain original order among protected/non-protected blocks
        // Later, drag-drop will modify the order in currentSystemData.yearlyInitiatives directly
    });

    let cumulativeSdeTotal = 0;

    sortedInitiatives.forEach((initiative, rowIndex) => {
        if (!initiative || !initiative.initiativeId) {
            console.warn("Skipping invalid initiative data:", initiative);
            return;
        }

        const row = tbody.insertRow();
        row.setAttribute('draggable', 'true'); // Make row draggable
        row.setAttribute('data-initiative-id', initiative.initiativeId);
        row.style.borderBottom = '1px solid #eee'; // Add faint row separators
        // Add slight padding for easier dropping between rows
        row.style.padding = '2px 0';

        // *** ADD DRAG LISTENERS ***
        row.addEventListener('dragstart', handleDragStart);
        row.addEventListener('dragover', handleDragOver);
        row.addEventListener('dragleave', handleDragLeave);
        row.addEventListener('drop', handleDrop);
        row.addEventListener('dragend', handleDragEnd);
        
        // --- Fixed Cells ---
        // Protected Checkbox
        const protectedCell = row.insertCell();
        const protectedCheckbox = document.createElement('input');
        protectedCheckbox.type = 'checkbox';
        protectedCheckbox.checked = initiative.isProtected;
        protectedCheckbox.setAttribute('data-initiative-id', initiative.initiativeId);
        protectedCheckbox.style.cursor = 'pointer';
        protectedCheckbox.onchange = handleProtectedChange; // Add the event listener
        protectedCell.appendChild(protectedCheckbox);
        protectedCell.style.textAlign = 'center';

        // Title
        const titleCell = row.insertCell();
        titleCell.textContent = initiative.title || 'No Title';
        titleCell.style.fontWeight = initiative.isProtected ? 'bold' : 'normal';

        // Id
        const idCell = row.insertCell();
        idCell.textContent = initiative.initiativeId;
        idCell.style.fontSize = '0.8em'; // Make it smaller perhaps
        idCell.style.color = '#555';    // Grey it out slightly

        // Description (Truncated with Tooltip)
        const descCell = row.insertCell();
        const descText = initiative.description || '';
        descCell.textContent = descText.length > 50 ? descText.substring(0, 47) + '...' : descText; // Truncate
        descCell.title = descText; // Full description on hover

        // --- Calculated Cells (Placeholders first) ---
        const totalSdeCell = row.insertCell(); totalSdeCell.style.textAlign = 'right';
        const cumSdeCell = row.insertCell(); cumSdeCell.style.textAlign = 'right';
        const statusCell = row.insertCell(); statusCell.style.textAlign = 'center';
        const atlBtlCell = row.insertCell(); atlBtlCell.style.fontWeight = 'bold'; atlBtlCell.style.textAlign = 'center';

        // --- Dynamic Team Cells & Calculate Initiative Total ---
        let initiativeTotalSde = 0;
        const assignmentsMap = new Map((initiative.assignments || []).map(a => [a.teamId, a.sdeYears]));

        teamHeaderMap.forEach((teamId, colIndex) => { // Iterate using the header map order
            const teamCell = row.insertCell();
            const currentEstimate = assignmentsMap.get(teamId) || 0;

            // *** Replace textContent with an input element ***
            const estimateInput = document.createElement('input');
            estimateInput.type = 'number';
            estimateInput.min = '0';
            estimateInput.step = '0.25'; // Allow quarter SDE years
            estimateInput.value = currentEstimate > 0 ? currentEstimate.toFixed(2) : ''; // Show empty for 0
            estimateInput.setAttribute('data-initiative-id', initiative.initiativeId);
            estimateInput.setAttribute('data-team-id', teamId);
            estimateInput.style.width = '60px'; // Adjust width as needed
            estimateInput.style.textAlign = 'right';
            estimateInput.style.border = 'none'; // Remove border for inline feel
            estimateInput.style.backgroundColor = 'transparent'; // Blend with cell
            // Add listener to handle changes
            estimateInput.addEventListener('change', handleEstimateChange);
            // Optional: Recalculate on blur as well or instead of change
            // estimateInput.addEventListener('blur', handleEstimateChange);

            teamCell.appendChild(estimateInput);
            
            teamCell.style.textAlign = 'center';
            teamCell.style.backgroundColor = currentEstimate > 0 ? '#fffacd' : '#fafafa'; // Highlight assigned cells
            initiativeTotalSde += currentEstimate;
        });

        // --- Populate Calculated Cells ---
        totalSdeCell.textContent = initiativeTotalSde.toFixed(2);
        cumulativeSdeTotal += initiativeTotalSde;
        cumSdeCell.textContent = cumulativeSdeTotal.toFixed(2);

        // Capacity Status
        if (cumulativeSdeTotal <= totalBIS) {
            statusCell.textContent = '✅'; // Within BIS
            statusCell.title = `Within BIS Capacity (${totalBIS.toFixed(2)})`;
            statusCell.style.backgroundColor = '#d4edda'; // Light green
        } else if (cumulativeSdeTotal <= totalFundedHC) {
            statusCell.textContent = '⚠️'; // Exceeds BIS but within Funded
            statusCell.title = `Exceeds BIS (${totalBIS.toFixed(2)}), Within Funded HC (${totalFundedHC.toFixed(2)})`;
            statusCell.style.backgroundColor = '#fff3cd'; // Light yellow
        } else {
            statusCell.textContent = '🛑'; // Exceeds Funded HC
            statusCell.title = `Exceeds Funded HC (${totalFundedHC.toFixed(2)})`;
            statusCell.style.backgroundColor = '#f8d7da'; // Light red
        }

        // ATL/BTL Status
        if (cumulativeSdeTotal <= totalFundedHC) {
            atlBtlCell.textContent = 'ATL';
            atlBtlCell.style.color = 'green';
        } else {
            atlBtlCell.textContent = 'BTL';
            atlBtlCell.style.color = 'red';
            // Optional: Style the whole row slightly differently if BTL
            // row.style.backgroundColor = '#ffeeee'; // Very light pink for BTL rows
        }

    }); // End sortedInitiatives.forEach

    table.appendChild(tbody);
    container.appendChild(table);
    // --- End Populate Body ---

    // --- 4. Add Drag/Drop Event Listeners (Placeholder for next step) ---
    // TODO: Implement makeTableDraggable(table.id);
    console.log("Placeholder: Need to implement table row drag/drop.");

    // --- 5. Add Checkbox Listeners (Placeholder for next step) ---
    // TODO: Add event listeners to 'Protected' checkboxes.
    console.log("Placeholder: Need to implement protected checkbox logic.");

} // --- End generatePlanningTable ---

/** Shows the Yearly Planning View */
function showPlanningView() {
    console.log("Switching to Yearly Planning View...");
    currentMode = Modes.PLANNING; // Assuming we might add a PLANNING mode

    // --- Hide ALL other main view sections ---
    const viewsToHide = [
        'systemEditForm', 'visualization', 'teamVisualization', 'teamBreakdown',
        'serviceRelationshipsVisualization', 'dependencyVisualization', 'serviceDependenciesTable',
        'organogramView', 'engineerTableView'
    ];
    viewsToHide.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.style.display = 'none';
    });
    // Ensure edit menu is visible (for view switching) but main menu is hidden
    const editMenu = document.querySelector('.edit-menu');
    if (editMenu) editMenu.style.display = 'block';
    const mainMenu = document.querySelector('.menu');
    if (mainMenu) mainMenu.style.display = 'none';
    // ----------------------------------------

    // --- Show the Planning View ---
    const planningViewDiv = document.getElementById('planningView');
    if (planningViewDiv) {
        planningViewDiv.style.display = 'block';
        // Update title based on loaded system
        const planningTitle = document.getElementById('planningViewTitle');
        if (planningTitle && currentSystemData && currentSystemData.systemName) {
            planningTitle.innerText = `Yearly Planning View: ${currentSystemData.systemName}`;
        } else if (planningTitle) {
            planningTitle.innerText = `Yearly Planning View (No System Loaded)`;
        }
        // Generate the table content
        generatePlanningTable(); // Call the function to build the table
        
        // --- Populate Team Select & Attach Listeners (Ensure this happens AFTER elements are visible) ---
        populateTeamSelect();

        const addAssignButton = document.getElementById('addTeamAssignmentButton');
        if (addAssignButton && !addAssignButton.hasAttribute('data-listener-attached')) {
             addAssignButton.addEventListener('click', handleAddTeamAssignment);
             addAssignButton.setAttribute('data-listener-attached', 'true'); // Prevent multiple listeners
        }

        const addInitButton = document.getElementById('addInitiativeButton');
         if (addInitButton && !addInitButton.hasAttribute('data-listener-attached')) {
            addInitButton.addEventListener('click', handleAddInitiative);
            addInitButton.setAttribute('data-listener-attached', 'true'); // Prevent multiple listeners
         }     

         // *** ADD LISTENER FOR SAVE PLAN BUTTON ***
         const savePlanButton = document.getElementById('savePlanButton');
         if (savePlanButton && !savePlanButton.hasAttribute('data-listener-attached')) {
            savePlanButton.addEventListener('click', handleSavePlan);
            savePlanButton.setAttribute('data-listener-attached', 'true');
         }         
    } else {
        console.error("Planning view container not found!");
    }
    // ---------------------------
}

// --- Add New Initiative Logic ---

// Store temporary assignments before adding the initiative
let tempAssignments = [];

/** Populates the team selection dropdown in the 'Add Initiative' section */
function populateTeamSelect() {
    const select = document.getElementById('newInitiativeTeamSelect');
    if (!select) return;

    // Clear existing options except the placeholder
    select.length = 1; // Keep only the "-- Select Team --" option

    (currentSystemData.teams || []).forEach(team => {
        const option = document.createElement('option');
        option.value = team.teamId;
        option.textContent = team.teamIdentity || team.teamName || team.teamId;
        select.appendChild(option);
    });
}

/** Updates the display area showing temporary team assignments */
function displayTempAssignments() {
    const displayDiv = document.getElementById('newInitiativeAssignmentsDisplay');
    if (!displayDiv) return;
    displayDiv.innerHTML = ''; // Clear current display

    tempAssignments.forEach((assignment, index) => {
        const team = (currentSystemData.teams || []).find(t => t.teamId === assignment.teamId);
        const teamName = team ? (team.teamIdentity || team.teamName) : assignment.teamId;
        const assignmentDiv = document.createElement('div');
        assignmentDiv.style.marginBottom = '3px';
        assignmentDiv.textContent = `${teamName}: ${assignment.sdeYears.toFixed(2)} SDE Years `;

        const removeButton = document.createElement('button');
        removeButton.textContent = 'Remove';
        removeButton.style.marginLeft = '10px';
        removeButton.style.fontSize = '0.8em';
        removeButton.onclick = () => {
            tempAssignments.splice(index, 1); // Remove from array
            displayTempAssignments(); // Refresh display
        };
        assignmentDiv.appendChild(removeButton);
        displayDiv.appendChild(assignmentDiv);
    });
}

/** Handles clicking the 'Add Assignment' button */
function handleAddTeamAssignment() {
    const teamSelect = document.getElementById('newInitiativeTeamSelect');
    const sdeYearsInput = document.getElementById('newInitiativeSdeYears');
    const teamId = teamSelect.value;
    const sdeYears = parseFloat(sdeYearsInput.value);

    // Validation
    if (!teamId) {
        alert('Please select a team.');
        return;
    }
    if (isNaN(sdeYears) || sdeYears <= 0) {
        alert('Please enter a valid positive number for SDE Years.');
        return;
    }

    // Check if team already assigned in temp list
    const existingIndex = tempAssignments.findIndex(a => a.teamId === teamId);
    if (existingIndex > -1) {
        // Update existing assignment
        tempAssignments[existingIndex].sdeYears = sdeYears;
        console.log(`Updated assignment for team ${teamId} to ${sdeYears}`);
    } else {
        // Add new assignment
        tempAssignments.push({ teamId: teamId, sdeYears: sdeYears });
        console.log(`Added assignment for team ${teamId}: ${sdeYears}`);
    }

    // Refresh display and clear inputs
    displayTempAssignments();
    teamSelect.selectedIndex = 0; // Reset dropdown
    sdeYearsInput.value = '';
}

/** Handles clicking the 'Add Initiative to Plan' button */
function handleAddInitiative() {
    const titleInput = document.getElementById('newInitiativeTitle');
    const descriptionInput = document.getElementById('newInitiativeDescription');
    const goalIdInput = document.getElementById('newInitiativeGoalId');

    const title = titleInput.value.trim();
    const description = descriptionInput.value.trim();
    const goalId = goalIdInput.value.trim() || null; // Use null if empty

    // Validation
    if (!title) {
        alert('Initiative Title cannot be empty.');
        return;
    }
    if (tempAssignments.length === 0) {
        alert('Please add at least one team assignment.');
        return;
    }

    // Create new initiative object
    const newInitiative = {
        initiativeId: 'init-' + Date.now() + '-' + Math.floor(Math.random() * 1000), // Simple unique ID
        title: title,
        description: description,
        relatedBusinessGoalId: goalId,
        isProtected: false, // New initiatives are not protected by default
        assignments: [...tempAssignments] // Copy the temporary assignments
    };

    // Add to main data structure
    if (!currentSystemData.yearlyInitiatives) {
        currentSystemData.yearlyInitiatives = [];
    }
    currentSystemData.yearlyInitiatives.push(newInitiative);
    console.log("Added new initiative:", newInitiative);

    // Clear form and temporary data
    titleInput.value = '';
    descriptionInput.value = '';
    goalIdInput.value = '';
    tempAssignments = [];
    displayTempAssignments(); // Clear display area

    // Refresh the main planning table
    generatePlanningTable();
}

/** Handles clicking the 'Save Current Plan' button */
function handleSavePlan() {
    console.log("Attempting to save plan from planning view...");

    if (!currentSystemData || !currentSystemData.systemName) {
        alert("Cannot save plan: No system data loaded or system name is missing.");
        return;
    }

    // --- Perform Pre-Save Actions ---
    // Ensure global platform dependencies reflect assignments before saving
    buildGlobalPlatformDependencies();
    // Validate engineer assignments (important if edits happened elsewhere)
    if (!validateEngineerAssignments()) {
        // Validation function already shows an alert
        return;
    }
    // Add any other planning-specific validations here if needed later
    // --- End Pre-Save Actions ---


    // --- Save the ENTIRE currentSystemData object to Local Storage ---
    // The yearlyInitiatives array within currentSystemData should reflect the current order and estimates.
    try {
        const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
        const systemNameKey = currentSystemData.systemName; // Use the name stored in the data

        // Save the current data under its name
        systems[systemNameKey] = currentSystemData;
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

        alert(`Plan for system "${systemNameKey}" saved successfully.`);
        console.log('System changes saved to local storage via Save Plan button.');

    } catch (error) {
        console.error("Error saving system to local storage:", error);
        alert("An error occurred while trying to save the plan. Please check the console for details.");
    }
    // ---------------------------------------------------------------
}


// Attach functions to the global window object
window.showSavedSystems = showSavedSystems;
window.createNewSystem = createNewSystem;
window.resetToDefaults = resetToDefaults;
window.returnToHome = returnToHome;
window.showPlanningView = showPlanningView;

</script>

</body>
</html>
