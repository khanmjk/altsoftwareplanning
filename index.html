<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Architecture Visualization Tool</title>
    <!-- Include D3.js for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <style>
        /* Basic styling */
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { text-align: center; }
        .menu, .edit-menu { text-align: center; margin-bottom: 20px; }
        .menu button, .edit-menu button { margin: 5px; padding: 10px 20px; font-size: 16px; }
        #visualization, #teamVisualization { max-width: 800px; margin: 20px auto; }
        svg { width: 100%; height: 600px; border: 1px solid #ccc; }
        #teamTable { width: 100%; border-collapse: collapse; margin-top: 20px; }
        #teamTable th, #teamTable td { border: 1px solid #ccc; padding: 8px; text-align: left; vertical-align: top; }
        .node text { pointer-events: none; font-size: 12px; }
        .tooltip { position: absolute; text-align: left; width: auto; max-width: 300px; padding: 5px; font: 12px sans-serif; background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; pointer-events: none; }
        .legend { font-size: 12px; display: flex; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; margin-right: 15px; margin-bottom: 5px; }
        .team-edit {margin-bottom: 15px;padding: 10px;border: 1px solid #ccc;}
    
          #returnHomeButton {
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 10px 15px;
          font-size: 14px;
          z-index: 1000;
          }

          #systemDescription {
              text-align: center; /* Add this line to center the text */
              /* You can add other styles here too if needed, like margin */
              margin-top: 10px;
              margin-bottom: 20px;
          }
          
          #backToSystemViewButton {
            position: fixed;
            top: 20px;
            /* Adjust 'right' value to position it left of Return Home */
            /* Return home is at 20px, add its width + margin */
            /* Let's estimate ~140px for Return Home + 10px margin + 10px gap */
            right: 170px; /* Adjust this pixel value as needed */
            padding: 10px 15px;
            font-size: 14px;
            z-index: 1000; /* Same stack level as Return Home */
            display: none; /* Keep initial display none */
          }          
          
          .team-edit {
              margin-bottom: 15px;
              border: 1px solid #ccc;
          }
          
          .team-edit h4 {
              margin: 0;
              padding: 10px;
              background-color: #f2f2f2;
          }
          
          .team-details {
              padding: 10px;
              display: none;
          }
          .service-edit {
              margin-bottom: 15px;
              border: 1px solid #ccc;
          }
          
          .service-edit h4 {
              margin: 0;
              padding: 10px;
              background-color: #e6f7ff;
              cursor: pointer;
          }
          
          .service-details {
              padding: 10px;
              display: none;
          }
          
          .api-edit {
              margin-left: 20px;
              margin-bottom: 10px;
              border: 1px solid #ddd;
              padding: 10px;
          }    

          /* --- Visualization Carousel Styles --- */
          #visualizationCarousel {
              position: relative;
              max-width: 90%;   /* <-- Changed to match service table */
              margin: 20px auto;
              border: 1px solid #ddd;
              padding: 10px;
              display:none; /* Initially hidden */
          }
          
          #visualizationCarousel .carousel-item {
              /* display: none; */ /* Initially set in HTML, JS will manage */
              /* Optional: Add transition effects later if desired */
              /* transition: opacity 0.5s ease-in-out; */
              /* opacity: 0; */
              width: 100%; /* Ensure items take full width */
          }
          
          #visualizationCarousel .carousel-item.active {
              display: block; /* Show the active item */
              /* opacity: 1; */
          }
          
          /* Style for the central title */
          #visualizationTitle {
              display: inline-block; /* Allows margin */
              min-width: 250px;      /* Give it some space */
              text-align: center;
          }
          
          /* Optional: Basic button styling */
          #visualizationCarousel button {
              padding: 5px 10px;
              cursor: pointer;
          }
          /* --- End Carousel Styles --- */


          /* Adjust SVG size for service visualization */
          #serviceSvg {
              width: 100%;
              height: 600px;
              border: 1px solid #ccc;
          }
          
          /* Adjust tooltip styling if necessary */
          .tooltip {
              position: absolute;
              text-align: left;
              width: auto;
              max-width: 300px;
              padding: 5px;
              font: 12px sans-serif;
              background: rgba(255, 255, 255, 0.9);
              border: 1px solid #ccc;
              pointer-events: none;
              z-index: 1000;
          }
          /* Dependency visualization styles */
          .node circle {
              fill: #fff;
              stroke: steelblue;
              stroke-width: 2px;
          }
          
          .node text {
              font: 12px sans-serif;
          }
          
          .link {
              fill: none;
              stroke: #ccc;
              stroke-width: 2px;
          }
          
          .tooltip {
              position: absolute;
              text-align: left;
              width: auto;
              max-width: 300px;
              padding: 10px;
              font: 12px sans-serif;
              background: rgba(255, 255, 255, 0.9);
              border: 1px solid #ccc;
              border-radius: 5px;
              pointer-events: none;
              z-index: 1000;
          }
          #serviceDependenciesTable {
              margin-top: 20px;
          }
          
          #serviceDependenciesTable table {
              width: 100%;
              border-collapse: collapse;
          }
          
          #serviceDependenciesTable th, #serviceDependenciesTable td {
              border: 1px solid #ccc;
              padding: 8px;
              text-align: left;
          }
          
          #serviceDependenciesTable th {
              background-color: #f2f2f2;
          }
          
          #serviceDependenciesTable tr:nth-child(even) {
              background-color: #f9f9f9;
          }
          
          #serviceDependenciesTable tr:hover {
              background-color: #e9e9e9;
          }          
          .platform-deps-container {
              display: flex;
              align-items: center;
          }
          .current-deps, .other-deps {
              flex: 1;
              margin: 0 10px;
          }
          .platform-deps-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          .platform-deps-buttons button {
              margin: 5px 0;
          }
          .platform-deps-container select {
              width: 100%;
              min-height: 100px;
          }          
          .service-deps-container {
              display: flex;
              align-items: center;
              margin-bottom: 10px;
          }
          
          .current-service-deps, .other-services {
              flex: 1;
              margin: 0 10px;
          }
          
          .service-deps-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          
          .service-deps-buttons button {
              margin: 5px 0;
          }
          
          .service-deps-container select {
              width: 100%;
              min-height: 100px;
          }
          /* Styles for Dependent APIs */
          .dependent-apis-container {
              display: flex;
              align-items: center;
              margin-bottom: 10px;
          }
          
          .current-dependent-apis, .other-apis {
              flex: 1;
              margin: 0 10px;
          }
          
          .dependent-apis-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          
          .dependent-apis-buttons button {
              margin: 5px 0;
          }
          
          .dependent-apis-container select {
              width: 100%;
              min-height: 100px;
          }          
          /* Add styles for new views */
          #organogramView, #engineerTableView {
              max-width: 90%; /* Allow wider view */
              margin: 20px auto;
          }
          
          #organogramSvg {
              width: 100%;
              height: 700px; /* Adjust as needed */
              border: 1px solid #ccc;
              background-color: #f9f9f9; /* Light background */
          }
          
          /* Styles for Organogram Nodes/Links (Example) */
          .organogram-link {
            fill: none;
            stroke: #555;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
          }
          
          .organogram-node circle { /* Example using circles */
            stroke: steelblue;
            stroke-width: 1.5px;
          }
           .organogram-node rect { /* Example using rectangles */
            stroke: steelblue;
            stroke-width: 1.5px;
            fill: #fff;
          }
          
          .organogram-node text {
            font: 10px sans-serif;
            /* Adjust text anchor and position based on layout */
          }
          
           /* Styles for Engineer Table */
           #engineerTable th, #engineerTable td {
               border: 1px solid #ccc;
               padding: 8px;
               text-align: left;
           }
           #engineerTable th {
               background-color: #f2f2f2;
           }
            #engineerTable th[data-sort-key]:hover { /* Indicate sortable */
               background-color: #e0e0e0;
               text-decoration: underline;
            }
          #engineerTable tr:nth-child(even) {
              background-color: #f9f9f9;
          }          
          /* Also add some basic CSS for visual feedback (place within the <style> tag) */
          /* Add styles for drag-and-drop feedback */
          #planningTableBody tr.dragging {
              opacity: 0.5;
              border: 2px dashed #ccc;
          }
          #planningTableBody tr.drag-over {
              border-top: 2px solid blue; /* Highlight where it will drop */
          }          
      /* --- Styles for Planning Table Enhancements (Revised for Alignment Fix) --- */
          #planningTableWrapper {
              overflow: auto; /* Enable BOTH horizontal and vertical scrolling */
              /* max-height: 550px; */ /* Set max height before vertical scroll appears (Adjust as needed) */
              max-width: 100%;   /* Ensure it doesn't overflow its parent */
              margin-bottom: 15px; /* Add some space below */
              border: 1px solid #ccc; /* Optional: add a border to see the scroll container */
          }
      
          /* Make headers stick within the scrollable container */
          #planningTable thead th {
            position: sticky;
            top: 0;
            z-index: 2;
            background-color: #f2f2f2;
            border: 1px solid #ccc;
            text-align: left;
            white-space: nowrap;
            /* --- ADDED specific, reduced padding and font-size --- */
            padding: 3px 5px;  /* Reduced vertical and horizontal padding */
            font-size: 0.85em; /* Reduced font size */
            /* ----------------------------------------------------- */
          }
           /* Ensure the background of the dynamic team headers is also solid */
       #planningTable th[data-team-id] {
            background-color: #e6f7ff;
            writing-mode: vertical-lr;
            text-orientation: mixed;
            text-align: center;
            /* --- Apply reduced padding/font AND adjust min/max width --- */
            padding: 5px 2px;  /* Adjusted padding for vertical (more top/bottom, less left/right) */
            font-size: 0.8em;  /* Further reduced font for vertical names */
            min-width: 25px;   /* Reduced width */
            max-width: 25px;   /* Reduced width */
        
          }
      
      
          /* Center-align specific numerical columns in the planning table */
          #planningTable th:nth-child(5), /* Total SDE Years Header */
          #planningTable td:nth-child(5), /* Total SDE Years Cell */
          #planningTable th:nth-child(6), /* Cumulative SDE Years Header */
          #planningTable td:nth-child(6) { /* Cumulative SDE Years Cell */
              text-align: center !important; /* Use important if needed */
          }

/* --- REVISED: Reduce font size and padding for BOTH planning table rows AND summary table rows --- */
        #planningTable tbody td,
        #teamLoadSummaryTable tbody td { /* Added summary table selector */
            padding: 2px 3px;   /* Reduced vertical padding */
            font-size: 0.80em; /* Smaller row font */
            border: 1px solid #eee;
            vertical-align: middle; /* Align content vertically */
        }
        /* Also target inputs in the main planning table */
        #planningTable tbody td input[type="number"] {
             vertical-align: middle;
            font-size: 0.85em; /* Smaller row font */             
        }
        /* Style summary table footer cells similarly */
        #teamLoadSummaryTable tfoot td {
            padding: 2px 3px;
            font-size: 0.80em; /* Apply same font size */
            border: 1px solid #ccc; /* Keep slightly stronger border for footer */
            background-color: #f8f9fa; /* Keep footer background */
            text-align: center; /* Keep footer text centered */
            vertical-align: middle;
        }
        /* Adjust the first footer cell (label) alignment */
         #teamLoadSummaryTable tfoot td:first-child {
            text-align: left;
         }
 
        /* --- REVISED: Control column widths for Team Load Summary Table (Attempt 2) --- */
        #teamLoadSummaryTable thead th {
             /* Base style if needed */
        }
        #teamLoadSummaryTable thead th:nth-child(1) { text-align: left; width: 10%; max-width: 30px} /* Team Name */
        #teamLoadSummaryTable thead th:nth-child(2), /* Funded HC */
        #teamLoadSummaryTable thead th:nth-child(3), /* Team BIS */
        #teamLoadSummaryTable thead th:nth-child(4), /* Away BIS */
        #teamLoadSummaryTable thead th:nth-child(5) { width: 8%; } /* Effective BIS */
        #teamLoadSummaryTable thead th:nth-child(6) { width: 12%; max-width: 40px; } /* Assigned ATL SDEs */
        #teamLoadSummaryTable thead th:nth-child(7) { width: 12%; max-width: 40px; } /* Scenario Capacity Limit */
        #teamLoadSummaryTable thead th:nth-child(8) { width: 12%; max-width: 40px; } /* Remaining Capacity (ATL) */
        #teamLoadSummaryTable thead th:nth-child(9) { width: 10%; } /* ATL Status */
        /* -------------------------------------------------------------------------- */

          /* REVISED Style for clickable headers */
          #planningView h3[onclick],
          #planningView h4[onclick] { /* Keep targeting both in case h4 is used later */
              cursor: pointer;
              /* Removed position: relative and padding-left */
          }
          /* REVISED Style for toggle indicator */
          #planningView h3[onclick] span.toggle-indicator,
          #planningView h4[onclick] span.toggle-indicator {
               /* Removed absolute positioning properties */
               display: inline-block; /* Keep this */
               font-weight: bold;    /* Keep this */
               margin-right: 5px;    /* Add some space after the indicator */
               /* Optional: Adjust color if desired */
               /* color: #007bff; */
          }
          /* Style for the disabled constraints toggle label */
          .toggle-disabled {
              opacity: 0.6;  /* Make it appear faded */
              color: #6c757d; /* Grey out the text */
              cursor: not-allowed !important; /* Ensure 'not-allowed' cursor */
          }
          .toggle-disabled input[type="checkbox"] {
               cursor: not-allowed !important; /* Apply to checkbox too */
          }            
        /* --- Styles specifically for SDM Forecasting Tool View --- */
        #sdmForecastingView .input-section,
        #sdmForecastingView .output-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #eee; /* Add a light border */
            border-radius: 4px;
        }

        #sdmForecastingView .input-group {
            margin-bottom: 15px; /* Increased spacing */
        }

        #sdmForecastingView label {
            display: block; /* Ensure label is on its own line */
            margin-top: 10px;
            font-weight: bold; /* Make label stand out */
            margin-bottom: 3px; /* Space between label and input */
        }

        #sdmForecastingView input[type="number"] { /* Target number inputs */
            width: 150px; /* Adjust width as needed */
            padding: 8px;
            margin-top: 0; /* Remove default top margin */
            box-sizing: border-box; /* Include padding in width */
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        #sdmForecastingView .help-text {
            font-size: 0.9em;
            color: #555;
            margin-top: 4px; /* Space above help text */
            margin-left: 5px; /* Indent slightly */
        }

        /* Style the info/summary divs if needed */
        #sdmForecastingView .info,
        #sdmForecastingView .summary {
            margin-top: 10px;
            font-weight: bold;
            padding: 10px;
            background-color: #e9ecef;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }

        /* Style tables within the view */
        #sdmForecastingView table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em; /* Slightly smaller font for tables */
        }

        #sdmForecastingView th,
        #sdmForecastingView td {
            border: 1px solid #ccc;
            padding: 6px 8px; /* Adjust padding */
            text-align: center;
        }
        #sdmForecastingView th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        #sdmForecastingView td.editable { /* Keep editable style */
            background-color: #f9f9f9;
            cursor: pointer;
        }

        /* Style the FAQ section */
        #sdmForecastingView .faq-section {
            margin-top: 40px;
            border-top: 1px solid #ccc;
            padding-top: 20px;
        }

        #sdmForecastingView .faq-item {
            margin-bottom: 20px;
        }

        #sdmForecastingView .faq-item h4 {
            margin-bottom: 5px; /* Adjust spacing */
            color: #0056b3;
        }
        #sdmForecastingView .faq-item p,
        #sdmForecastingView .faq-item ul,
        #sdmForecastingView .faq-item ol {
            font-size: 0.95em;
            color: #333;
            margin-left: 15px; /* Indent FAQ content */
        }
        /* --- End SDM Forecasting Tool Styles --- */          

          /* Add any additional styles as needed */          
    </style>
</head>
<body>

<!-- Updated Heading with ID -->
<h1 id="pageTitle">Software Management Tools</h1>
<p id="systemDescription">Load a previously saved system or create a new software system</p>

<!-- Menu for loading systems 
<div class="menu">
    <button onclick="showSavedSystems()">Load Saved System</button>
</div>
-->

<!-- Edit System Button -->
<div class="edit-menu" style="display: none;">
    <button id="editSystemButton" onclick="enterEditMode()">Edit System</button>
    <button id="viewOrgChartButton" onclick="showOrganogramView()">View Org Chart</button>
    <button id="viewEngineerListButton" onclick="showEngineerTableView()">View Engineers in Org</button>
    <button id="manageYearPlanButton" onclick="showPlanningView()">Manage Year Plan</button>
    <button id="tuneCapacityButton" onclick="showCapacityConfigView()">Tune Capacity Constraints</button>
    <button id="sdmForecastButton" onclick="showSdmForecastingView()">SDM Resource Forecasting</button>    
</div>

<!-- Visualization Section -->
<div id="visualizationCarousel" style="position: relative; max-width: 800px; margin: 20px auto; border: 1px solid #ddd; padding: 10px; display:none;"> <div style="text-align: center; margin-bottom: 10px;">
        <button onclick="navigateVisualizations(-1)">&lt; Previous</button>
        <span id="visualizationTitle" style="margin: 0 15px; font-weight: bold; font-size: 1.1em;">System Visualization</span> <button onclick="navigateVisualizations(1)">Next &gt;</button>
    </div>

    <div id="visualization" class="carousel-item" style="display: block;"> <svg id="systemSvg" style="width: 100%; height: 600px; border: 1px solid #ccc;"></svg>
        <div id="legend" class="legend"></div>
    </div>

    <div id="teamVisualization" class="carousel-item" style="display: none;">
        <svg id="teamSvg" style="width: 100%; height: 600px; border: 1px solid #ccc;"></svg>
        <div id="teamLegend" class="legend"></div>
    </div>

    <div id="serviceRelationshipsVisualization" class="carousel-item" style="display: none;">
        <select id="serviceSelection" onchange="updateServiceVisualization()" style="margin-bottom: 5px; display: block; margin-left: auto; margin-right: auto;">
            </select>
        <svg id="serviceSvg" style="width: 100%; height: 600px; border: 1px solid #ccc;"></svg>
        <div id="serviceLegend" class="legend"></div>
    </div>

    <div id="dependencyVisualization" class="carousel-item" style="display: none;">
        <select id="dependencyServiceSelection" onchange="updateDependencyVisualization()" style="margin-bottom: 5px; display: block; margin-left: auto; margin-right: auto;">
            </select>
        <svg id="dependencySvg" style="width: 100%; height: 600px; border: 1px solid #ccc;"></svg>
        <div id="dependencyLegend" class="legend"></div>
    </div>

</div>
<div id="serviceDependenciesTable" style="max-width: 90%; margin: 20px auto; display:none;">
    <h2>Service Dependencies Table</h2>
    <div style="overflow-x: auto;"> <table style="width: 100%; border-collapse: collapse;">
            <thead>
            <tr>
                <th>Service Name</th>
                <th>Description</th>
                <th>Owning Team</th>
                <th>Upstream Dependencies (Services Depended On)</th>
                <th>Platform Dependencies</th>
                <th>Downstream Dependencies (Services That Depend On This Service)</th>
            </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
    </div>
</div>


<!-- System Edit Form -->
<div id="systemEditForm" style="display:none;">
    <h2>Edit System</h2>
    <form id="editSystemForm">
        <label>System Name:</label><br>
        <input type="text" id="systemNameInput"><br><br>
        <label>System Description:</label><br>
        <textarea id="systemDescriptionInput" rows="3" cols="50"></textarea><br><br>
        <button type="button" onclick="saveSystemDetails()">Save System Details</button>
    </form>

    <!-- Services Management Section -->
    <h3>Services</h3>
    <div id="editServicesManagement">
        <!-- Services will be listed here -->
    </div>
    <button type="button" onclick="addNewService()">Add New Service</button><br><br>
    
    <!-- Teams Management Section -->
    <h3>Teams</h3>
    <div id="teamsManagement">
        <!-- Teams will be listed here -->
    </div>
    <button id="addNewTeamButton" type="button" onclick="addNewTeam()">Add New Team</button><br><br>

    <!-- Buttons to Save or Cancel -->
    <button type="button" onclick="saveAllChanges()">Save All Changes</button>
    <button type="button" onclick="exitEditMode()">Cancel</button>
</div>

<!-- Menu for loading systems and creating new systems -->
<div class="menu">
    <button onclick="showSavedSystems()">Load Saved System</button>
    <button onclick="createNewSystem()">Create New System</button>
    <button id="deleteSystemButton" onclick="deleteSystem()">Delete System</button>    
    <button onclick="resetToDefaults()">Reset to Defaults</button>    
</div>

<!-- Return to Home Button -->
<button id="backToSystemViewButton" onclick="showSystemOverview()" style="display: none; margin-right: 10px;">Back to System Overview</button>
<button id="returnHomeButton" onclick="returnToHome()" style="display: none;">Home Page</button>

<!-- added some new views 8th april 25 -->
<div id="organogramView" style="display:none; margin-top: 20px;">
    <div id="organogramToolbar" style="margin-bottom: 10px;">
        </div>
    <div id="organogramContent" style="border: 1px solid #ccc; padding: 15px;">
        </div>

    <!-- Team Breakdown Table -->
    <div id="teamBreakdown" style="margin-top: 30px;">
        <h2>Team Breakdown</h2>
        <p id="levelKey" style="font-size: 0.9em; color: #555; margin-bottom: 10px;"></p> <table id="teamTable">
              <thead>
                  <!-- Headers will be generated by JS -->
              </thead>
              <tbody>
                  <!-- Rows will be generated by JS -->
              </tbody>
              <tfoot>
                  <!-- Totals will be generated by JS -->
              </tfoot>
        </table>
    </div>
</div>

<div id="engineerTableView" style="display:none; margin-top: 20px;">
    <h2 id="engineerTableHeading">Engineer Resource List</h2> <p style="font-size: 0.9em; color: #555;">Click column headers to sort.</p>
    <table id="engineerTable" style="width: 100%; border-collapse: collapse; margin-top: 10px;">
        <thead>
            <tr>
                <th data-sort-key="name" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Engineer Name &#x2195;</th>
                <th data-sort-key="level" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Level &#x2195;</th>
                <th data-sort-key="teamName" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Team Name &#x2195;</th>
                <th data-sort-key="sdmName" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">SDM Name &#x2195;</th>
                <th data-sort-key="srMgrName" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Senior Manager Name &#x2195;</th>
            </tr>
        </thead>
        <tbody>
            </tbody>
    </table>
</div>

<div id="planningView" style="display:none; margin-top: 20px;">
    <div id="planningCapacitySummary" style="margin-bottom: 15px; font-weight: bold;">
        </div>

    <div id="planningScenarioControl" style="margin-bottom: 15px; padding: 8px; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px;">
        </div>

    <div id="teamLoadSummarySection" style="margin-bottom: 20px; border: 1px solid #ccc; border-radius: 4px;">
        <h4 onclick="toggleCollapsibleSection('teamLoadSummaryContent', 'teamLoadSummaryToggle')"
            style="cursor: pointer; margin: 0; padding: 10px; background-color: #e9ecef; border-bottom: 1px solid #ccc;"
            title="Click to expand/collapse team load summary">
            <span id="teamLoadSummaryToggle" class="toggle-indicator">(+) </span> Team Load Summary (for ATL Initiatives)
        </h4>
        <div id="teamLoadSummaryContent" style="display: none; padding: 10px;">
             <p style="font-size: 0.9em; color: #555;">Shows team load based *only* on initiatives currently Above The Line (ATL) according to the selected scenario below.</p>
             <table id="teamLoadSummaryTable" style="margin: 0 auto; border-collapse: collapse; font-size: 0.9em;">
                 <thead>
                     <tr style="background-color: #f2f2f2;">
                         <th style="border: 1px solid #ccc; padding: 5px;">Team Name</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Finance Approved Budget">Funded HC</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Actual Team Members">Team BIS</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Borrowed/Away Members">Away BIS</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Team BIS + Away BIS">Effective BIS</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="SDEs assigned to this team from ATL initiatives only">Assigned ATL SDEs</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Team's capacity based on selected scenario button below">Scenario Capacity Limit</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Scenario Capacity Limit - Assigned ATL SDEs">Remaining Capacity (ATL)</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Load status for ATL work based on Scenario Capacity Limit">ATL Status</th>
                     </tr>
                 </thead>
                 <tbody id="teamLoadSummaryTableBody">
                     </tbody>
                 <tfoot id="teamLoadSummaryTableFoot" style="font-weight: bold;">
                      </tfoot>
             </table>
        </div>
    </div>

    <div id="planningTableContainer">
        </div>
    <div id="addInitiativeSection" style="margin-top: 20px; padding: 15px; border: 1px solid #ccc;">
         <h3 onclick="toggleCollapsibleSection('addInitiativeContent', 'addInitiativeToggle')" title="Click to expand/collapse">
             <span id="addInitiativeToggle" class="toggle-indicator">(+) </span> Add New Initiative
        </h3>
        
        <div id="addInitiativeContent" style="display: none;"> 
          <div style="margin-bottom: 10px;">
              <label for="newInitiativeTitle" style="display: block;">Title:</label>
              <input type="text" id="newInitiativeTitle" placeholder="Initiative Title" style="width: 90%;">
          </div>
          <div style="margin-bottom: 10px;">
              <label for="newInitiativeDescription" style="display: block;">Description:</label>
              <textarea id="newInitiativeDescription" placeholder="Description" rows="2" style="width: 90%;"></textarea>
          </div>
          <div style="margin-bottom: 10px;">
              <label for="newInitiativeGoalId" style="display: block;">Related Business Goal ID (Optional):</label>
              <input type="text" id="newInitiativeGoalId" placeholder="Optional: Business Goal ID" style="width: 90%;">
          </div>
  
          <hr>
          <h4>Team Assignments:</h4>
          <div id="newInitiativeAssignmentsDisplay" style="margin-bottom: 10px; min-height: 30px; background-color: #f8f9fa; padding: 5px; border: 1px solid #eee;">
          </div>
          <div style="display: flex; align-items: center; margin-bottom: 10px;">
               <label for="newInitiativeTeamSelect" style="margin-right: 5px;">Team:</label>
               <select id="newInitiativeTeamSelect" style="margin-right: 10px;">
                   <option value="">-- Select Team --</option>
               </select>
               <label for="newInitiativeSdeYears" style="margin-right: 5px;">SDE Years:</label>
               <input type="number" id="newInitiativeSdeYears" step="0.25" min="0" placeholder="e.g., 1.5" style="width: 80px; margin-right: 10px;">
               <button type="button" id="addTeamAssignmentButton">Add Assignment</button>
          </div>
  
          <hr>
          <button type="button" id="addInitiativeButton" style="padding: 10px 15px; font-size: 16px; background-color: #28a745; color: white; border: none; cursor: pointer;">Add Initiative to Plan</button>
        </div>
    </div>
</div>

<div id="capacityConfigView" style="display:none; margin-top: 20px; max-width: 90%; margin-left: auto; margin-right: auto;"></div>
<div id="sdmForecastingView" style="display:none; margin-top: 20px; max-width: 90%; margin-left: auto; margin-right: auto;"></div>

<script>
/* JavaScript Code */
/* global variables */
/** Define a unique key for local storage **/
const LOCAL_STORAGE_KEY = 'architectureVisualization_systems';
let currentSystemData = null;
let newServiceData = {};
let uniqueEngineers = [];
const Modes = {
    NAVIGATION: 'navigation',
    BROWSING: 'browsing',
    EDITING: 'editing',
    CREATING: 'creating',
    PLANNING: 'planning' 
};
let currentMode = Modes.NAVIGATION;
let planningCapacityScenario = 'effective'; // Default to 'effective'
let currentCapacityScenario = 'EffectiveBIS'; // Default scenario for capacity summary ('TeamBIS', 'EffectiveBIS', 'FundedHC')
let currentChartTeamId = '__ORG_VIEW__'; // To track which team's chart is displayed
let capacityChartInstance = null; // To hold the Chart.js instance
let applyCapacityConstraintsToggle = false; // Default to OFF

// --- Carousel State ---
let currentVisualizationIndex = 0;
const visualizationItems = [
    { id: 'visualization', title: 'System Visualization' },
    { id: 'teamVisualization', title: 'Team Relationships Visualization' },
    { id: 'serviceRelationshipsVisualization', title: 'Service Relationships Visualization' },
    { id: 'dependencyVisualization', title: 'Service Dependency Visualization' }
];
// ----------------------

// ========= SDM Resource Forecasting Tool Code (Lift & Shift - Phase 1) =========

// --- Global variables specific to the SDM Forecasting Tool ---
let totalRampedUpEngineersArray_SDM = [];
let productiveEngineers_SDM = [];
let cumulativeAttritionArray_SDM = [];
let monthlyData_SDM = {};
let totalHeadcountArray_SDM = [];
let forecastChart_SDM = null; // Chart instance for this view

const weekToMonth_SDM = [ // Renamed variable - CORRECTED LENGTH
    1,1,1,1,    // Jan (4 weeks) Weeks 1-4
    2,2,2,2,    // Feb (4 weeks) Weeks 5-8
    3,3,3,3,3,  // Mar (5 weeks) Weeks 9-13
    4,4,4,4,    // Apr (4 weeks) Weeks 14-17
    5,5,5,5,    // May (4 weeks) Weeks 18-21
    6,6,6,6,6,  // Jun (5 weeks) Weeks 22-26
    7,7,7,7,    // Jul (4 weeks) Weeks 27-30
    8,8,8,8,    // Aug (4 weeks) Weeks 31-34
    9,9,9,9,9,  // Sep (5 weeks) Weeks 35-39
    10,10,10,10, // Oct (4 weeks) Weeks 40-43
    11,11,11,11, // Nov (4 weeks) Weeks 44-47
    12,12,12,12,12 // Dec (5 weeks) Weeks 48-52 *** Corrected: Added 5th '12' ***
];

/**
 * NEW Function: Shows the SDM Forecasting View
 */
function showSdmForecastingView() {
    console.log("Switching to SDM Resource Forecasting View...");
    if (!currentSystemData) { // Check if a main system is loaded, although this tool is standalone for now
        alert("Please load a system first (although forecasting is currently standalone).");
        // return; // Or allow proceeding as it's standalone? Let's allow for now.
    }

    switchView('sdmForecastingView', 'forecasting'); // Use switchView for consistency

    // Generate the UI content for the forecasting tool
    generateForecastingUI_SDM();

    // Initial forecast generation on load (optional, or require button click)
    // generateForecast_SDM(); // Uncomment this if you want it to run automatically on view load
}
// Make globally accessible for the button
window.showSdmForecastingView = showSdmForecastingView;

/**
 * NEW Function (Phase 2b): Loads team data into forecast inputs.
 */
 function loadSdmForecastInputsForTeam(teamId) {
    console.log(`Loading forecast inputs for team ID: ${teamId}`);
    const fundedSizeInput = document.getElementById('fundedSize_SDM');
    const currentEngInput = document.getElementById('currentEngineers_SDM');
    // Get references to other inputs to reset them
    const hiringTimeInput = document.getElementById('hiringTime_SDM');
    const rampUpTimeInput = document.getElementById('rampUpTime_SDM');
    const attritionRateInput = document.getElementById('attritionRate_SDM');
    const closeGapWeekInput = document.getElementById('closeGapWeek_SDM');


    if (!fundedSizeInput || !currentEngInput) {
        console.error("Could not find forecast input elements.");
        return;
    }

    if (!teamId) { // No team selected (e.g., "-- Select --")
        fundedSizeInput.value = '';
        currentEngInput.value = '';
        // Reset other manual inputs to defaults
        if(hiringTimeInput) hiringTimeInput.value = 12;
        if(rampUpTimeInput) rampUpTimeInput.value = 10;
        if(attritionRateInput) attritionRateInput.value = 10;
        if(closeGapWeekInput) closeGapWeekInput.value = 26;
        return;
    }

    const team = currentSystemData?.teams?.find(t => t.teamId === teamId);

    if (!team) {
        console.error(`Team data not found for ID: ${teamId}`);
        fundedSizeInput.value = 'Error';
        currentEngInput.value = 'Error';
        return;
    }

    // Populate read-only fields from team data
    fundedSizeInput.value = team.fundedHeadcount ?? 0;
    currentEngInput.value = team.engineers?.length ?? 0; // This is Team BIS

    // TODO (Future): Load saved forecastingParams for this team here
    // For now, reset manual inputs to defaults when team changes
     if(hiringTimeInput) hiringTimeInput.value = 12;
     if(rampUpTimeInput) rampUpTimeInput.value = 10;
     if(attritionRateInput) attritionRateInput.value = 10; // Reset attrition
     if(closeGapWeekInput) closeGapWeekInput.value = 26; // Reset target week


    console.log(`Inputs populated for team: ${team.teamIdentity || teamId}`);
}

/**
 * NEW Function: Clears the output areas of the SDM forecast view.
 */
 function clearSdmForecastOutputs() {
    console.log("Clearing SDM forecast outputs.");
    const hiringInfoDiv = document.getElementById('hiringInfo_SDM');
    const outputSummaryDiv = document.getElementById('outputSummary_SDM');
    const forecastTable = document.getElementById('forecastTable_SDM');
    const monthlySummaryTable = document.getElementById('monthlySummaryTable_SDM');
    const canvas = document.getElementById('forecastChart_SDM');

    if(hiringInfoDiv) hiringInfoDiv.textContent = 'Select a team and click \'Generate Forecast\'.';
    if(outputSummaryDiv) outputSummaryDiv.innerHTML = '';
    if(forecastTable) forecastTable.innerHTML = '<thead><tr><th>Week</th><th>Effective Engineers</th></tr></thead><tbody><tr><td colspan="2">...</td></tr></tbody>';
    if(monthlySummaryTable) monthlySummaryTable.innerHTML = '<thead><tr><th>Month</th><th>Headcount Available</th><th>SDE-Weeks</th><th>SDE-Days</th></tr></thead><tbody><tr><td colspan="4">...</td></tr></tbody>';

    // Destroy existing chart
    if (forecastChart_SDM) {
        forecastChart_SDM.destroy();
        forecastChart_SDM = null;
    }
    // Clear canvas
    if (canvas) {
        const ctx = canvas.getContext('2d');
        if (ctx) {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    }
}

/**
 * REVISED (Fix Button Visibility): Generates the HTML structure for the forecasting tool dynamically.
 * - Adds Team Selection Dropdown.
 * - Makes Funded Size / Current Engineers read-only.
 * - Removes Efficiency Factor input group.
 * - Adds 'onchange' listeners to manual inputs for dynamic updates.
 * - Ensures Generate Forecast button is visible.
 */
 function generateForecastingUI_SDM() {
    console.log("Generating SDM Forecasting UI (Fixing Button Visibility)..."); // Updated log
    const container = document.getElementById('sdmForecastingView');
    if (!container) {
        console.error("SDM Forecasting container #sdmForecastingView not found.");
        return;
    }
    container.innerHTML = ''; // Clear previous content

    // --- Team Selection Dropdown ---
    const teamSelectionDiv = document.createElement('div');
    teamSelectionDiv.style.marginBottom = '20px';
    teamSelectionDiv.style.paddingBottom = '15px';
    teamSelectionDiv.style.borderBottom = '1px solid #ccc';

    const teamLabel = document.createElement('label');
    teamLabel.htmlFor = 'sdmForecastTeamSelect';
    teamLabel.textContent = 'Select Team to Forecast:';
    teamLabel.style.fontWeight = 'bold';
    teamLabel.style.marginRight = '10px';

    const teamSelect = document.createElement('select');
    teamSelect.id = 'sdmForecastTeamSelect';
    teamSelect.style.padding = '5px';
    teamSelect.style.minWidth = '200px';

    teamSelect.appendChild(new Option('-- Select a Team --', ''));
    if (currentSystemData && currentSystemData.teams) {
        currentSystemData.teams.forEach(team => {
            const teamDisplayName = team.teamIdentity || team.teamName || team.teamId;
            teamSelect.appendChild(new Option(teamDisplayName, team.teamId));
        });
    }
    teamSelect.addEventListener('change', (event) => {
        loadSdmForecastInputsForTeam(event.target.value);
        clearSdmForecastOutputs();
    });

    teamSelectionDiv.appendChild(teamLabel);
    teamSelectionDiv.appendChild(teamSelect);
    container.appendChild(teamSelectionDiv);
    // --- End Team Selection ---


    // --- Input Section ---
    const inputSection = document.createElement('div');
    inputSection.className = 'input-section';
    // Use template literals for easier HTML structure definition
    inputSection.innerHTML = `
        <h3>Input Parameters</h3>
        <p style="font-size:0.9em; color:#555;"><i>Select a team above. Funded Size & Current Engineers are read from system data. Changes to other parameters below will automatically update the forecast.</i></p>
        <div class="input-group">
            <label for="fundedSize_SDM">Funded Team Size:</label>
            <input id="fundedSize_SDM" type="number" value="" readonly />
            <div class="help-text">Total number of engineers the budget allows for (from Team data).</div>
        </div>
        <div class="input-group">
            <label for="currentEngineers_SDM">Current Available Engineers (Team BIS):</label>
            <input id="currentEngineers_SDM" type="number" value="" readonly />
            <div class="help-text">Number of engineers currently assigned to this team (from Team data).</div>
        </div>
        <hr style="margin: 15px 0;">
        <div class="input-group">
            <label for="hiringTime_SDM">Average Hiring Time (weeks):</label>
            <input id="hiringTime_SDM" type="number" value="12" />
            <div class="help-text">Est. time from initiating hiring to an engineer's start date.</div>
        </div>
        <div class="input-group">
            <label for="rampUpTime_SDM">Ramp-up Time (weeks):</label>
            <input id="rampUpTime_SDM" type="number" value="10" />
            <div class="help-text">Est. time for new hires to reach full productivity.</div>
        </div>
        <div class="input-group">
            <label for="attritionRate_SDM">Annual Attrition Rate (%):</label>
            <input id="attritionRate_SDM" type="number" value="10" />
            <div class="help-text">Estimated percentage of engineers expected to leave annually for this team.</div>
        </div>
        <div class="input-group">
            <label for="closeGapWeek_SDM">Target Week to Close Funding Gap:</label>
            <input id="closeGapWeek_SDM" type="number" value="26" />
            <div class="help-text">Target week (1-52) to reach the funded team size via hiring.</div>
        </div>
        <button type="button" id="generateForecastBtn_SDM">Generate Forecast</button> `;
    container.appendChild(inputSection);

    // --- Output Section (Remains mostly the same structure) ---
    const outputSection = document.createElement('div');
    outputSection.className = 'output-section';
    outputSection.innerHTML = `
        <h3>Monthly Resource Summary</h3>
        <div class="info" id="hiringInfo_SDM">Select a team to run forecast.</div>
        <canvas id="forecastChart_SDM" style="max-height: 450px; width: 100%;"></canvas>
        <table id="monthlySummaryTable_SDM"><thead><tr><th>Month</th><th>Headcount Available</th><th>SDE-Weeks</th><th>SDE-Days</th></tr></thead><tbody><tr><td colspan="4">...</td></tr></tbody></table>
        <div class="summary" id="outputSummary_SDM"></div>
        <h3>Weekly Resource Plan</h3>
        <table id="forecastTable_SDM"><thead><tr><th>Week</th><th>Effective Engineers</th></tr></thead><tbody><tr><td colspan="2">...</td></tr></tbody></table>
        <div class="faq-section">
             <h3>Frequently Asked Questions (FAQ)</h3>
             <p style="color:orange; font-style:italic;">(Note: FAQ needs updating for integrated capacity calculations)</p>
             </div>
    `;
    container.appendChild(outputSection);

    // *** Attach 'change' event listeners AFTER adding elements to the DOM ***
    const manualInputs = [
        'hiringTime_SDM',
        'rampUpTime_SDM',
        'attritionRate_SDM',
        'closeGapWeek_SDM'
    ];

    manualInputs.forEach(inputId => {
        const inputElement = document.getElementById(inputId);
        if (inputElement) {
            // Remove previous listener before adding again (safety for potential re-renders)
            inputElement.removeEventListener('change', generateForecast_SDM);
            inputElement.addEventListener('change', generateForecast_SDM);
            console.log(`Attached change listener to ${inputId}`);
        } else {
            console.warn(`Could not find input element ${inputId} to attach listener.`);
        }
    });

    // Attach listener to the button
    const generateBtn = document.getElementById('generateForecastBtn_SDM');
    if (generateBtn) {
        // Remove old listener first if needed
        generateBtn.removeEventListener('click', generateForecast_SDM);
        generateBtn.addEventListener('click', generateForecast_SDM); // Use addEventListener for consistency
        console.log("Attached click listener to Generate button.");
    } else {
         console.error("Could not find Generate Forecast button to attach listener.");
    }

    console.log("SDM Forecasting UI generated with dynamic update listeners and visible button.");
}

/**
 * RENAMED & ADAPTED from standalone tool.
 * Phase 2c: Removed reading of deleted inputs (efficiencyFactor, leaveDays, publicHolidays).
 * Passes selectedTeamId to simulation.
 */
 function generateForecast_SDM() {
    console.log("Generating SDM Forecast (Phase 2c)...");

    // --- Get Selected Team ---
    const teamSelect = document.getElementById('sdmForecastTeamSelect');
    const selectedTeamId = teamSelect?.value;
    if (!selectedTeamId) {
        alert("Please select a team to forecast.");
        clearSdmForecastOutputs(); // Clear results if no team selected
        return;
    }
    console.log(`Forecasting for team: ${selectedTeamId}`);
    // --- End Get Selected Team ---

    // --- Retrieve input values using NEW IDs ---
    const fundedSizeInput = document.getElementById('fundedSize_SDM');
    const currentEngineersInput = document.getElementById('currentEngineers_SDM');
    const hiringTimeInput = document.getElementById('hiringTime_SDM');
    const rampUpTimeInput = document.getElementById('rampUpTime_SDM');
    const attritionRateInput = document.getElementById('attritionRate_SDM');
    const closeGapWeekInput = document.getElementById('closeGapWeek_SDM');

    // Get values (handle potential null elements)
    const fundedSize = parseInt(fundedSizeInput?.value || '0');
    const currentEngineers = parseInt(currentEngineersInput?.value || '0'); // Team BIS
    const hiringTime = parseInt(hiringTimeInput?.value || '12');
    const rampUpTime = parseInt(rampUpTimeInput?.value || '10');
    const attritionRate = parseFloat(attritionRateInput?.value || '10') / 100;
    const closeGapWeek = parseInt(closeGapWeekInput?.value || '26');

    // --- REMOVED reading efficiencyFactor, leaveDays, publicHolidays ---

    const hiringInfoDiv = document.getElementById('hiringInfo_SDM');
    const outputSummaryDiv = document.getElementById('outputSummary_SDM');
    const forecastTable = document.getElementById('forecastTable_SDM');
    const monthlySummaryTable = document.getElementById('monthlySummaryTable_SDM');

    // --- Validate required inputs ---
    if (isNaN(fundedSize) || isNaN(currentEngineers) || isNaN(hiringTime) || isNaN(rampUpTime) || isNaN(attritionRate) || isNaN(closeGapWeek)) {
         alert("Please ensure all forecast parameters (Hiring Time, Ramp-up, Attrition, Target Week) have valid numeric values.");
         clearSdmForecastOutputs();
         return;
    }
     // Check if essential capacity config exists
     if (!currentSystemData?.capacityConfiguration?.workingDaysPerYear || currentSystemData.capacityConfiguration.workingDaysPerYear <= 0) {
        alert("Cannot run forecast: 'Standard Working Days Per Year' must be configured in Capacity Constraints and be greater than 0.");
        clearSdmForecastOutputs();
        return;
     }
     if (!currentSystemData?.capacityConfiguration?.leaveTypes) {
         console.warn("Leave types not defined in capacity configuration. Proceeding with defaults (0).");
         // Allow proceeding, but calculations might be off if leave types aren't defined
     }


    // Feasibility Check
    if (closeGapWeek < hiringTime) {
        if(hiringInfoDiv) hiringInfoDiv.innerHTML = `<span style="color:red">Target week (${closeGapWeek}) is earlier than hiring time (${hiringTime} weeks). Cannot reach target.</span>`;
        if(outputSummaryDiv) outputSummaryDiv.innerHTML = `<p>Adjust Hiring Time or Target Week.</p>`;
        if(forecastTable) forecastTable.innerHTML = '';
        if(monthlySummaryTable) monthlySummaryTable.innerHTML = '';
        if (forecastChart_SDM) { forecastChart_SDM.destroy(); forecastChart_SDM = null; }
        return;
    } else {
        if(outputSummaryDiv) outputSummaryDiv.innerHTML = ''; // Clear previous summary/error
    }

    // Calculate required hiring rate using renamed function
    // Pass null for teamId as computeHiringRate just needs the headcount simulation part
    const hiringRate = computeHiringRate_SDM(fundedSize, currentEngineers, hiringTime, rampUpTime, attritionRate, closeGapWeek);

    if(hiringInfoDiv) hiringInfoDiv.innerHTML = `Required Hiring Rate: <span style="color:blue">${hiringRate.toFixed(2)} engineers/week</span> to reach funded team size by week ${closeGapWeek}.`;

    // Initialize weeks array
    let weeks = [...Array(52).keys()].map(i => i + 1);

    // --- Simulate team size over time using renamed function ---
    // *** Pass selectedTeamId for actual forecast run ***
    const simulationResult = simulateTeamSize_SDM(
        hiringRate, fundedSize, currentEngineers, hiringTime, rampUpTime, attritionRate,
        selectedTeamId // Pass actual teamId for capacity lookup
        // capAtFundedSize defaults to true
    );
    // *** --------------------------------------------- ***

    // Check if simulation returned valid results
     if (!simulationResult) {
         alert("An error occurred during the forecast simulation. Please check the console.");
         clearSdmForecastOutputs();
         if(hiringInfoDiv) hiringInfoDiv.textContent = "Simulation Error.";
         return;
     }

    // Update global variables (renamed versions)
    productiveEngineers_SDM = simulationResult.productiveEngineers;
    totalRampedUpEngineersArray_SDM = simulationResult.totalRampedUpEngineersArray;
    cumulativeAttritionArray_SDM = simulationResult.cumulativeAttritionArray;
    monthlyData_SDM = simulationResult.monthlyData;
    totalHeadcountArray_SDM = simulationResult.totalHeadcountArray;

    // Generate tables and charts using renamed functions
    generateWeeklyTable_SDM(weeks, productiveEngineers_SDM);
    generateMonthlySummary_SDM(monthlyData_SDM); // This now also attaches listeners
    generateChart_SDM(weeks, simulationResult, fundedSize);

    // Generate output summary using renamed function
    // Pass simulationResult to access calculated net days for the summary text
    generateOutputSummary_SDM(hiringRate, closeGapWeek, selectedTeamId, simulationResult);
}

/**
 * RENAMED & ADAPTED from standalone tool.
 * Phase 2c: Calls simulateTeamSize_SDM with null teamId, as only headcount matters here.
 */
 function computeHiringRate_SDM(fundedSize, currentEngineers, hiringTime, rampUpTime, attritionRate, closeGapWeek) {
    console.log("Computing SDM hiring rate...");
    let lowerBound = 0;
    let upperBound = 20; // Max plausible rate
    let tolerance = 0.01;
    let hiringRate = 0;
    let iterations = 0;

    while ((upperBound - lowerBound) > tolerance && iterations < 1000) {
        hiringRate = (upperBound + lowerBound) / 2;

        // Call the simulation function WITHOUT a teamId (or null)
        // It will use default capacity assumptions (e.g., 5 days/week) internally
        const simulationResult = simulateTeamSize_SDM(
            hiringRate, fundedSize, currentEngineers, hiringTime, rampUpTime, attritionRate,
            null // Pass null for selectedTeamId
        );

        // *** Check if simulationResult is valid before accessing properties ***
        if (!simulationResult || !simulationResult.totalHeadcountArray) {
             console.error("Error: Simulation failed during hiring rate computation. Cannot proceed.");
              // Handle error appropriately - maybe return a default rate or throw an error?
              // Returning 0 might be safest for now, but indicates a problem.
              return 0;
         }
        // *** End Check ***

        const totalHeadcountAtTargetWeek = simulationResult.totalHeadcountArray[closeGapWeek - 1];

        if (totalHeadcountAtTargetWeek === undefined) {
             console.error(`Error: Headcount for target week ${closeGapWeek} is undefined in simulation results during rate computation.`);
             return 0; // Indicate error
        }

        if (totalHeadcountAtTargetWeek >= fundedSize) {
            upperBound = hiringRate;
        } else {
            lowerBound = hiringRate;
        }
        iterations++;
    }
     if (iterations >= 1000) {
        console.warn("computeHiringRate_SDM reached max iterations.");
    }
    // Return the upper bound as it's the lowest rate that achieves the target
    console.log(`Computed hiring rate: ${upperBound.toFixed(2)} after ${iterations} iterations.`);
    return upperBound; // Return upperBound for potentially closer result
}

/**
 * RENAMED & ADAPTED from standalone tool.
 * Phase 2c: Implements Option B for Capacity/Efficiency.
 * - selectedTeamId is now optional.
 * - Calculates netAvailableDaysPerWeekPerSDE based on Capacity Config data IF teamId is provided.
 * - Uses netAvailableDaysPerWeekPerSDE to calculate effectiveEngineers.
 * - Uses default capacity assumptions if teamId is null (for computeHiringRate call).
 */
 function simulateTeamSize_SDM(
    hiringRate, fundedSize, currentEngineers, hiringTime, rampUpTime, attritionRate,
    selectedTeamId = null, // Optional parameter
    capAtFundedSize = true
) {
    console.log(`Simulating SDM team size... Team ID: ${selectedTeamId || 'None (Rate Calc)'}`);

    let netAvailableDaysPerWeekPerSDE = 5.0; // Default assumption (5 working days)
    let teamNameForLog = "Rate Calculation";

    // --- If a specific team is provided, calculate its detailed capacity ---
    if (selectedTeamId) {
        const team = currentSystemData?.teams?.find(t => t.teamId === selectedTeamId);
        const capacityConfig = currentSystemData?.capacityConfiguration;

        if (!team) {
            console.error(`Simulation error: Team not found for ID: ${selectedTeamId}`);
            // Return null to indicate failure, handled by caller
            return null;
        }
         teamNameForLog = team.teamIdentity || team.teamName || teamId;

        if (!capacityConfig || !capacityConfig.workingDaysPerYear || capacityConfig.workingDaysPerYear <= 0) {
            console.error("Simulation error: Invalid 'workingDaysPerYear' in capacity configuration.");
            alert("Error: 'Standard Working Days Per Year' must be configured in Capacity Constraints and be greater than 0.");
            return null;
        }

        // --- Calculate Net Available Days per Week per SDE using helpers ---
        const workingDaysPerYear = capacityConfig.workingDaysPerYear;
        const globalLeaveTypes = capacityConfig.leaveTypes || [];

        const stdLeave_days_per_sde = calculateTotalStandardLeaveDaysPerSDE(team, globalLeaveTypes, capacityConfig);
        const holidays_days_per_sde = capacityConfig.globalConstraints?.publicHolidays || 0;
        const orgEvents_days_per_sde = calculateOrgEventDaysPerSDE(capacityConfig);
        const overhead_days_per_sde = calculateOverheadDaysPerSDE(team, workingDaysPerYear);
        const teamActivityImpacts = calculateTeamActivityImpacts(team);
        const teamActivity_days_per_sde = teamActivityImpacts.daysPerSDE;

        const totalPerSdeDeductionDays = stdLeave_days_per_sde + holidays_days_per_sde + orgEvents_days_per_sde + overhead_days_per_sde + teamActivity_days_per_sde;
        const netProjectDaysPerSdePerYear = Math.max(0, workingDaysPerYear - totalPerSdeDeductionDays);
        netAvailableDaysPerWeekPerSDE = (netProjectDaysPerSdePerYear / workingDaysPerYear) * 5;

        console.log(`  Calculating capacity for Team: ${teamNameForLog}`);
        console.log(`    Working Days/Year: ${workingDaysPerYear}`);
        console.log(`    Total Per-SDE Deduction Days/Year: ${totalPerSdeDeductionDays.toFixed(1)}`);
        console.log(`    Net Project Days/SDE/Year: ${netProjectDaysPerSdePerYear.toFixed(1)}`);
        console.log(`    Net Available Days/Week/SDE: ${netAvailableDaysPerWeekPerSDE.toFixed(2)}`);
        // --- End Net Available Days Calculation ---
    } else {
         console.log("  Running simulation for rate calculation (using default 5 available days/week).");
    }


    // --- Simulation Initialization ---
    let productiveEngineersLocal = [];
    let totalRampedUpEngineersArrayLocal = [];
    let cumulativeAttritionArrayLocal = [];
    let totalHeadcountArrayLocal = [];
    let monthlyDataLocal = { headcount: [], sdeWeeks: [], sdeDays: [] };

    let weeks = 52;
    let totalRampedUpEngineers = currentEngineers;
    let totalHeadcount = currentEngineers; // Start with Team BIS
    let hiringPipeline = [];
    let rampingEngineers = [];
    let cumulativeAttrition = 0;
    let attritionCounter = 0;
    const weeklyAttritionRate = attritionRate / 52;
    // --- End Initialization ---

    // --- Weekly Simulation Loop ---
    for (let week = 1; week <= weeks; week++) {
        // Attrition (based on total headcount)
        attritionCounter += totalHeadcount * weeklyAttritionRate;
        let attritionThisWeek = Math.floor(attritionCounter);
        attritionCounter -= attritionThisWeek;

        if (attritionThisWeek > 0) {
             totalHeadcount -= attritionThisWeek;
             let preAttritionHC = totalHeadcount + attritionThisWeek; // Headcount before this week's attrition
             let rampedProportion = (preAttritionHC > 0) ? totalRampedUpEngineers / preAttritionHC : 0;
             let attritionFromRamped = Math.round(attritionThisWeek * rampedProportion);
             let attritionFromRamping = attritionThisWeek - attritionFromRamped;

             totalRampedUpEngineers -= attritionFromRamped;

             // Remove from ramping pipeline
             let removedFromRamping = 0;
             for (let i = rampingEngineers.length - 1; i >= 0 && removedFromRamping < attritionFromRamping; i--) {
                 let removable = Math.min(rampingEngineers[i].count, attritionFromRamping - removedFromRamping);
                 rampingEngineers[i].count -= removable;
                 removedFromRamping += removable;
                 if (rampingEngineers[i].count <= 0) {
                     rampingEngineers.splice(i, 1);
                 }
             }
             cumulativeAttrition += attritionThisWeek;
        }

        // Ensure non-negative counts
        totalRampedUpEngineers = Math.max(0, totalRampedUpEngineers);
        totalHeadcount = Math.max(0, totalHeadcount);

        // Hiring (target fundedSize)
        let totalFutureHeadcount = totalHeadcount + hiringPipeline.reduce((sum, h) => sum + h.count, 0);
        if (totalFutureHeadcount < fundedSize) {
            let hiringNeeded = fundedSize - totalFutureHeadcount;
            let actualHiring = Math.min(hiringRate, hiringNeeded);
             if (actualHiring > 0) {
                hiringPipeline.push({ weeksLeft: hiringTime, count: actualHiring });
            }
        }

        // Advance hiring pipeline -> Ramping
        for (let i = hiringPipeline.length - 1; i >= 0; i--) {
            hiringPipeline[i].weeksLeft--;
            if (hiringPipeline[i].weeksLeft <= 0) {
                 totalHeadcount += hiringPipeline[i].count;
                 rampingEngineers.push({ weeksLeft: rampUpTime, count: hiringPipeline[i].count });
                 hiringPipeline.splice(i, 1);
             }
        }

        // Advance ramp-up pipeline -> Ramped Up
        for (let i = rampingEngineers.length - 1; i >= 0; i--) {
            rampingEngineers[i].weeksLeft--;
            if (rampingEngineers[i].weeksLeft <= 0) {
                totalRampedUpEngineers += rampingEngineers[i].count;
                rampingEngineers.splice(i, 1);
            }
        }

        // Cap total headcount at funded size if required
        if (capAtFundedSize) {
             let overflow = totalHeadcount - fundedSize;
             if (overflow > 0) {
                 totalHeadcount = fundedSize;
                 totalRampedUpEngineers = Math.min(totalRampedUpEngineers, totalHeadcount);
             }
        }

        // *** Calculate effective engineers using NET available days ***
        // Convert net days/week (out of 5) to a weekly multiplier
        const weeklyAvailabilityMultiplier = netAvailableDaysPerWeekPerSDE / 5;
        const effectiveEngineers = totalRampedUpEngineers * weeklyAvailabilityMultiplier;
        // *** ---------------------------------------------------- ***

        // Store weekly results
        productiveEngineersLocal.push(effectiveEngineers);
        totalRampedUpEngineersArrayLocal.push(totalRampedUpEngineers);
        totalHeadcountArrayLocal.push(totalHeadcount);
        cumulativeAttritionArrayLocal.push(cumulativeAttrition);

        // Aggregate monthly data
        const weekArrayIndex = week - 1;
        if (weekArrayIndex >= 0 && weekArrayIndex < weekToMonth_SDM.length) {
            const monthNumber = weekToMonth_SDM[weekArrayIndex];
            if (typeof monthNumber === 'number' && monthNumber >= 1 && monthNumber <= 12) {
                let monthIndex = monthNumber - 1;
                if (monthlyDataLocal.headcount[monthIndex] === undefined) {
                    monthlyDataLocal.headcount[monthIndex] = 0;
                    monthlyDataLocal.sdeWeeks[monthIndex] = 0;
                    monthlyDataLocal.sdeDays[monthIndex] = 0;
                }
                monthlyDataLocal.headcount[monthIndex] = totalHeadcount;
                monthlyDataLocal.sdeWeeks[monthIndex] += effectiveEngineers; // Sum of effective SDEs each week
                // SDE-Days = Sum over weeks of (Effective SDEs that week * Net available days for that week)
                monthlyDataLocal.sdeDays[monthIndex] += effectiveEngineers * netAvailableDaysPerWeekPerSDE; // Uses the calculated net days
            } else {
                 console.warn(`Invalid month number ${monthNumber} derived for week ${week}`);
            }
        } else {
             console.warn(`Invalid week array index ${weekArrayIndex} calculated for week ${week}`);
        }

    } // End weekly loop

    // Final formatting for monthly data
    for (let i = 0; i < 12; i++) {
        monthlyDataLocal.headcount[i] = Math.round(monthlyDataLocal.headcount[i] || 0);
        monthlyDataLocal.sdeDays[i] = parseFloat((monthlyDataLocal.sdeDays[i] || 0).toFixed(2));
        monthlyDataLocal.sdeWeeks[i] = parseFloat((monthlyDataLocal.sdeWeeks[i] || 0).toFixed(2));
    }

    console.log("SDM Simulation complete.");
    return {
        productiveEngineers: productiveEngineersLocal,
        totalRampedUpEngineersArray: totalRampedUpEngineersArrayLocal,
        totalHeadcountArray: totalHeadcountArrayLocal,
        cumulativeAttritionArray: cumulativeAttritionArrayLocal,
        monthlyData: monthlyDataLocal,
        // Pass back the calculated net days for the summary
        calculatedNetAvailableDaysPerWeek: netAvailableDaysPerWeekPerSDE
    };
}

/**
 * RENAMED & ADAPTED from standalone tool.
 */
function generateWeeklyTable_SDM(weeks, productiveEngineers) {
    const table = document.getElementById('forecastTable_SDM');
    if (!table) { console.error("Weekly forecast table #forecastTable_SDM not found."); return; }
    let tableHTML = '<thead><tr><th>Week</th><th>Effective Engineers</th></tr></thead><tbody>'; // Added thead/tbody
    for (let i = 0; i < weeks.length; i++) {
        tableHTML += `<tr><td>${weeks[i]}</td><td>${(productiveEngineers[i] || 0).toFixed(2)}</td></tr>`;
    }
    tableHTML += '</tbody>';
    table.innerHTML = tableHTML;
}

/**
 * RENAMED & ADAPTED from standalone tool. Attaches listeners dynamically.
 */
function generateMonthlySummary_SDM(monthlyData) {
    const table = document.getElementById('monthlySummaryTable_SDM');
     if (!table) { console.error("Monthly summary table #monthlySummaryTable_SDM not found."); return; }
    let monthlyTableHTML = '<thead><tr><th>Month</th><th>Headcount Available</th><th>SDE-Weeks</th><th>SDE-Days</th></tr></thead><tbody>';
    for (let i = 0; i < 12; i++) {
        monthlyTableHTML += `<tr>
            <td>${i + 1}</td>
            <td contenteditable="true" class="editable sdm-editable-cell" data-month-index="${i}">${Math.round(monthlyData.headcount[i] || 0)}</td>
            <td>${(monthlyData.sdeWeeks[i] || 0).toFixed(2)}</td>
            <td>${(monthlyData.sdeDays[i] || 0).toFixed(2)}</td>
        </tr>`;
    }
    monthlyTableHTML += '</tbody>';
    table.innerHTML = monthlyTableHTML;

    // Add event listeners AFTER generating the table
    const editableCells = table.querySelectorAll('td.sdm-editable-cell');
    editableCells.forEach(cell => {
        // Remove existing listener first to prevent duplicates if called multiple times
        cell.removeEventListener('input', handleMonthlyHeadcountInput_SDM);
        // Add the new listener
        cell.addEventListener('input', handleMonthlyHeadcountInput_SDM);
    });
}
// NEW Listener function specific to SDM tool's editable cells
function handleMonthlyHeadcountInput_SDM(event) {
    const cell = event.target;
    const monthIndex = parseInt(cell.getAttribute('data-month-index'));
    const newValue = parseInt(cell.textContent);
    if (!isNaN(newValue) && monthIndex >= 0) {
        // Call the specific update function for this tool
        updateMonthlyHeadcount_SDM(monthIndex, newValue);
    } else {
         // Optional: Add validation feedback or revert
         console.warn("Invalid input for monthly headcount:", cell.textContent);
         // Revert? Might be complex. For now, just don't update.
    }
}

/**
 * RENAMED & ADAPTED from standalone tool.
 * Phase 2c: Updated summary text to reflect integrated capacity calculation (Option B).
 */
 function generateOutputSummary_SDM(hiringRate, closeGapWeek, selectedTeamId, simulationResult) { // Added teamId & simResult
     const summaryDiv = document.getElementById('outputSummary_SDM');
     if (!summaryDiv) { console.error("Output summary div #outputSummary_SDM not found."); return; }

     const team = currentSystemData?.teams?.find(t => t.teamId === selectedTeamId);
     const teamName = team ? (team.teamIdentity || team.teamName) : 'the selected team';

     // Get current input values using NEW IDs
     const hiringTime = document.getElementById('hiringTime_SDM')?.value || 'N/A';
     const rampUpTime = document.getElementById('rampUpTime_SDM')?.value || 'N/A';
     const attritionRate = document.getElementById('attritionRate_SDM')?.value || 'N/A';

     // Get the calculated net available days from the simulation result
     const netAvailableDays = simulationResult?.calculatedNetAvailableDaysPerWeek?.toFixed(2) || 'N/A';
     let netDaysInfo = "";
     if (netAvailableDays !== 'N/A') {
          netDaysInfo = `Based on the Capacity Configuration data for <strong>${teamName}</strong> (including leave, holidays, overhead, etc.), the calculated average net available days per SDE per week is approx. <strong>${netAvailableDays}</strong> (out of 5).`;
     } else {
          netDaysInfo = "Could not retrieve detailed capacity configuration; using default assumptions.";
     }

    const summary = `
        <p>For team <strong>${teamName}</strong>, to reach the funded team size by week ${closeGapWeek}, the required hiring rate is approx. <strong>${hiringRate.toFixed(2)}</strong> engineers per week.</p>
        <p>This forecast considers:</p>
        <ul>
            <li>Avg. Hiring Time: ${hiringTime} weeks</li>
            <li>Avg. Ramp-up Time: ${rampUpTime} weeks</li>
            <li>Annual Attrition Rate: ${attritionRate}%</li>
        </ul>
        <p>The 'Effective Engineers' shown reflect the ramped-up engineers adjusted for their actual productive time. ${netDaysInfo}</p>
        <p><i>Note: Manual forecast parameters (hiring time, ramp-up, attrition) are not currently saved per team.</i></p>
        `;
    summaryDiv.innerHTML = summary;
}

/**
 * RENAMED & ADAPTED from standalone tool.
 */
function updateMonthlyHeadcount_SDM(monthIndex, newHeadcount) {
    console.log(`Manual update for Month ${monthIndex + 1} to Headcount: ${newHeadcount}`);
    // Update totalHeadcountArray_SDM and recalculate derived arrays
    const fundedSize = parseInt(document.getElementById('fundedSize_SDM').value);
    const efficiencyFactor = parseFloat(document.getElementById('efficiencyFactor_SDM').value) / 100;
    const leaveDays = parseInt(document.getElementById('leaveDays_SDM').value);
    const publicHolidays = parseInt(document.getElementById('publicHolidays_SDM').value);

    // --- Phase 1: Simple update, assumes manually edited headcount are all ramped ---
    // TODO (Phase 2): Revisit this logic. Manual edits might conflict with simulation.
    //                  Perhaps disable manual edits or make simulation more flexible.
    const weeklyLeaveDaysPerEngineer = leaveDays / 52;
    const weeklyPublicHolidaysPerEngineer = publicHolidays / 52;
    const weeklyAvailableDaysPerEngineer = Math.max(0, 5 - weeklyLeaveDaysPerEngineer - weeklyPublicHolidaysPerEngineer);

    let weekStartIndex = -1, weekEndIndex = -1;
    for(let i=0; i < weekToMonth_SDM.length; i++){
        if(weekToMonth_SDM[i] === monthIndex + 1){
            if(weekStartIndex === -1) weekStartIndex = i;
            weekEndIndex = i;
        }
    }

    if(weekStartIndex === -1) { console.error("Could not find weeks for month index:", monthIndex); return;}

    // Update arrays for the relevant weeks
    for (let weekIndex = weekStartIndex; weekIndex <= weekEndIndex; weekIndex++) {
        if (weekIndex < totalHeadcountArray_SDM.length) {
            totalHeadcountArray_SDM[weekIndex] = newHeadcount;
            // Simplistic assumption for Phase 1: If headcount is manually set, assume they are ramped.
            totalRampedUpEngineersArray_SDM[weekIndex] = newHeadcount;
            // Recalculate effective engineers based on the new ramped-up count
            const effectiveEngineers = totalRampedUpEngineersArray_SDM[weekIndex] * efficiencyFactor * (weeklyAvailableDaysPerEngineer / 5);
            if (weekIndex < productiveEngineers_SDM.length) {
                productiveEngineers_SDM[weekIndex] = effectiveEngineers;
            }
        }
    }

    // Recalculate monthlyData for the affected month
    monthlyData_SDM.headcount[monthIndex] = newHeadcount;
    monthlyData_SDM.sdeWeeks[monthIndex] = 0;
    monthlyData_SDM.sdeDays[monthIndex] = 0;
    for (let weekIndex = weekStartIndex; weekIndex <= weekEndIndex; weekIndex++) {
         if (weekIndex < productiveEngineers_SDM.length) {
            monthlyData_SDM.sdeWeeks[monthIndex] += productiveEngineers_SDM[weekIndex];
            monthlyData_SDM.sdeDays[monthIndex] += productiveEngineers_SDM[weekIndex] * weeklyAvailableDaysPerEngineer;
         }
    }
     monthlyData_SDM.headcount[monthIndex] = Math.round(monthlyData_SDM.headcount[monthIndex] || 0);
     monthlyData_SDM.sdeDays[monthIndex] = parseFloat((monthlyData_SDM.sdeDays[monthIndex] || 0).toFixed(2));
     monthlyData_SDM.sdeWeeks[monthIndex] = parseFloat((monthlyData_SDM.sdeWeeks[monthIndex] || 0).toFixed(2));


    // Refresh display elements
    generateWeeklyTable_SDM([...Array(52).keys()].map(i => i + 1), productiveEngineers_SDM);
    // Need to regenerate the monthly summary to update the specific cell and recalculate SDE days/weeks
    generateMonthlySummary_SDM(monthlyData_SDM);
    generateChart_SDM([...Array(52).keys()].map(i => i + 1), {
        productiveEngineers: productiveEngineers_SDM,
        totalRampedUpEngineersArray: totalRampedUpEngineersArray_SDM,
        totalHeadcountArray: totalHeadcountArray_SDM,
        cumulativeAttritionArray: cumulativeAttritionArray_SDM // Pass existing attrition
    }, fundedSize);
    console.log("Updated forecast after manual headcount change.");
}

/**
 * RENAMED & ADAPTED from standalone tool. Uses new chart ID and variable names.
 */
function generateChart_SDM(weeks, simulationResult, fundedSize) {
    console.log("Generating SDM Forecast Chart...");
    // Destroy existing chart instance if it exists
    if (forecastChart_SDM) {
        forecastChart_SDM.destroy();
        forecastChart_SDM = null;
        console.log("Destroyed previous SDM forecast chart instance.");
    }

    const canvas = document.getElementById('forecastChart_SDM');
    if (!canvas) {
        console.error("Canvas element #forecastChart_SDM not found.");
        return; // Cannot generate chart without canvas
    }
    const ctx = canvas.getContext('2d');
    if (!ctx) {
         console.error("Failed to get 2D context for SDM forecast chart canvas.");
         return;
    }

    forecastChart_SDM = new Chart(ctx, {
        type: 'line',
        data: {
            labels: weeks,
            datasets: [
                {
                    label: 'Effective Engineers',
                    data: simulationResult.productiveEngineers,
                    borderColor: 'blue', fill: false, yAxisID: 'y', tension: 0.1
                },
                {
                    label: 'Total Ramped Up Engineers',
                    data: simulationResult.totalRampedUpEngineersArray,
                    borderColor: 'green', fill: false, yAxisID: 'y', tension: 0.1
                },
                {
                    label: 'Total Headcount',
                    data: simulationResult.totalHeadcountArray,
                    borderColor: 'purple', fill: false, yAxisID: 'y', tension: 0.1
                },
                {
                    label: 'Cumulative Attrition',
                    data: simulationResult.cumulativeAttritionArray,
                    borderColor: 'orange', fill: false, yAxisID: 'y1', tension: 0.1
                },
                {
                    label: 'Funded Team Size',
                    data: weeks.map(() => fundedSize),
                    borderColor: 'red', borderDash: [5, 5], fill: false, yAxisID: 'y', tension: 0.1
                },
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false, // Allow chart to resize vertically
            interaction: { mode: 'index', intersect: false, },
            stacked: false,
            scales: {
                x: { display: true, title: { display: true, text: 'Week' } },
                y: { // Primary Y-axis for Engineers/Headcount
                    type: 'linear', display: true, position: 'left',
                    beginAtZero: true,
                    title: { display: true, text: 'Engineers' },
                },
                y1: { // Secondary Y-axis for Attrition
                    type: 'linear', display: true, position: 'right',
                    grid: { drawOnChartArea: false, }, // only want the grid lines for the primary axis
                    beginAtZero: true,
                    title: { display: true, text: 'Cumulative Attrition' },
                }
            }
        }
    });
    console.log("SDM Forecast Chart generated.");
}

// ========= END SDM Resource Forecasting Tool Code =========



/** Sample Data for StreamView **/

/** Define Senior Managers for StreamView **/
const sampleSeniorManagersDataStreamView = [
    { seniorManagerId: 'srMgr1', seniorManagerName: 'Director Dave' },
    { seniorManagerId: 'srMgr2', seniorManagerName: 'VP Victoria' }
];

/** Updated SDMs Data for StreamView (with seniorManagerId) **/
const sampleSDMsDataStreamView = [
    { sdmId: 'sdm1', sdmName: 'Alice Johnson', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm2', sdmName: 'Emily Clark', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm3', sdmName: 'Carol Davis', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm4', sdmName: 'Grace Lee', seniorManagerId: 'srMgr2' },
    { sdmId: 'sdm5', sdmName: 'Ian Turner', seniorManagerId: 'srMgr2' },
    { sdmId: 'sdm6', sdmName: 'Karen Adams', seniorManagerId: 'srMgr2' },
    { sdmId: 'sdm7', sdmName: 'Natalie Green', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm8', sdmName: 'Zoe King', seniorManagerId: 'srMgr2' }
];

/** Updated Teams Data for StreamView (with fundedHeadcount, buildersInSeats, engineers array) **/
const sampleTeamsDataStreamView = [
    {
        teamId: 'team1',
        teamName: 'User Experience Team',
        teamIdentity: 'Avengers',
        fundedHeadcount: 7,
        buildersInSeats: 5,
        engineers: [
            { name: 'Alice Johnson', level: 4 },
            { name: 'Mark Evans', level: 3 },
            { name: 'Sophia Lee', level: 3 },
            { name: 'John Doe', level: 2 },
            { name: 'Emma Davis', level: 1 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm1',
        pmtId: 'pmt1',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            
        }
    },
    {
        teamId: 'team2',
        teamName: 'Streaming Team',
        teamIdentity: 'Spartans',
        fundedHeadcount: 5,
        buildersInSeats: 4,
        engineers: [
            { name: 'Emily Clark', level: 5 },
            { name: 'Daniel Thompson', level: 3 },
            { name: 'Olivia Brown', level: 2 },
            { name: 'Liam Wilson', level: 2 }
        ],
        awayTeamMembers: [
            { name: 'Borrowed Betty', level: 3, sourceTeam: 'External Partner X' }
        ], // Example away team member
        sdmId: 'sdm2',
        pmtId: 'pmt2',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }

    },
    {
        teamId: 'team3',
        teamName: 'Content Team',
        teamIdentity: 'Crusaders',
        fundedHeadcount: 4,
        buildersInSeats: 3,
        engineers: [
            { name: 'Carol Davis', level: 4 },
            { name: 'Kevin Moore', level: 2 },
            { name: 'Isabella Martinez', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm3',
        pmtId: 'pmt2',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }

    },
    {
        teamId: 'team4',
        teamName: 'Recommendation Team',
        teamIdentity: 'Olympus',
        fundedHeadcount: 6,
        buildersInSeats: 4,
        engineers: [
            { name: 'Grace Lee', level: 4 },
            { name: 'Ethan Harris', level: 3 },
            { name: 'Mia Turner', level: 2 },
            { name: 'Noah Walker', level: 1 }
        ],
        awayTeamMembers: [
            { name: 'Loaned Larry', level: 4, sourceTeam: 'Core Platform BU' },
            { name: 'Visiting Vinny', level: 2, sourceTeam: 'Data Science Org' }
        ], // Example away team members
        sdmId: 'sdm4',
        pmtId: 'pmt3',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }

    },
    {
        teamId: 'team5',
        teamName: 'Finance Team',
        teamIdentity: 'Falcons',
        fundedHeadcount: 4,
        buildersInSeats: 3,
        engineers: [
            { name: 'Ian Turner', level: 5 },
            { name: 'Charlotte Adams', level: 3 },
            { name: 'Benjamin Scott', level: 3 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm5',
        pmtId: 'pmt3',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }

    },
    {
        teamId: 'team6',
        teamName: 'Communication Team',
        teamIdentity: 'Ninjas',
        fundedHeadcount: 3,
        buildersInSeats: 2,
        engineers: [
            { name: 'Karen Adams', level: 3 },
            { name: 'Lucas Wright', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm6',
        pmtId: 'pmt2',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }

    },
    {
        teamId: 'team7',
        teamName: 'Analytics Team',
        teamIdentity: 'Dragons',
        fundedHeadcount: 5,
        buildersInSeats: 3,
        engineers: [
            { name: 'Natalie Green', level: 4 },
            { name: 'Andrew Hall', level: 3 },
            { name: 'Ella Young', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm7',
        pmtId: 'pmt4',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }

    },
    {
        teamId: 'team8',
        teamName: 'Search Team',
        teamIdentity: 'Search',
        fundedHeadcount: 3,
        buildersInSeats: 2,
        engineers: [
            { name: 'Zoe King', level: 3 },
            { name: 'Michael Baker', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm8',
        pmtId: 'pmt1',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }

    }
];

const samplePMTsDataStreamView = [
    { pmtId: 'pmt1', pmtName: 'Bob Smith' },
    { pmtId: 'pmt2', pmtName: 'Frank Thompson' },
    { pmtId: 'pmt3', pmtName: 'Jane Parker' },
    { pmtId: 'pmt4', pmtName: 'Owen Clark' }
];

//Service Name
//Upstreams: List of services the current service depends on.
//Downstreams: List of services that depend on the current service.
//Platform Dependencies: List of platforms the current service depends on.
//Upstreams: For a given service, upstreams are the services listed in its serviceDependencies.
//Downstreams: For a given service, downstreams are the services that include its name in their serviceDependencies.	

const sampleServicesDataStreamView = [
    {
      serviceName: 'User Management Service',
      serviceDescription: 'Handles user registration, authentication, profiles, and account settings.',
      owningTeamId: 'team1',
      apis: [
          {
              apiName: 'Register API',
              apiDescription: 'Allows new users to sign up.',
              dependentApis: []
          },
          {
              apiName: 'Login API',
              apiDescription: 'Authenticates users and starts a session.',
              dependentApis: []
          },
          {
              apiName: 'Profile API',
              apiDescription: 'Manages user profiles and account settings.',
              dependentApis: []
          },
          {
              apiName: 'Logout API',
              apiDescription: 'Ends the user session.',
              dependentApis: []
          }
      ],
      serviceDependencies: [],
      platformDependencies: ['Auth0', 'AWS DynamoDB']
  },
  {
      serviceName: 'Content Delivery Service',
      serviceDescription: 'Manages content streaming and delivery to users.',
      owningTeamId: 'team2',
      apis: [
          {
              apiName: 'Stream Content API',
              apiDescription: 'Streams selected content to the user.',
              dependentApis: ['Subscription API', 'Profile API']
          },
          {
              apiName: 'Adaptive Bitrate API',
              apiDescription: 'Adjusts streaming quality based on network conditions.',
              dependentApis: []
          },
          {
              apiName: 'Content Caching API',
              apiDescription: 'Manages caching of frequently accessed content.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['Content Management Service', 'User Management Service', 'Billing and Subscription Service'],
      platformDependencies: ['AWS CloudFront', 'AWS S3']
  },
  {
      serviceName: 'Content Management Service',
      serviceDescription: 'Handles content ingestion, metadata, and catalog management.',
      owningTeamId: 'team3',
      apis: [
          {
              apiName: 'Content Ingestion API',
              apiDescription: 'Ingests new content into the platform.',
              dependentApis: []
          },
          {
              apiName: 'Metadata API',
              apiDescription: 'Manages content metadata like titles, descriptions, genres.',
              dependentApis: []
          },
          {
              apiName: 'Catalog API',
              apiDescription: 'Provides the catalog of available content.',
              dependentApis: []
          }
      ],
      serviceDependencies: [],
      platformDependencies: ['AWS S3', 'AWS Lambda']
  },
  {
      serviceName: 'Recommendation Engine Service',
      serviceDescription: 'Provides personalized content recommendations to users based on viewing history and preferences.',
      owningTeamId: 'team4',
      apis: [
          {
              apiName: 'Recommendations API',
              apiDescription: 'Retrieves recommended content for a user.',
              dependentApis: ['User Behavior Tracking API', 'Metadata API']
          },
          {
              apiName: 'User Behavior Tracking API',
              apiDescription: 'Tracks user interactions and viewing history.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Content Management Service', 'Analytics Service'],
      platformDependencies: ['AWS Machine Learning', 'Apache Spark']
  },
  {
      serviceName: 'Billing and Subscription Service',
      serviceDescription: 'Manages user subscriptions, billing, and payment processing.',
      owningTeamId: 'team5',
      apis: [
          {
              apiName: 'Subscription API',
              apiDescription: 'Manages user subscription plans.',
              dependentApis: []
          },
          {
              apiName: 'Payment Processing API',
              apiDescription: 'Processes payments securely.',
              dependentApis: ['Email Notification API']
          },
          {
              apiName: 'Invoice API',
              apiDescription: 'Generates invoices and billing statements.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Notification Service'],
      platformDependencies: ['Stripe API', 'AWS RDS']
  },
  {
      serviceName: 'Notification Service',
      serviceDescription: 'Sends notifications, emails, and in-app messages to users.',
      owningTeamId: 'team6',
      apis: [
          {
              apiName: 'Email Notification API',
              apiDescription: 'Sends email notifications to users.',
              dependentApis: []
          },
          {
              apiName: 'Push Notification API',
              apiDescription: 'Sends push notifications to user devices.',
              dependentApis: ['Profile API']
          },
          {
              apiName: 'In-App Messaging API',
              apiDescription: 'Displays messages within the app.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Billing and Subscription Service'],
      platformDependencies: ['AWS SNS', 'Firebase Cloud Messaging']
  },
  {
      serviceName: 'Analytics Service',
      serviceDescription: 'Collects and analyzes data on user engagement, content performance, and platform metrics.',
      owningTeamId: 'team7',
      apis: [
          {
              apiName: 'Data Collection API',
              apiDescription: 'Collects data from various services.',
              dependentApis: []
          },
          {
              apiName: 'Reporting API',
              apiDescription: 'Provides analytical reports and dashboards.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Content Delivery Service', 'Recommendation Engine Service'],
      platformDependencies: ['AWS Redshift', 'Tableau']
  },
  {
      serviceName: 'Search Service',
      serviceDescription: 'Enables users to search for content across the platform.',
      owningTeamId: 'team8',
      apis: [
          {
              apiName: 'Search API',
              apiDescription: 'Allows users to search for content by title, genre, etc.',
              dependentApis: []
          },
          {
              apiName: 'Autocomplete API',
              apiDescription: 'Provides search suggestions as users type.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['Content Management Service', 'User Management Service'],
      platformDependencies: ['Elasticsearch']
  }
];

/** Updated System Data for StreamView (including seniorManagers and yearlyInitiatives) **/
const sampleSystemDataStreamView = {
    systemName: 'StreamView',
    systemDescription: 'StreamView is a video streaming platform that provides personalized content to users worldwide.',
    seniorManagers: sampleSeniorManagersDataStreamView,
    teams: sampleTeamsDataStreamView,
    sdms: sampleSDMsDataStreamView,
    pmts: samplePMTsDataStreamView,
    services: sampleServicesDataStreamView,
    platformDependencies: [], // Will be built dynamically on load
    // Capacity constraints
    capacityConfiguration: {
        workingDaysPerYear: 261, // To be configured
        standardHoursPerDay: 8,  // Default
        globalConstraints: {
            publicHolidays: null, // To be configured
            orgEvents: [
                // User will add events via UI later
            ]
        },
        leaveTypes: [ // Define standard leave types globally
            { id: "annual", name: "Annual Leave", defaultEstimatedDays: 0 },
            { id: "sick", name: "Sick Leave", defaultEstimatedDays: 0 },
            { id: "study", name: "Study Leave", defaultEstimatedDays: 0 },
            { id: "inlieu", name: "Time off In-lieu Leave", defaultEstimatedDays: 0 }
            //{ id: "paternity", name: "Paternity Leave", defaultEstimatedDays: 0 },
            //{ id: "family", name: "Family Responsibility", defaultEstimatedDays: 0 }
        ]
    },
    yearlyInitiatives: [
        // --- Protected Initiatives ---
        {
            initiativeId: 'init-sv-ktlo', title: 'KTLO / Operational Excellence', description: 'Ongoing bug fixes, refactoring, library updates, minor enhancements.', relatedBusinessGoalId: 'eng-excellence', isProtected: true,
            assignments: [ // Assign estimate to all teams
                { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.75 }, { teamId: 'team4', sdeYears: 1.25 },
                { teamId: 'team5', sdeYears: 0.75 }, { teamId: 'team6', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }
            ]
        },
        {
            initiativeId: 'init-sv-oncall', title: 'On-Call / Production Support', description: 'Dedicated capacity for handling live site issues and production incidents.', relatedBusinessGoalId: 'ops-stability', isProtected: true,
            assignments: [ // Assign 1 SDE Year to all teams
                 { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 1.0 }, { teamId: 'team4', sdeYears: 1.0 },
                 { teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 1.0 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 1.0 }
            ]
        },
        {
            initiativeId: 'init-sv-security', title: 'Mandatory Security Hardening (Compliance)', description: 'Address critical security vulnerabilities and ensure compliance (e.g., SOC2, GDPR).', relatedBusinessGoalId: 'compliance', isProtected: true,
            assignments: [
                { teamId: 'team1', sdeYears: 0.5 }, // User Management
                { teamId: 'team5', sdeYears: 0.75 }, // Billing/Finance
                // Add infra/platform team if one existed, assume team2 handles some platform aspects
                { teamId: 'team2', sdeYears: 0.5 } // Content Delivery/Platform
            ]
        },
        // --- Feature/Product Initiatives (Examples) ---
        { initiativeId: 'init-sv-001', title: 'AV1 Codec Support', description: 'Implement AV1 codec for improved streaming efficiency.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 2.5 }, { teamId: 'team3', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-002', title: 'Tiered Subscription Model', description: 'Launch new subscription tiers (Basic, Premium, Family).', relatedBusinessGoalId: 'revenue-growth', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 3.0 }, { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-003', title: 'Recommendation Algorithm V3', description: 'Develop and deploy next-gen recommendation engine.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 4.0 }, { teamId: 'team7', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-004', title: 'Expand CDN to South America', description: 'Set up CDN infrastructure in SA region.', relatedBusinessGoalId: 'global-expansion', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-005', title: 'User Profile Enhancements', description: 'Add customizable avatars and viewing preferences.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-006', title: 'Content Search Facets', description: 'Improve search with filters for genre, rating, year.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-007', title: 'Offline Viewing Improvements', description: 'Enhance download stability and management.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-008', title: 'A/B Testing Framework', description: 'Build internal framework for feature A/B testing.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 2.0 }] },
        { initiativeId: 'init-sv-009', title: 'Parental Controls V2', description: 'Granular controls per profile and content rating.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-010', title: 'Interactive Content POC', description: 'Proof-of-concept for choose-your-own-adventure style content.', relatedBusinessGoalId: 'innovation', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 0.75 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-011', title: 'Payment Gateway Integration (New Region)', description: 'Add local payment options for APAC.', relatedBusinessGoalId: 'global-expansion', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-012', title: 'Real-time Analytics Dashboard', description: 'Internal dashboard for viewing concurrency and errors.', relatedBusinessGoalId: 'ops-stability', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-013', title: 'Watch Party Feature', description: 'Allow users to watch content synchronously with friends.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.5 }, { teamId: 'team6', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-014', title: 'Metadata Enrichment AI', description: 'Use AI to auto-tag content metadata.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team3', sdeYears: 1.5 }, { teamId: 'team4', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-015', title: 'GDPR Data Deletion Automation', description: 'Automate user data deletion requests for GDPR.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.75 }, { teamId: 'team7', sdeYears: 0.25 }] },
        { initiativeId: 'init-sv-016', title: 'Improved Subtitle Customization', description: 'Allow users to change subtitle font, size, color.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-017', title: 'Search Performance Optimization', description: 'Reduce search latency by 50%.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-018', title: 'Gift Subscriptions', description: 'Allow users to purchase subscriptions for others.', relatedBusinessGoalId: 'revenue-growth', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 0.25 }] },
        { initiativeId: 'init-sv-019', title: 'Video Player Accessibility Audit & Fixes', description: 'Ensure player meets WCAG AA standards.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.75 }] },
        { initiativeId: 'init-sv-020', title: 'Reduce Streaming Startup Time', description: 'Optimize playback start time for users.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-021', title: 'Content Partner Reporting Portal', description: 'Allow content partners to view performance data.', relatedBusinessGoalId: 'partnerships', isProtected: false, assignments: [{ teamId: 'team3', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-022', title: 'Personalized Push Notifications', description: 'Send targeted notifications based on viewing habits.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team6', sdeYears: 1.0 }, { teamId: 'team4', sdeYears: 0.5 }] }
    ],
    // *** NEW: Add placeholder for calculated capacity metrics ***
    calculatedCapacityMetrics: null
    // **********************************************************
};

/** Sample Data for ConnectPro **/

/** Define Senior Managers for ConnectPro **/
const sampleSeniorManagersDataContactCenter = [
    { seniorManagerId: 'srMgrCC1', seniorManagerName: 'Senior Sam' }
    // Only one senior manager for this example
];

/** Updated SDMs Data for ConnectPro (with seniorManagerId) **/
const contactCenterSDMsData = [
    { sdmId: 'sdm1', sdmName: 'Alex Johnson', seniorManagerId: 'srMgrCC1' },
    { sdmId: 'sdm2', sdmName: 'Matthew Jackson', seniorManagerId: 'srMgrCC1' },
    { sdmId: 'sdm3', sdmName: 'Ryan King', seniorManagerId: 'srMgrCC1' },
    { sdmId: 'sdm4', sdmName: 'Laura Turner', seniorManagerId: 'srMgrCC1' }
];

const contactCenterPMTsData = [
    { pmtId: 'pmt1', pmtName: 'Karen Davis' },          // Shared between team1 and team8
    { pmtId: 'pmt2', pmtName: 'Patricia Thompson' },    // Shared among team2, team3, team6
    { pmtId: 'pmt3', pmtName: 'Angela Green' },         // Shared between team4 and team5
    { pmtId: 'pmt4', pmtName: 'Stephanie Roberts' }     // PMT for team7
];

/** Updated Teams Data for ConnectPro (with fundedHeadcount, buildersInSeats, engineers array) **/
const contactCenterTeamsData = [
    {
        teamId: 'team1',
        teamName: 'Customer Experience Team',
        teamIdentity: 'CX Warriors',
        fundedHeadcount: 6,
        buildersInSeats: 5,
        engineers: [
            { name: 'Alex Johnson', level: 4 }, // Assuming SDM might be L4+
            { name: 'Emily Smith', level: 3 },
            { name: 'David Lee', level: 3 },
            { name: 'Sarah Brown', level: 2 },
            { name: 'Michael Wilson', level: 1 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm1',
        pmtId: 'pmt1',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }
        
    },
    {
        teamId: 'team2',
        teamName: 'Case Management Team',
        teamIdentity: 'Case Titans',
        fundedHeadcount: 5,
        buildersInSeats: 4,
        engineers: [
            { name: 'Jessica Taylor', level: 4 },
            { name: 'Daniel Moore', level: 3 },
            { name: 'Amy Anderson', level: 2 },
            { name: 'James Thomas', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm1',
        pmtId: 'pmt2',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }
        
    },
    {
        teamId: 'team3',
        teamName: 'Routing and Agent Tools Team', // Note: Original had 7 names, split into team3/4
        teamIdentity: 'Routing Rangers',
        fundedHeadcount: 5, // Adjusted
        buildersInSeats: 4, // Adjusted
        engineers: [
            { name: 'Matthew Jackson', level: 5 }, // Assuming SDM L5
            { name: 'Ashley White', level: 3 },
            { name: 'Joshua Harris', level: 2 },
            { name: 'Andrew Garcia', level: 2 } // Moved Andrew here
        ],
        awayTeamMembers: [
            { name: 'Helping Hannah', level: 2, sourceTeam: 'AI Research Division' }
        ], // Example away team member
        sdmId: 'sdm2',
        pmtId: 'pmt2',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }
        
    },
    {
        teamId: 'team4',
        teamName: 'Agent Tools Team', // Note: Original had 7 names, split into team3/4
        teamIdentity: 'Agent Aces',
        fundedHeadcount: 4, // Adjusted
        buildersInSeats: 3, // Adjusted
        engineers: [
             // Andrew Garcia moved to team3
            { name: 'Megan Clark', level: 3 },
            { name: 'Steven Lewis', level: 2 },
            { name: 'Nicole Young', level: 1 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm2', // Still under Matthew Jackson
        pmtId: 'pmt3',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }
        
    },
    {
        teamId: 'team5',
        teamName: 'Communication Channels Team',
        teamIdentity: 'Comm Mandalorians',
        fundedHeadcount: 6,
        buildersInSeats: 5,
        engineers: [
            { name: 'Ryan King', level: 4 }, // Assuming SDM L4
            { name: 'Samantha Wright', level: 3 },
            { name: 'Brandon Lopez', level: 3 },
            { name: 'Rachel Hill', level: 2 },
            { name: 'Justin Scott', level: 2 }
        ],
        awayTeamMembers: [
            { name: 'Support Sam', level: 3, sourceTeam: 'Sister Company Ops' }
        ], // Example away team member
        sdmId: 'sdm3',
        pmtId: 'pmt3',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }
        
    },
    {
        teamId: 'team6',
        teamName: 'Skills Management Team',
        teamIdentity: 'Skill Masters',
        fundedHeadcount: 3,
        buildersInSeats: 2,
        engineers: [
            { name: 'Kimberly Adams', level: 3 },
            { name: 'Jonathan Baker', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm3',
        pmtId: 'pmt2',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }
        
    },
    {
        teamId: 'team7',
        teamName: 'Analytics and Configuration Team', // Note: Original had 5 names, split into team7/8
        teamIdentity: 'Data Wizards',
        fundedHeadcount: 4, // Adjusted
        buildersInSeats: 3, // Adjusted
        engineers: [
            { name: 'Jason Carter', level: 4 },
            { name: 'Melissa Mitchell', level: 3 },
            { name: 'Kevin Perez', level: 2 }
            // Laura Turner and Eric Phillips moved to team8
        ],
        awayTeamMembers: [],
        sdmId: 'sdm4',
        pmtId: 'pmt4',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }
        
    },
    {
        teamId: 'team8',
        teamName: 'Configuration Team', // Note: Original had 5 names, split into team7/8
        teamIdentity: 'Config Ninjas',
        fundedHeadcount: 3, // Adjusted
        buildersInSeats: 2, // Adjusted
        engineers: [
            { name: 'Laura Turner', level: 4 }, // Assuming SDM L4
            { name: 'Eric Phillips', level: 3 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm4', // Still under Laura Turner
        pmtId: 'pmt1',
        teamCapacityAdjustments: {
            leaveUptakeEstimates: [], // Empty by default
            variableLeaveImpact: {   // New structure
                maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
            },
            teamActivities: [],
            recurringOverhead: [],
            avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI            

        }
        
    }
];


const sampleServicesDataConnectPro = [
    {
        serviceName: 'Customer Portal Service',
        serviceDescription: 'Allows customers to raise support tickets and track their status.',
        owningTeamId: 'team1',
        apis: [
            {
                apiName: 'Ticket Submission API',
                apiDescription: 'Enables customers to submit support tickets.',
                dependentApis: []
            },
            {
                apiName: 'Ticket Tracking API',
                apiDescription: 'Allows customers to check the status of their tickets.',
                dependentApis: []
            }
        ],
        serviceDependencies: [],
        platformDependencies: ['AWS Cognito', 'AWS S3']
    },
    {
        serviceName: 'Case Management Service',
        serviceDescription: 'Manages the lifecycle of support tickets within the system.',
        owningTeamId: 'team2',
        apis: [
            {
                apiName: 'Case Creation API',
                apiDescription: 'Creates a new case in the system.',
                dependentApis: []
            },
            {
                apiName: 'Case Update API',
                apiDescription: 'Updates case details and status.',
                dependentApis: []
            },
            {
                apiName: 'Case Assignment API',
                apiDescription: 'Assigns cases to agents based on skills and availability.',
                dependentApis: ['Skills Assignment API']
            }
        ],
        serviceDependencies: ['Customer Portal Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS DynamoDB']
    },
    {
        serviceName: 'Routing Service',
        serviceDescription: 'Routes incoming interactions to appropriate agents.',
        owningTeamId: 'team3', // Owned by team3
        apis: [
            {
                apiName: 'Interaction Routing API',
                apiDescription: 'Routes voice, email, and chat interactions.',
                dependentApis: ['Skill Matching API', 'Agent Login API']
            },
            {
                apiName: 'Skill Matching API',
                apiDescription: 'Matches interactions to agents based on skills.',
                dependentApis: ['Skills Evaluation API']
            }
        ],
        serviceDependencies: ['Communication Channels Service', 'Skills Management Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS Lambda']
    },
    {
        serviceName: 'Agent Desktop Service',
        serviceDescription: 'Provides agents with tools to handle customer interactions.',
        owningTeamId: 'team4', 
        apis: [
            {
                apiName: 'Agent Login API',
                apiDescription: 'Authenticates agents and starts their session.',
                dependentApis: []
            },
            {
                apiName: 'Interaction Handling API',
                apiDescription: 'Manages ongoing interactions with customers.',
                dependentApis: ['Case Retrieval API']
            },
            {
                apiName: 'Case Retrieval API',
                apiDescription: 'Retrieves case details for agents.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service'],
        platformDependencies: ['AWS AppSync']
    },
    {
        serviceName: 'Communication Channels Service',
        serviceDescription: 'Handles voice calls, emails, and chat messages.',
        owningTeamId: 'team5',
        apis: [
            {
                apiName: 'Voice Call API',
                apiDescription: 'Manages voice call connections.',
                dependentApis: []
            },
            {
                apiName: 'Email Processing API',
                apiDescription: 'Processes incoming and outgoing emails.',
                dependentApis: []
            },
            {
                apiName: 'Chat Messaging API',
                apiDescription: 'Manages live chat sessions.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Routing Service', 'Agent Desktop Service'],
        platformDependencies: ['Amazon Connect', 'AWS SES', 'Amazon Lex']
    },
    {
        serviceName: 'Skills Management Service',
        serviceDescription: 'Manages agent skills and competencies.',
        owningTeamId: 'team6',
        apis: [
            {
                apiName: 'Skills Assignment API',
                apiDescription: 'Assigns skills to agents.',
                dependentApis: []
            },
            {
                apiName: 'Skills Evaluation API',
                apiDescription: 'Evaluates agent performance in skills.',
                dependentApis: []
            }
        ],
        serviceDependencies: [],
        platformDependencies: ['AWS Machine Learning']
    },
    {
        serviceName: 'Reporting and Analytics Service',
        serviceDescription: 'Provides reports on contact center performance.',
        owningTeamId: 'team7',
        apis: [
            {
                apiName: 'Performance Metrics API',
                apiDescription: 'Retrieves metrics on agent and center performance.',
                dependentApis: []
            },
            {
                apiName: 'Historical Data API',
                apiDescription: 'Accesses historical interaction data.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS Redshift', 'Amazon QuickSight']
    },
    {
        serviceName: 'Business Configuration Service',
        serviceDescription: 'Allows administrators to configure business rules and settings.',
        owningTeamId: 'team8', 
        apis: [
            {
                apiName: 'Settings API',
                apiDescription: 'Manages system-wide settings.',
                dependentApis: []
            },
            {
                apiName: 'Rules Engine API',
                apiDescription: 'Defines routing and assignment rules.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service', 'Agent Desktop Service', 'Communication Channels Service', 'Skills Management Service'],
        platformDependencies: ['AWS CloudFormation']
    }
];

/** Updated System Data for ConnectPro (including seniorManagers and yearlyInitiatives) **/
const sampleSystemDataContactCenter = {
    systemName: 'ConnectPro',
    systemDescription: 'ConnectPro is a cloud-based contact center solution that streamlines customer interactions across multiple channels.',
    seniorManagers: sampleSeniorManagersDataContactCenter,
    teams: contactCenterTeamsData,
    sdms: contactCenterSDMsData,
    pmts: contactCenterPMTsData,
    services: sampleServicesDataConnectPro,
    platformDependencies: [], // Will be built dynamically on load
    // Capacity constraints
    capacityConfiguration: {
        workingDaysPerYear: 261, // To be configured
        standardHoursPerDay: 8,  // Default
        globalConstraints: {
            publicHolidays: null, // To be configured
            orgEvents: [
                // User will add events via UI later
            ]
        },
        leaveTypes: [ // Define standard leave types globally
            { id: "annual", name: "Annual Leave", defaultEstimatedDays: 0 },
            { id: "sick", name: "Sick Leave", defaultEstimatedDays: 0 },
            { id: "study", name: "Study Leave", defaultEstimatedDays: 0 },
            { id: "inlieu", name: "Time off In-lieu Leave", defaultEstimatedDays: 0 }
           // { id: "paternity", name: "Paternity Leave", defaultEstimatedDays: 0 },
           // { id: "family", name: "Family Responsibility", defaultEstimatedDays: 0 }
        ]
    },
    yearlyInitiatives: [
        // --- Protected Initiatives ---
        {
            initiativeId: 'init-cc-ktlo', title: 'KTLO / Operational Excellence', description: 'Ongoing bug fixes, refactoring, library updates, minor enhancements.', relatedBusinessGoalId: 'eng-excellence', isProtected: true,
            assignments: [ // Assign estimate to all teams
                { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.75 }, { teamId: 'team4', sdeYears: 0.75 },
                { teamId: 'team5', sdeYears: 1.25 }, { teamId: 'team6', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }
            ]
        },
        {
            initiativeId: 'init-cc-oncall', title: 'On-Call / Production Support', description: 'Dedicated capacity for handling live site issues and production incidents.', relatedBusinessGoalId: 'ops-stability', isProtected: true,
            assignments: [ // Assign 1 SDE Year to all teams
                 { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 1.0 }, { teamId: 'team4', sdeYears: 1.0 },
                 { teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 1.0 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 1.0 }
            ]
        },
        {
            initiativeId: 'init-cc-security', title: 'Mandatory Security Audit & Remediation', description: 'Address findings from annual security audit and maintain compliance.', relatedBusinessGoalId: 'compliance', isProtected: true,
            assignments: [
                { teamId: 'team1', sdeYears: 0.5 }, // Customer Portal
                { teamId: 'team4', sdeYears: 0.75 }, // Agent Desktop
                { teamId: 'team5', sdeYears: 0.5 }, // Comm Channels (sensitive data)
                { teamId: 'team8', sdeYears: 0.5 }  // Config / Infra
            ]
        },
        // --- Feature/Product Initiatives (Examples) ---
        { initiativeId: 'init-cc-001', title: 'Omnichannel Support (Chat)', description: 'Integrate live chat channel support.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 2.0 }, { teamId: 'team4', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-002', title: 'AI-Powered Agent Assist (KB Suggestions)', description: 'Suggest relevant knowledge base articles to agents in real-time.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 2.5 }, { teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-cc-003', title: 'Upgrade Reporting Engine', description: 'Migrate reporting to new platform for better performance.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 3.0 }] },
        { initiativeId: 'init-cc-004', title: 'Salesforce CRM Integration V1', description: 'Basic integration to sync contact data and case creation.', relatedBusinessGoalId: 'integration', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }, { teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-005', title: 'Customer Portal Self-Service KB', description: 'Allow customers to search knowledge base via portal.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.5 }] },
        { initiativeId: 'init-cc-006', title: 'Advanced Routing Rules (Time-based)', description: 'Allow configuration of time-of-day routing.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team3', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-007', title: 'Agent Performance Dashboard', description: 'New dashboard in agent desktop showing key metrics.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 1.0 }, { teamId: 'team7', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-008', title: 'Skills-Based Routing Enhancements', description: 'Add proficiency levels to skill matching.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team6', sdeYears: 1.5 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-009', title: 'Email Channel Integration', description: 'Add support for email as an interaction channel.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.5 }, { teamId: 'team4', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-010', title: 'Voice Call Recording & Playback', description: 'Implement secure call recording and retrieval.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 2.0 }, { teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-011', title: 'Case Prioritization Engine', description: 'Automatically prioritize cases based on SLA or sentiment.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }, { teamId: 'team7', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-012', title: 'Configuration Change History', description: 'Track who changed what configuration when.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 1.0 }] },
        { initiativeId: 'init-cc-013', title: 'CTI Screen Pop Improvements', description: 'Customize screen pop data based on call context.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 1.0 }, { teamId: 'team5', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-014', title: 'Sentiment Analysis POC', description: 'Proof-of-concept for analyzing sentiment in chat/email.', relatedBusinessGoalId: 'innovation', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-cc-015', title: 'Supervisor Barge-In/Listen-In', description: 'Allow supervisors to monitor or join live calls.', relatedBusinessGoalId: 'quality-assurance', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.5 }, { teamId: 'team4', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-016', title: 'Customer Satisfaction Survey (CSAT)', description: 'Implement post-interaction CSAT surveys.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-017', title: 'Agent Skill Self-Assessment', description: 'Allow agents to update their skill profiles.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team6', sdeYears: 0.75 }, { teamId: 'team4', sdeYears: 0.25 }] },
        { initiativeId: 'init-cc-018', title: 'Knowledge Base Article Versioning', description: 'Track changes and history for KB articles.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.5 }] }, // Assuming portal team owns KB UI
        { initiativeId: 'init-cc-019', title: 'Real-time Queue Dashboard', description: 'Dashboard showing queue lengths, wait times.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.25 }] },
        { initiativeId: 'init-cc-020', title: 'Automated Case Closure Rules', description: 'Configure rules to auto-close inactive cases.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 0.75 }, { teamId: 'team8', sdeYears: 0.25 }] },
        { initiativeId: 'init-cc-021', title: 'Bulk User Import/Update', description: 'Allow admins to manage agents in bulk.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-022', title: 'PCI Compliance for Call Recordings', description: 'Ensure call recording storage meets PCI standards.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }] }
    ],
    // *** NEW: Add placeholder for calculated capacity metrics ***
    calculatedCapacityMetrics: null
    // **********************************************************
};

window.onload = function() {
    console.log("!!! Window on load !!!!");
    
    currentMode = Modes.NAVIGATION;
    // Initialize UI accordingly
};

/**
 * REVISED (v4) - Central function to manage switching between main views.
 * - Corrects title rendering logic.
 * - Hides edit-menu buttons on sub-views (Org Chart, Planning, etc.).
 * - Corrects Back button visibility on Edit System page.
 * Hides all views, then shows the target view and manages related UI elements.
 * @param {string | null} targetViewId - The ID of the main view container to show (e.g., 'planningView', 'organogramView'), or null/empty to show the home screen.
 * @param {string | null} newMode - Optional: The new mode to set (e.g., Modes.PLANNING). If null, mode is typically NAVIGATION or BROWSE depending on targetViewId.
 */
function switchView(targetViewId, newMode = null) {
    console.log(`Switching view to: ${targetViewId || 'Home'}, Mode: ${newMode || 'Auto'}`);

    // --- 1. Define all known view container IDs ---
    const allViewIds = [
        'systemEditForm',
        'visualizationCarousel', // Control the whole carousel container
        'serviceDependenciesTable', // The table below the carousel
        'organogramView',
        'engineerTableView',
        'planningView',
        'capacityConfigView'
    ];

    // --- 2. Hide all view containers ---
    allViewIds.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.style.display = 'none';
        }
    });

    // --- 3. Manage Top Bar Elements & Mode ---
    const pageTitleH1 = document.getElementById('pageTitle');
    const systemDescP = document.getElementById('systemDescription');
    const editMenu = document.querySelector('.edit-menu'); // System-specific actions
    const mainMenu = document.querySelector('.menu');     // Home screen actions
    const returnHomeBtn = document.getElementById('returnHomeButton');
    const backButton = document.getElementById('backToSystemViewButton');

    if (targetViewId) {
        // Showing a specific system-related view
        currentMode = newMode || Modes.BROWSE;

        // Show the target view container
        const targetElement = document.getElementById(targetViewId);
        if (targetElement) {
            targetElement.style.display = 'block';
        } else {
            console.error(`switchView: Target element with ID '${targetViewId}' not found!`);
            returnToHome(); // Fallback to home screen
            return;
        }

        // Update Title/Description
        if (pageTitleH1 && currentSystemData) {
            let titleSuffix = '';
            if (targetViewId === 'planningView') titleSuffix = ' - Year Plan';
            else if (targetViewId === 'organogramView') titleSuffix = ' - Organization Overview';
            else if (targetViewId === 'engineerTableView') titleSuffix = ' - Engineer List';
            else if (targetViewId === 'systemEditForm') titleSuffix = ' - Edit System';
            else if (targetViewId === 'visualizationCarousel' || targetViewId === 'serviceDependenciesTable') titleSuffix = ' - Overview';
            else if (targetViewId === 'capacityConfigView') titleSuffix = ' - Capacity Configurations';
            pageTitleH1.innerText = `${currentSystemData.systemName || 'System'}${titleSuffix}`;
            pageTitleH1.style.display = 'block';
        } else if (pageTitleH1) {
             pageTitleH1.style.display = 'none';
        }

        if (systemDescP) {
             const isOverview = (targetViewId === 'visualizationCarousel' || targetViewId === 'serviceDependenciesTable');
             systemDescP.style.display = isOverview ? 'block' : 'none';
             if(systemDescP.style.display === 'block' && currentSystemData) {
                systemDescP.innerText = currentSystemData.systemDescription || '';
             }
        }

        // Hide main menu, show edit menu ONLY for overview
        if (mainMenu) mainMenu.style.display = 'none';
        if (editMenu) {
            const isOverview = (targetViewId === 'visualizationCarousel' || targetViewId === 'serviceDependenciesTable');
            editMenu.style.display = isOverview ? 'block' : 'none';
        }

        // Show Return Home always when a system is loaded
        if (returnHomeBtn) returnHomeBtn.style.display = 'block';

        // *** CORRECTED LOGIC for Back Button visibility ***
        // Show Back button ONLY if NOT on the main overview
        const isOverviewForBackButton = (targetViewId === 'visualizationCarousel' || targetViewId === 'serviceDependenciesTable');
        if (backButton) {
            // Show if NOT overview, hide if overview. Edit page should show it.
             backButton.style.display = isOverviewForBackButton ? 'none' : 'block'; // <-- Corrected logic
        }
        // *** END CORRECTION ***

    } else {
        // Showing the Home Screen (targetViewId is null or empty)
        currentMode = Modes.NAVIGATION;
        currentSystemData = null; // Clear loaded system

        // Restore default Title/Description
        if (pageTitleH1) { pageTitleH1.innerText = "Software Management Tools"; pageTitleH1.style.display = 'block'; }
        if (systemDescP) { systemDescP.innerText = "Load a previously saved system or create a new system..."; systemDescP.style.display = 'block';}

        // Show main menu, hide edit menu
        if (mainMenu) mainMenu.style.display = 'block';
        if (editMenu) editMenu.style.display = 'none';

        // Hide action buttons
        if (returnHomeBtn) returnHomeBtn.style.display = 'none';
        if (backButton) backButton.style.display = 'none';

         // Clean up popups/tooltips just in case
        const systemListDiv = document.getElementById('systemListDiv');
        if (systemListDiv) document.body.removeChild(systemListDiv);
        d3.selectAll('.tooltip').remove();
    }

    // Special handling for carousel visibility
    if (targetViewId === 'visualizationCarousel') {
        showVisualization(0); // Make sure first carousel item is shown
    }

    console.log(`View switched. Current mode: ${currentMode}`);
}
// Make it globally accessible
window.switchView = switchView;

/** NEW Function - Shows the Capacity Configuration View */
function showCapacityConfigView() {
    console.log("Switching to Capacity Configuration View (Focus Mode)...");
    if (!currentSystemData) {
        alert("Please load a system first.");
        return;
    }
    const container = document.getElementById('capacityConfigView');
    if (!container) {
        console.error("Cannot generate global constraints form: Container #capacityConfigView not found.");
        return;
    }

    // Use switchView to handle view transition and UI elements
    switchView('capacityConfigView'); // Pass the ID of the new view container

    generateGlobalConstraintsForm();
    generateTeamConstraintsForms();    
    // ---------------------------

    // Placeholder for future content generation
    console.log("Capacity Config View displayed. Content generation will be added in next phase.");
    // (Phase 5+)
    updateCapacityCalculationsAndDisplay();

}
// Make it globally accessible for the button's onclick
window.showCapacityConfigView = showCapacityConfigView;

// --- Helper for Input Warnings (Phase 7a) ---
const updateInputWarning = (inputElement, message) => {
    let warningSpan = inputElement.nextElementSibling;
    // Check if the next sibling is ALREADY the warning span we created
    if (warningSpan && warningSpan.classList.contains('input-warning')) {
        // Update existing warning
        warningSpan.textContent = message ? ' ⚠️' : ''; // Show icon only if there's a message
        warningSpan.title = message || ''; // Set tooltip message
        warningSpan.style.display = message ? 'inline' : 'none'; // Hide span if no message
    } else if (message) {
        // Create NEW warning span if there's a message and no span exists
        warningSpan = document.createElement('span');
        warningSpan.className = 'input-warning';
        warningSpan.textContent = ' ⚠️';
        warningSpan.title = message;
        warningSpan.style.color = 'orange';
        warningSpan.style.cursor = 'help';
        warningSpan.style.marginLeft = '3px'; // Add a little space
        warningSpan.style.display = 'inline'; // Ensure it's visible
        // Insert the span immediately after the input element
        inputElement.parentNode.insertBefore(warningSpan, inputElement.nextSibling);
    }
     // Update the input's own title to include the warning (if any)
     // Ensure original title exists before appending
     const originalTitle = inputElement.dataset.originalTitle || '';
     inputElement.title = originalTitle + (message ? `\nWarning: ${message}` : '');
};
// --- End Helper ---

/**
 * Generates the form elements for global capacity constraints.
 * Fixes tbody lookup issue in renderOrgEvents.
 */
function generateGlobalConstraintsForm() {
    console.log("Generating Global Constraints Form (Fix 1)...");
    const container = document.getElementById('capacityConfigView');
    if (!container) {
        console.error("Cannot generate global constraints form: Container #capacityConfigView not found.");
        return;
    }
    if (!currentSystemData || !currentSystemData.capacityConfiguration) {
         console.error("Cannot generate global constraints form: Missing currentSystemData.capacityConfiguration.");
         container.innerHTML = '<p style="color:red;">Error: Capacity configuration data missing in the loaded system.</p>';
         return;
    }

    // Ensure nested structure exists
    if (!currentSystemData.capacityConfiguration.globalConstraints) {
         currentSystemData.capacityConfiguration.globalConstraints = { publicHolidays: null, orgEvents: [] };
    }

    if (!currentSystemData.capacityConfiguration.globalConstraints.orgEvents || !Array.isArray(currentSystemData.capacityConfiguration.globalConstraints.orgEvents)) {
         console.warn("Initializing missing or invalid orgEvents array.");
         currentSystemData.capacityConfiguration.globalConstraints.orgEvents = [];
     }
     
     if (!currentSystemData.capacityConfiguration.leaveTypes) {
         currentSystemData.capacityConfiguration.leaveTypes = [
             { id: "annual", name: "Annual Leave", defaultEstimatedDays: 0 },
             { id: "sick", name: "Sick Leave", defaultEstimatedDays: 0 },
             { id: "study", name: "Study Leave", defaultEstimatedDays: 0 },
             { id: "inlieu", name: "Time off In-lieu Leave", defaultEstimatedDays: 0 }             
         ];
     }


    // --- Create Section for Global Settings ---
    let globalSection = document.getElementById('globalConstraintsSection');
    if (!globalSection) {
        console.log("Creating #globalConstraintsSection div...");
        globalSection = document.createElement('div');
        globalSection.id = 'globalConstraintsSection';
        globalSection.style.border = '1px solid #ccc';
        globalSection.style.padding = '15px';
        globalSection.style.marginBottom = '20px';
        const globalTitle = document.createElement('h3');
        globalTitle.textContent = 'Organizational Defaults & Global Events';
        globalSection.appendChild(globalTitle);
        // Insert the new section at the beginning of the main container
        container.insertBefore(globalSection, container.firstChild);
    } else {
        console.log("Clearing existing content within #globalConstraintsSection (keeping title)...");
        // Clear previous content EXCEPT the title (assuming H3 is the first child)
        while (globalSection.childNodes.length > 1) {
            globalSection.removeChild(globalSection.lastChild);
        }
      }
    globalSection.style.border = '1px solid #ccc';
    globalSection.style.padding = '15px';
    globalSection.style.marginBottom = '20px';

    // Working Days per Year
    const wdLabel = document.createElement('label');
    wdLabel.textContent = 'Standard Working Days Per Year: ';
    wdLabel.htmlFor = 'workingDaysInput';
    wdLabel.title = 'Define the standard number of working days in a year (e.g., 261). Used as the basis for SDE Year calculations. Values over 300 may be unrealistic.';
    const wdInput = document.createElement('input');
    wdInput.type = 'number';
    wdInput.id = 'workingDaysInput';
    wdInput.min = '1';
    wdInput.step = '1';
    wdInput.value = currentSystemData.capacityConfiguration.workingDaysPerYear || 261; // Default if null
    wdInput.style.width = '80px';
    wdInput.dataset.originalTitle = wdLabel.title; // Store original title for warnings    
    wdInput.addEventListener('change', (e) => {
        const value = parseInt(e.target.value);
        let warningMsg = ''; // Initialize warning message
        if (!isNaN(value) && value > 0) {
            currentSystemData.capacityConfiguration.workingDaysPerYear = value;
            console.log("Updated workingDaysPerYear:", value);
            // --- Sanity Check ---
            if (value > 300 || value < 200) { // Example sanity check range
                warningMsg = 'Value seems high/low. Typical range is 200-300.';
            }
            // --- End Sanity Check ---
            updateCapacityCalculationsAndDisplay();
        } else {
            // Revert to stored value if input is invalid
            e.target.value = currentSystemData.capacityConfiguration.workingDaysPerYear || 261;
        }
        updateInputWarning(e.target, warningMsg); // Update warning display
    });
    globalSection.appendChild(wdLabel);
    globalSection.appendChild(wdInput);
    // Initial check on load
    updateInputWarning(wdInput, (parseInt(wdInput.value) > 300 || parseInt(wdInput.value) < 200) ? 'Value seems high/low. Typical range is 200-300.' : '');    
    globalSection.appendChild(document.createElement('br'));
    globalSection.appendChild(document.createElement('br'));

    // Public Holidays
    const phLabel = document.createElement('label');
    phLabel.textContent = 'Public Holidays (Days/Year): ';
    phLabel.htmlFor = 'publicHolidaysInput';
    phLabel.title = 'Enter the total number of official public holidays per year that impact all teams.';
    const phInput = document.createElement('input');
    phInput.type = 'number';
    phInput.id = 'publicHolidaysInput';
    phInput.min = '0';
    phInput.step = '1';
    phInput.value = currentSystemData.capacityConfiguration.globalConstraints.publicHolidays || 0;
    phInput.style.width = '80px';
    phInput.dataset.originalTitle = phLabel.title; // Store original title    
    phInput.addEventListener('change', (e) => {
        const value = parseInt(e.target.value);
        let warningMsg = ''; // Initialize warning message
        if (!isNaN(value) && value >= 0) {
            currentSystemData.capacityConfiguration.globalConstraints.publicHolidays = value;
            console.log("Updated publicHolidays:", value);
            // --- Sanity Check ---
            if (value > 30) { // Example sanity check
                 warningMsg = 'Value seems high for public holidays (more than 30).';
            }
            // --- End Sanity Check ---
            updateCapacityCalculationsAndDisplay();
        } else {
            // Revert to stored value if input is invalid
            e.target.value = currentSystemData.capacityConfiguration.globalConstraints.publicHolidays || 0;
        }
        updateInputWarning(e.target, warningMsg); // Update warning display
    });

    globalSection.appendChild(phLabel);
    globalSection.appendChild(phInput);
    // Initial check on load
    updateInputWarning(phInput, (parseInt(phInput.value) > 30) ? 'Value seems high for public holidays (more than 30).' : '');    
    globalSection.appendChild(document.createElement('br'));
    globalSection.appendChild(document.createElement('br'));

    // --- Org-Wide Events ---
    const orgEventsTitle = document.createElement('h4');
    orgEventsTitle.textContent = 'Organization-Wide Events';
    orgEventsTitle.title = 'Define events that impact all (or most) engineers globally (e.g., Hackathons, All-Hands). Estimate average days per participating SDE.';
    globalSection.appendChild(orgEventsTitle);

    const orgEventsTable = document.createElement('table');
    orgEventsTable.style.width = '80%';
    orgEventsTable.style.borderCollapse = 'collapse';
    orgEventsTable.innerHTML = `
        <thead>
            <tr>
                <th style="border: 1px solid #ccc; padding: 5px;">Event Name</th>
                <th style="border: 1px solid #ccc; padding: 5px; text-align: center;">Est. Days/SDE</th>
                <th style="border: 1px solid #ccc; padding: 5px; width: 80px; text-align: center;">Action</th>
            </tr>
        </thead>
        <tbody id="orgEventsTbody">
            </tbody>
    `;
    globalSection.appendChild(orgEventsTable);

    // *** Find the tbody WITHIN the newly created table ***
    const orgEventsTbody = orgEventsTable.querySelector('#orgEventsTbody'); // Find tbody inside the table

    // --- REVISED renderOrgEvents function within generateGlobalConstraintsForm ---
    const renderOrgEvents = (tbodyElement) => {
        if (!tbodyElement) {console.error("Org events tbody not found for rendering"); return;}
        tbodyElement.innerHTML = '';
        // Access the array safely AFTER the check/init above
        const events = currentSystemData.capacityConfiguration.globalConstraints.orgEvents;
        console.log("[DEBUG] Rendering org events table with data:", JSON.stringify(events)); // Add log to see data used for render
    
        events.forEach((event, index) => {
            const row = tbodyElement.insertRow();
            const nameCell = row.insertCell(); /* ... Name Input Cell ... */ nameCell.style.border = '1px solid #ccc'; nameCell.style.padding = '5px'; const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = event.name || ''; nameInput.style.width = '95%';
            // *** MODIFIED NAME INPUT ONCHANGE ***
            nameInput.onchange = (e) => {
                // Explicitly find the event in currentSystemData using index
                const eventToUpdate = currentSystemData.capacityConfiguration.globalConstraints.orgEvents[index];
                if (eventToUpdate) {
                    eventToUpdate.name = e.target.value; // Update the object in the main data structure
                    console.log(`Updated org event[${index}] name in currentSystemData`);
                    updateCapacityCalculationsAndDisplay(); // Trigger update
                } else {
                    console.error(`Could not find org event at index ${index} to update name.`);
                }
            };
            nameCell.appendChild(nameInput);
    
            const daysCell = row.insertCell(); /* ... Days Input Cell ... */ daysCell.style.border = '1px solid #ccc'; daysCell.style.padding = '5px'; daysCell.style.textAlign = 'center'; const daysInput = document.createElement('input'); daysInput.type = 'number'; daysInput.min = '0'; daysInput.step = '0.5'; daysInput.value = event.estimatedDaysPerSDE || 0; daysInput.style.width = '60px';
            // *** MODIFIED DAYS INPUT ONCHANGE ***
            daysInput.onchange = (e) => {
                 // Explicitly find the event in currentSystemData using index
                 const eventToUpdate = currentSystemData.capacityConfiguration.globalConstraints.orgEvents[index];
                 if (eventToUpdate) {
                     eventToUpdate.estimatedDaysPerSDE = parseFloat(e.target.value) || 0; // Update the object in the main data structure
                     console.log(`Updated org event[${index}] days in currentSystemData`);
                     updateCapacityCalculationsAndDisplay(); // Trigger update
                 } else {
                     console.error(`Could not find org event at index ${index} to update days.`);
                 }
            };
            daysCell.appendChild(daysInput);
    
            const actionCell = row.insertCell(); /* ... Remove Button Cell ... */ actionCell.style.border = '1px solid #ccc'; actionCell.style.padding = '5px'; actionCell.style.textAlign = 'center'; const removeBtn = document.createElement('button'); removeBtn.textContent = 'Remove'; removeBtn.style.fontSize = '0.9em';
            // Remove button logic remains the same - it correctly modifies the array directly
            removeBtn.onclick = () => {
                console.log(`Attempting to remove org event at index ${index}`);
                currentSystemData.capacityConfiguration.globalConstraints.orgEvents.splice(index, 1);
                console.log("Spliced event from array. New array:", JSON.stringify(currentSystemData.capacityConfiguration.globalConstraints.orgEvents));
                renderOrgEvents(tbodyElement); // Re-render the table rows
                updateCapacityCalculationsAndDisplay(); // Trigger summary update
            };
            actionCell.appendChild(removeBtn);
        });
    };
    // --- END REVISED renderOrgEvents function ---

    // Check if tbody was found before calling renderOrgEvents
    if (orgEventsTbody) {
        renderOrgEvents(orgEventsTbody); // Initial render, pass the found tbody
    } else {
        console.error("Could not find #orgEventsTbody within the created orgEventsTable.");
    }

    const addOrgEventBtn = document.createElement('button');
    addOrgEventBtn.textContent = 'Add Org Event';
    addOrgEventBtn.style.marginTop = '10px';
    addOrgEventBtn.onclick = () => {
         if (!currentSystemData.capacityConfiguration.globalConstraints.orgEvents) {
             currentSystemData.capacityConfiguration.globalConstraints.orgEvents = [];
         }
         currentSystemData.capacityConfiguration.globalConstraints.orgEvents.push({ id: 'evt-' + Date.now(), name: 'New Org Event', estimatedDaysPerSDE: 0 });
         // *** Pass the correct tbody element when re-rendering after add ***
         if(orgEventsTbody) renderOrgEvents(orgEventsTbody);
         // Trigger recalculation of summary display
         updateCapacityCalculationsAndDisplay();
     };
     globalSection.appendChild(addOrgEventBtn);
     globalSection.appendChild(document.createElement('br'));
     globalSection.appendChild(document.createElement('br'));


    // --- Standard Leave Types (Defaults) ---
    const leaveTypesTitle = document.createElement('h4');
    leaveTypesTitle.textContent = 'Standard Leave Types (Default Days/SDE/Year)';
    leaveTypesTitle.title = 'Define standard leave types and their default estimated days per SDE per year. Team-specific estimates can override these defaults later.';
    globalSection.appendChild(leaveTypesTitle);

    const leaveTypesTable = document.createElement('table');
    leaveTypesTable.style.width = '60%';
    leaveTypesTable.style.borderCollapse = 'collapse';
    leaveTypesTable.innerHTML = `
        <thead>
            <tr>
                <th style="border: 1px solid #ccc; padding: 5px;">Leave Type</th>
                <th style="border: 1px solid #ccc; padding: 5px; text-align: center;">Default Est. Days/SDE/Year</th>
            </tr>
        </thead>
        <tbody id="leaveTypesTbody">
            </tbody>
    `;
    globalSection.appendChild(leaveTypesTable);

    const tbodyLeave = leaveTypesTable.querySelector('#leaveTypesTbody'); // Find tbody within this table
    if(tbodyLeave) {
        (currentSystemData.capacityConfiguration.leaveTypes || []).forEach(leaveType => {
            if(!leaveType) return; // Skip if invalid
            const row = tbodyLeave.insertRow();
            const nameCell = row.insertCell();
            nameCell.style.border = '1px solid #ccc'; nameCell.style.padding = '5px';
            nameCell.textContent = leaveType.name;

            const daysCell = row.insertCell();
            daysCell.style.border = '1px solid #ccc'; daysCell.style.padding = '5px'; daysCell.style.textAlign = 'center';
            const daysInput = document.createElement('input');
            daysInput.type = 'number'; daysInput.min = '0'; daysInput.step = '1'; daysInput.value = leaveType.defaultEstimatedDays || 0; daysInput.style.width = '60px';
            daysInput.title = `Default estimate for ${leaveType.name}`;
            daysInput.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                leaveType.defaultEstimatedDays = (!isNaN(value) && value >= 0) ? value : 0;
                console.log(`Updated default days for ${leaveType.id} to ${leaveType.defaultEstimatedDays}`);
                 //Trigger recalculation of summary display
                 updateCapacityCalculationsAndDisplay();
             });
             daysCell.appendChild(daysInput);
        });
    } else {
        console.error("Could not find #leaveTypesTbody within the created leaveTypesTable.");
    }
    // Note: Not adding 'Add New Leave Type' for now to keep MVP simpler.

    // --- Append Global Section ---
    console.log("Finished generating Global Constraints Form.");
}
window.generateGlobalConstraintsForm = generateGlobalConstraintsForm; // Make global if needed

/**
 * Helper: Calculates total standard leave days per SDE for a team.
 */
function calculateTotalStandardLeaveDaysPerSDE(team, globalLeaveTypes, capacityConfig) {
    if (!team || !globalLeaveTypes || !capacityConfig || !capacityConfig.leaveTypes) return 0;
    let totalEffectiveDays = 0;
    const teamUptakeEstimates = team.teamCapacityAdjustments?.leaveUptakeEstimates || [];

    globalLeaveTypes.forEach(leaveType => {
        if (!leaveType || !leaveType.id) return;
        const currentGlobalDefaultObj = capacityConfig.leaveTypes.find(lt => lt.id === leaveType.id);
        const globalDefault = currentGlobalDefaultObj ? (currentGlobalDefaultObj.defaultEstimatedDays || 0) : 0;
        const teamUptake = teamUptakeEstimates.find(est => est.leaveTypeId === leaveType.id);
        const uptakePercent = teamUptake ? (teamUptake.estimatedUptakePercent ?? 100) : 100;
        totalEffectiveDays += globalDefault * (uptakePercent / 100);
    });
    return totalEffectiveDays;
}

/**
 * Helper: Calculates total variable leave impact in TOTAL TEAM DAYS.
 */
function calculateTotalVariableLeaveDays(team) {
    if (!team || !team.teamCapacityAdjustments?.variableLeaveImpact) return 0;
    let totalTeamVariableDays = 0;
    const varLeaveImpacts = team.teamCapacityAdjustments.variableLeaveImpact;

    for (const leaveKey in varLeaveImpacts) {
        if (varLeaveImpacts.hasOwnProperty(leaveKey)) {
            const impact = varLeaveImpacts[leaveKey];
            totalTeamVariableDays += (impact?.affectedSDEs || 0) * (impact?.avgDaysPerAffectedSDE || 0);
        }
    }
    return totalTeamVariableDays;
}

/**
 * Helper: Calculates total org event days per SDE.
 */
function calculateOrgEventDaysPerSDE(capacityConfig) {
    let totalDays = 0;
    const orgEvents = capacityConfig?.globalConstraints?.orgEvents || [];
    orgEvents.forEach(event => {
        totalDays += event.estimatedDaysPerSDE || 0;
    });
    return totalDays;
}


/**
 * Helper: Calculates team activity impacts.
 * Returns an object: { daysPerSDE: total_days_from_perSDE_inputs, totalTeamDaysDuration: duration_from_total_inputs }
 * Note: Renamed totalTeamDays to totalTeamDaysDuration to better reflect user interpretation.
 */
function calculateTeamActivityImpacts(team) {
    const result = { daysPerSDE: 0, totalTeamDaysDuration: 0 }; // Renamed second property
    if (!team || !team.teamCapacityAdjustments?.teamActivities) return result;

    const teamActivities = team.teamCapacityAdjustments.teamActivities;
    teamActivities.forEach(activity => {
        const value = activity.value || 0;
        if (activity.estimateType === 'perSDE') {
            result.daysPerSDE += value;
        } else { // Default to 'total' if not 'perSDE'
            result.totalTeamDaysDuration += value; // Accumulate the duration specified
        }
    });
    return result;
}


/**
 * Helper (CORRECTED): Calculates overhead days per SDE.
 */
function calculateOverheadDaysPerSDE(team, workingDaysPerYear) {
    if (!team || !team.teamCapacityAdjustments || !workingDaysPerYear || workingDaysPerYear === 0) {
         return 0;
    }
    const hoursPerWeek = team.teamCapacityAdjustments.avgOverheadHoursPerWeekPerSDE || 0;
    if (hoursPerWeek === 0) return 0;
    const standardHoursPerDay = 8;
    const totalAnnualOverheadHours = hoursPerWeek * (workingDaysPerYear / 5);
    const totalOverheadDays = totalAnnualOverheadHours / standardHoursPerDay;
    return totalOverheadDays;
}


/**
 * REVISED (Phase 7b fix 6) - Calculates capacity metrics for all teams across all scenarios.
 * - Includes required helper functions.
 * - Calculates SDE Year contribution for each deduction category directly.
 * - CORRECTED Team Activity calculation for 'Total Team Days' type inputs per user interpretation.
 */
function calculateAllCapacityMetrics() {
    console.log("Calculating all capacity metrics (Phase 7b - Fix 6)..."); // Log updated
    if (!currentSystemData || !currentSystemData.capacityConfiguration || !currentSystemData.teams) {
        console.error("Cannot calculate metrics: Missing core data (config or teams).");
        return { totals: { TeamBIS: {}, EffectiveBIS: {}, FundedHC: {} } };
    }

    const capacityConfig = currentSystemData.capacityConfiguration;
    const teams = currentSystemData.teams;
    const workingDaysPerYear = capacityConfig.workingDaysPerYear || 261;
    const sdesPerSdeYear = 1; // Base assumption
    const globalLeaveTypes = capacityConfig.leaveTypes || [];
    const workingDays = workingDaysPerYear || 1; // Use for division, avoid zero

    const teamMetrics = {};
    const totals = {
        TeamBIS: { headcount: 0, grossYrs: 0, deductYrs: 0, netYrs: 0, deductionsBreakdown: {} },
        EffectiveBIS: { headcount: 0, grossYrs: 0, deductYrs: 0, netYrs: 0, deductionsBreakdown: {} },
        FundedHC: { headcount: 0, grossYrs: 0, deductYrs: 0, netYrs: 0, deductionsBreakdown: {} }
    };
     // Initialize total breakdowns
     ['TeamBIS', 'EffectiveBIS', 'FundedHC'].forEach(scenario => {
        totals[scenario].deductionsBreakdown = {
            stdLeaveYrs: 0, varLeaveYrs: 0, holidayYrs: 0,
            orgEventYrs: 0, teamActivityYrs: 0, overheadYrs: 0
        };
     });


    // --- Iterate through each team ---
    (teams || []).forEach(team => {
        if (!team || !team.teamId) return;
        teamMetrics[team.teamId] = { TeamBIS: {}, EffectiveBIS: {}, FundedHC: {} };

        // --- Pre-calculate per-SDE values and total team days using helpers ---
        const stdLeave_days_per_sde = calculateTotalStandardLeaveDaysPerSDE(team, globalLeaveTypes, capacityConfig);
        const holidays_days_per_sde = capacityConfig.globalConstraints?.publicHolidays || 0;
        const orgEvents_days_per_sde = calculateOrgEventDaysPerSDE(capacityConfig);
        const overhead_days_per_sde = calculateOverheadDaysPerSDE(team, workingDaysPerYear);
        const variable_leave_total_team_days = calculateTotalVariableLeaveDays(team);
        // Get { daysPerSDE: total_avg_days, totalTeamDaysDuration: duration_for_whole_team_event }
        const teamActivityImpacts = calculateTeamActivityImpacts(team);

        // --- Iterate through each scenario for this team ---
        ['TeamBIS', 'EffectiveBIS', 'FundedHC'].forEach(scenario => {
            let headcount = 0;
            switch (scenario) {
                case 'TeamBIS': headcount = team?.buildersInSeats || 0; break;
                case 'EffectiveBIS': headcount = (team?.buildersInSeats || 0) + (team?.awayTeamMembers?.length || 0); break;
                case 'FundedHC': headcount = team?.fundedHeadcount || 0; break;
            }

            // --- Calculate SDE Year impact for EACH category for THIS scenario ---

            // Calculate SDE Years impact from the duration specified for 'Total Team Days' type activities
            // This impact applies to *each* SDE in the current scenario's headcount
            const teamActivityYrs_from_total_duration = (teamActivityImpacts.totalTeamDaysDuration / workingDays) * headcount;

            // Calculate SDE Years impact from the average specified for 'Days/SDE' type activities
            // This impact is an average and not scaled by headcount again
            const teamActivityYrs_from_perSDE_avg = teamActivityImpacts.daysPerSDE / workingDays;

            const breakdown = {
                stdLeaveYrs: (stdLeave_days_per_sde / workingDays) * headcount,
                varLeaveYrs: variable_leave_total_team_days / workingDays, // Direct conversion from total days
                holidayYrs: (holidays_days_per_sde / workingDays) * headcount,
                orgEventYrs: (orgEvents_days_per_sde / workingDays) * headcount,
                // *** CORRECTED LOGIC for Team Activities (Fix 6) ***
                // Add the impact from events affecting the whole team (scaled by HC)
                // Add the impact from averaged per-SDE events (not scaled by HC)
                teamActivityYrs: teamActivityYrs_from_total_duration + teamActivityYrs_from_perSDE_avg,
                overheadYrs: (overhead_days_per_sde / workingDays) * headcount
            };

            // Calculate core metrics
            const grossYrs = headcount * sdesPerSdeYear;
            const totalDeductYrs = Object.values(breakdown).reduce((sum, val) => sum + (val || 0), 0);
            const netYrs = grossYrs - totalDeductYrs;

            // Store metrics
            teamMetrics[team.teamId][scenario] = {
                headcount: headcount,
                grossYrs: grossYrs,
                deductYrs: totalDeductYrs,
                netYrs: netYrs,
                deductionsBreakdown: breakdown
            };

            // Accumulate totals
            totals[scenario].headcount += headcount;
            totals[scenario].grossYrs += grossYrs;
            totals[scenario].deductYrs += totalDeductYrs;
            totals[scenario].netYrs += netYrs;
            if (breakdown) {
                totals[scenario].deductionsBreakdown.stdLeaveYrs += breakdown.stdLeaveYrs || 0;
                totals[scenario].deductionsBreakdown.varLeaveYrs += breakdown.varLeaveYrs || 0;
                totals[scenario].deductionsBreakdown.holidayYrs += breakdown.holidayYrs || 0;
                totals[scenario].deductionsBreakdown.orgEventYrs += breakdown.orgEventYrs || 0;
                totals[scenario].deductionsBreakdown.teamActivityYrs += breakdown.teamActivityYrs || 0;
                totals[scenario].deductionsBreakdown.overheadYrs += breakdown.overheadYrs || 0;
            }

        }); // End scenario loop
    }); // End team loop

    console.log("Finished calculating metrics (Phase 7b - Fix 6).");
    const finalMetrics = { ...teamMetrics, totals: totals };
    return finalMetrics;
}

window.calculateAllCapacityMetrics = calculateAllCapacityMetrics; // Ensure it's globally accessible

/**
 * REVISED (Phase 7d) - Triggers recalculation and redraws summary, narrative, AND chart.
 * @param {string | null} newScenario - Optional. If provided, sets the current scenario before redrawing.
 */
function updateCapacityCalculationsAndDisplay(newScenario = null) {
    console.log(`Updating capacity display. New scenario provided: ${newScenario}, Current scenario: ${currentCapacityScenario}`);
    let scenarioChanged = false;
    if (newScenario && ['TeamBIS', 'EffectiveBIS', 'FundedHC'].includes(newScenario) && newScenario !== currentCapacityScenario) {
        currentCapacityScenario = newScenario;
        scenarioChanged = true;
        console.log(`Capacity scenario changed to: ${currentCapacityScenario}`);
    }

    if (!currentSystemData) {
        console.warn("No current system data to calculate metrics from.");
        // Clear displays if no data?
         const summarySection = document.getElementById('capacitySummarySection');
         if (summarySection) summarySection.innerHTML = '<h3>Calculated Net Project Capacity Summary</h3><p><em>No system data loaded.</em></p>';
         const narrativeContainer = document.getElementById('capacityNarrativeSection');
          if (narrativeContainer) narrativeContainer.style.display = 'none'; // Hide if no data
           const chartContainer = document.getElementById('capacityChartContainer');
          if (chartContainer) chartContainer.style.display = 'none'; // Hide if no data
        return;
    }

    // --- Perform Calculations ---
    const calculatedMetrics = calculateAllCapacityMetrics(currentSystemData);
    console.log("Capacity metrics calculated:", calculatedMetrics); // Log calculated metrics for debugging

    // --- Update Displays ---
    // 1. Summary Table
    generateCapacitySummaryDisplay(calculatedMetrics, currentCapacityScenario);

    // 2. Narrative Section (will handle its own container creation/visibility)
    generateCapacityNarrative(calculatedMetrics, currentCapacityScenario);

    // 3. Waterfall Chart (will handle its own container creation/visibility)
    generateCapacityWaterfallChart(calculatedMetrics, currentCapacityScenario); // <-- ADDED CALL

    console.log("All capacity displays updated.");
}
// Make global if needed
window.updateCapacityCalculationsAndDisplay = updateCapacityCalculationsAndDisplay;


/**
 * Helper (Phase 7b): Formats the deduction breakdown object into a tooltip string.
 */
function formatDeductionTooltip(breakdown) {
    if (!breakdown) {
        return "Breakdown not available.";
    }
    // Ensure all potential keys exist, defaulting to 0
    const stdLeave = breakdown.stdLeaveYrs || 0;
    const varLeave = breakdown.varLeaveYrs || 0;
    const holidays = breakdown.holidayYrs || 0;
    const orgEvents = breakdown.orgEventYrs || 0;
    const teamActs = breakdown.teamActivityYrs || 0;
    const overhead = breakdown.overheadYrs || 0;

    // Format the string for the tooltip title attribute
    return `Breakdown (SDE Yrs):
Std Leave: ${stdLeave.toFixed(2)}
Var Leave: ${varLeave.toFixed(2)}
Holidays: ${holidays.toFixed(2)}
Org Events: ${orgEvents.toFixed(2)}
Team Acts: ${teamActs.toFixed(2)}
Overhead: ${overhead.toFixed(2)}`;
}
// --- End Helper ---

/**
 * NEW Function (Phase 5b) - Generates the Summary Table HTML based on calculated metrics and selected scenario.
 * @param {object} calculatedMetrics - The object returned by calculateAllCapacityMetrics.
 * @param {string} selectedScenario - The key of the currently selected scenario ('TeamBIS', 'EffectiveBIS', 'FundedHC').
 */
function generateCapacitySummaryDisplay(calculatedMetrics, selectedScenario) {
    console.log(`Generating Capacity Summary Display for scenario: ${selectedScenario}`);
    const summarySection = document.getElementById('capacitySummarySection');
    if (!summarySection) { console.error("Summary section not found."); return; }

    const placeholder = summarySection.querySelector('#capacitySummaryPlaceholder');
    if (placeholder) placeholder.style.display = 'none'; // Hide placeholder

    // --- Scenario Buttons ---
    let scenarioButtonsDiv = summarySection.querySelector('#capacityScenarioButtons');
    if (!scenarioButtonsDiv) {
        scenarioButtonsDiv = document.createElement('div');
        scenarioButtonsDiv.id = 'capacityScenarioButtons';
        scenarioButtonsDiv.style.marginBottom = '15px';
        summarySection.insertBefore(scenarioButtonsDiv, summarySection.querySelector('p')); // Insert before placeholder
    }
    const baseButtonStyle = 'padding: 5px 10px; margin-right: 10px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 0.9em;';
    const activeButtonStyle = baseButtonStyle + ' background-color: #007bff; color: white; border-color: #0056b3; font-weight: bold;';
    const inactiveButtonStyle = baseButtonStyle + ' background-color: #e9ecef; color: #495057;';

    scenarioButtonsDiv.innerHTML = `
        <strong style="margin-right: 10px;">Show Summary For:</strong>
        <button type="button" style="${selectedScenario === 'EffectiveBIS' ? activeButtonStyle : inactiveButtonStyle}" onclick="updateCapacityCalculationsAndDisplay('EffectiveBIS')">Effective BIS</button>
        <button type="button" style="${selectedScenario === 'TeamBIS' ? activeButtonStyle : inactiveButtonStyle}" onclick="updateCapacityCalculationsAndDisplay('TeamBIS')">Team BIS</button>
        <button type="button" style="${selectedScenario === 'FundedHC' ? activeButtonStyle : inactiveButtonStyle}" onclick="updateCapacityCalculationsAndDisplay('FundedHC')">Funded HC</button>
    `;

    // --- Summary Table ---
    let summaryTable = summarySection.querySelector('#capacitySummaryTable');
    if (!summaryTable) {
        summaryTable = document.createElement('table');
        summaryTable.id = 'capacitySummaryTable';
        summaryTable.style.width = '100%';
        summaryTable.style.borderCollapse = 'collapse';
        summaryTable.style.marginTop = '10px';
        summarySection.appendChild(summaryTable); // Append new table
    }
    summaryTable.style.display = 'table'; // Ensure table is visible
    summaryTable.innerHTML = ''; // Clear previous content

    const thead = summaryTable.createTHead();
    const headerRow = thead.insertRow();
    // **UPDATED Headers with Units**
    const headers = [
        { text: 'Team Identity', title: 'Team Identifier' },
        { text: `HC (${selectedScenario})`, title: 'Headcount for the selected scenario' },
        { text: 'Gross (SDE Yrs)', title: 'Total SDE Years before deductions' },
        { text: '(-) Deduct (SDE Yrs)', title: 'Total deductions (Leave, Holidays, Activities, Overhead) in SDE Years' },
        { text: '(=) Net Project (SDE Yrs)', title: 'Remaining capacity for project work in SDE Years' }
    ];
    headers.forEach(hdr => {
        const th = document.createElement('th');
        th.textContent = hdr.text; th.title = hdr.title; // Use text and title properties
        th.style.border = '1px solid #ccc'; th.style.padding = '5px'; th.style.backgroundColor = '#f8f9fa';
        if (hdr.text !== 'Team Identity') th.style.textAlign = 'center'; else th.style.textAlign = 'left'; // Use hdr.text
        headerRow.appendChild(th);
    });

    const tbody = summaryTable.createTBody();
    const totals = calculatedMetrics.totals[selectedScenario] || { headcount: 0, grossYrs: 0, deductYrs: 0, netYrs: 0 };

    (currentSystemData.teams || []).forEach(team => {
        if (!team || !team.teamId) return;
        const teamMetrics = calculatedMetrics[team.teamId]?.[selectedScenario];
        if (!teamMetrics) { console.warn(`Metrics not found for team ${team.teamId} and scenario ${selectedScenario}`); return; }

        const row = tbody.insertRow();
        row.insertCell().textContent = team.teamIdentity || team.teamName || team.teamId;
        row.insertCell().textContent = teamMetrics.headcount.toFixed(2);
        row.insertCell().textContent = teamMetrics.grossYrs.toFixed(2);

        // Deduct Yrs Cell (with Tooltip)
        const deductCell = row.insertCell();
        deductCell.textContent = teamMetrics.deductYrs.toFixed(2); // Set the number
        // Add info icon for visual cue (optional)
        const infoIcon = document.createElement('span');
        infoIcon.textContent = ' ℹ️';
        infoIcon.style.cursor = 'help';
        infoIcon.style.fontSize = '0.8em'; // Make icon slightly smaller
        deductCell.appendChild(infoIcon);
        // Set the tooltip using the breakdown data
        const breakdownData = teamMetrics.deductionsBreakdown; // Get breakdown object
        deductCell.title = formatDeductionTooltip(breakdownData); // Use helper to format

        const netCell = row.insertCell();
        netCell.textContent = teamMetrics.netYrs.toFixed(2);
        netCell.style.fontWeight = 'bold';
        // **NEW (Phase 7a): Highlight if Net SDE Years <= 0**
        if (teamMetrics.netYrs <= 0) {
            netCell.style.backgroundColor = '#f8d7da'; // Light red
            netCell.title = 'Warning: Net Project Capacity is zero or negative!';
        }        

        // Style numerical cells
        Array.from(row.cells).forEach((cell, i) => { if (i > 0) cell.style.textAlign = 'center'; });
    });

    // Add Totals Row
    const tfoot = summaryTable.createTFoot();
    const footerRow = tfoot.insertRow();
    footerRow.style.fontWeight = 'bold'; footerRow.style.backgroundColor = '#f0f0f0';
    footerRow.insertCell().textContent = 'TOTALS';
    footerRow.insertCell().textContent = (totals.headcount).toFixed(2);
    footerRow.insertCell().textContent = totals.grossYrs.toFixed(2);
    
    // Total Deduct Yrs Cell (with Tooltip)
    const deductTotalCell = footerRow.insertCell();
    deductTotalCell.textContent = totals.deductYrs.toFixed(2); // Set the number
    // Add info icon
    const totalInfoIcon = document.createElement('span');
    totalInfoIcon.textContent = ' ℹ️';
    totalInfoIcon.style.cursor = 'help';
    totalInfoIcon.style.fontSize = '0.8em';
    deductTotalCell.appendChild(totalInfoIcon);
    // Set the tooltip using the breakdown data from totals
    const totalBreakdownData = totals[selectedScenario]?.deductionsBreakdown; // Get total breakdown
    deductTotalCell.title = formatDeductionTooltip(totalBreakdownData); // Use helper
    
    const netTotalCell = footerRow.insertCell();
    netTotalCell.textContent = totals.netYrs.toFixed(2);    

    // **NEW (Phase 7a): Highlight total if Net SDE Years <= 0**
    if (totals.netYrs <= 0) {
        netTotalCell.style.backgroundColor = '#f8d7da'; // Light red
        netTotalCell.title = 'Warning: Total Net Project Capacity is zero or negative!';
    }    
    Array.from(footerRow.cells).forEach((cell, i) => {
        cell.style.borderTop = '2px solid #666';
        if (i > 0) cell.style.textAlign = 'center';
    });

    console.log("Summary display generated.");
}
window.generateCapacitySummaryDisplay = generateCapacitySummaryDisplay; // Make global if needed

/**
 * REVISED (Phase 7c - Narrative Enhancement for Auditability) - Generates narrative & ensures container exists.
 */
function generateCapacityNarrative(calculatedMetrics, selectedScenario) {
    console.log(`Attempting to generate Enhanced Capacity Narrative for scenario: ${selectedScenario}...`);

    let narrativeContainer = document.getElementById('capacityNarrativeSection');
    const mainContainer = document.getElementById('capacityConfigView'); // Parent container

    // --- Ensure Narrative Container Exists ---
    if (!narrativeContainer) {
        console.log("Creating narrative section container with collapsible structure...");
        narrativeContainer = document.createElement('div');
        narrativeContainer.id = 'capacityNarrativeSection';
        narrativeContainer.style.border = '1px solid rgb(204, 204, 204)';
        narrativeContainer.style.marginTop = '20px';
        narrativeContainer.style.backgroundColor = '#f8f9fa';

        const narrativeHeader = document.createElement('h3');
        narrativeHeader.id = 'narrativeHeader';
        narrativeHeader.style.margin = '0';
        narrativeHeader.style.padding = '10px 15px';
        narrativeHeader.style.cursor = 'pointer';
        narrativeHeader.style.backgroundColor = '#e9ecef';
        narrativeHeader.style.borderBottom = '1px solid rgb(224, 224, 224)';
        narrativeHeader.title = 'Click to expand/collapse narrative';
        narrativeHeader.innerHTML = `<span class="toggle-indicator" style="font-weight:bold; margin-right:5px;">[+] </span>Capacity Narrative`;

        const narrativeContent = document.createElement('div');
        narrativeContent.id = 'narrativeContent';
        narrativeContent.style.padding = '15px';
        narrativeContent.style.display = 'none';
        narrativeContent.style.fontFamily = 'Arial, sans-serif';
        narrativeContent.style.lineHeight = '1.6';
        narrativeContent.innerHTML = `<p><em>Generating narrative...</em></p>`;

        narrativeContainer.appendChild(narrativeHeader);
        narrativeContainer.appendChild(narrativeContent);

        narrativeHeader.onclick = () => {
            const contentDiv = narrativeContainer.querySelector('#narrativeContent');
            const indicatorSpan = narrativeHeader.querySelector('.toggle-indicator');
            if (contentDiv && indicatorSpan) {
                const isHidden = contentDiv.style.display === 'none';
                contentDiv.style.display = isHidden ? 'block' : 'none';
                indicatorSpan.textContent = isHidden ? '[-] ' : '[+] ';
            }
        };

        if (mainContainer) {
            // Append after summary section if it exists, otherwise just append
            const summarySection = mainContainer.querySelector('#capacitySummarySection');
            if (summarySection && summarySection.parentNode === mainContainer) {
                 summarySection.insertAdjacentElement('afterend', narrativeContainer);
            } else {
                 mainContainer.appendChild(narrativeContainer);
            }
        } else {
            console.error("Main container #capacityConfigView not found. Cannot append narrative section.");
            return; // Cannot proceed without main container
        }

    } else {
        // Ensure main container is visible if it exists
         if(narrativeContainer) narrativeContainer.style.display = 'block';
    }

    const narrativeContentContainer = document.getElementById('narrativeContent');
    if (!narrativeContentContainer) {
        console.error("Narrative content container #narrativeContent not found in the DOM.");
        return;
    }

    // --- Check for Required Data ---
    if (!calculatedMetrics || !currentSystemData || !currentSystemData.capacityConfiguration || !currentSystemData.teams) {
        console.error("Cannot generate narrative: Required data is missing.");
        narrativeContentContainer.innerHTML = `<p><em>Error: Cannot generate narrative because required data is missing.</em></p>`;
        return;
    }

    const teams = currentSystemData.teams;
    const capacityConfig = currentSystemData.capacityConfiguration;
    const workingDays = capacityConfig.workingDaysPerYear || 261; // Use default if not set
    const standardHoursPerDay = capacityConfig.standardHoursPerDay || 8; // Use default if not set
    const totals = calculatedMetrics.totals; // Get totals for all scenarios

    // --- Helper Functions ---
    const toDays = (sdeYears) => {
        if (typeof sdeYears !== 'number' || isNaN(sdeYears)) return 'N/A';
        return (sdeYears * workingDays).toFixed(0);
    }
    const toFixed = (num, places = 2) => {
        if (typeof num !== 'number' || isNaN(num)) return 'N/A';
        const fixedNum = (num || 0).toFixed(places);
        return (fixedNum === '-0.00' || fixedNum === '-0.0') ? '0.00' : fixedNum;
    }
    const getTeamName = (team) => team.teamIdentity || team.teamName || team.teamId;
    const getDefaultLeaveDays = (leaveTypeId) => {
        return capacityConfig.leaveTypes?.find(lt => lt.id === leaveTypeId)?.defaultEstimatedDays || 0;
    }
    const getTeamLeaveUptake = (team, leaveTypeId) => {
        const uptakeObj = team.teamCapacityAdjustments?.leaveUptakeEstimates?.find(est => est.leaveTypeId === leaveTypeId);
        return uptakeObj?.estimatedUptakePercent ?? 100; // Default 100%
    }

    // --- Start Building Narrative HTML ---
    let narrativeHTML = '';

    // --- Paragraph 1: Top-Level Reality ---
    narrativeHTML += `<p><strong>Overall Capacity Baselines:</strong> `;
    narrativeHTML += `The total <strong>Funded Headcount</strong> is <strong>${toFixed(totals.FundedHC?.headcount)}</strong>, equivalent to a gross capacity of <strong>${toFixed(totals.FundedHC?.grossYrs)} SDE Years</strong> (${toDays(totals.FundedHC?.grossYrs)} SDE Days). `;
    narrativeHTML += `Based on current team composition (<strong>'Team BIS'</strong> - Builders In Seats), there are <strong>${toFixed(totals.TeamBIS?.headcount)}</strong> builders, providing <strong>${toFixed(totals.TeamBIS?.grossYrs)} SDE Years</strong> (${toDays(totals.TeamBIS?.grossYrs)} SDE Days). `;
    narrativeHTML += `Including known incoming 'Away Team' members (<strong>'Effective BIS'</strong>), the effective headcount is <strong>${toFixed(totals.EffectiveBIS?.headcount)}</strong>, for a gross capacity of <strong>${toFixed(totals.EffectiveBIS?.grossYrs)} SDE Years</strong> (${toDays(totals.EffectiveBIS?.grossYrs)} SDE Days) before any deductions.</p>`;

    // --- Paragraph 2: Global Constraints (with calculation parameters) ---
    const holidays = capacityConfig.globalConstraints?.publicHolidays || 0;
    const orgEvents = capacityConfig.globalConstraints?.orgEvents || [];
    const holidayImpactYrs = totals[selectedScenario]?.deductionsBreakdown?.holidayYrs || 0;
    const orgEventImpactYrs = totals[selectedScenario]?.deductionsBreakdown?.orgEventYrs || 0;

    narrativeHTML += `<p><strong>Global Factors Reducing Capacity:</strong> `;
    narrativeHTML += `Calculations converting days to SDE Years are based on the configured <strong>${workingDays} Standard Working Days Per Year</strong>. Overhead conversion assumes a standard <strong>${standardHoursPerDay}-hour</strong> working day. `; // Added parameters
    narrativeHTML += `Across the organization, <strong>${holidays} Public Holiday</strong> days reduce capacity by approx. <strong>${toFixed(holidayImpactYrs)} SDE Years</strong> (${toDays(holidayImpactYrs)} SDE Days). `;
    if (orgEvents.length > 0) {
        const eventNames = orgEvents.map(e => e.name || 'Unnamed Event').slice(0, 3).join(', ');
        narrativeHTML += `Planned Organization-Wide Events (e.g., ${eventNames}${orgEvents.length > 3 ? '...' : ''}) account for a further reduction of <strong>${toFixed(orgEventImpactYrs)} SDE Years</strong> (${toDays(orgEventImpactYrs)} SDE Days). `;
    } else {
         narrativeHTML += `No significant Organization-Wide Events impacting capacity have been defined. `;
    }
     const annualDefault = getDefaultLeaveDays('annual');
     narrativeHTML += `Standard leave defaults include ${annualDefault} days/SDE for Annual Leave. The actual impact varies per team based on estimated uptake percentages.</p>`;

    // --- Paragraphs 3+ (Per Team) ---
    narrativeHTML += `<h4 style="margin-bottom: 0.5em;">Team-Specific Breakdown (${selectedScenario} Scenario):</h4>`;

    teams.forEach(team => {
        const teamId = team.teamId;
        const teamName = getTeamName(team);
        const teamMetrics = calculatedMetrics[teamId]?.[selectedScenario];
        const teamBreakdown = teamMetrics?.deductionsBreakdown;

        if (!teamMetrics || !teamBreakdown) {
            narrativeHTML += `<p><strong>${teamName}:</strong> Metrics not available for this scenario.</p><hr style='border:none; border-top: 1px solid #eee; margin: 1em 0;'>`;
            return; // Skip this team if no metrics
        }

        const totalSinkYrs = teamMetrics.deductYrs || 0;
        const totalSinkDays = toDays(totalSinkYrs);

        narrativeHTML += `<p><strong><u>${teamName}</u> (HC: ${toFixed(teamMetrics.headcount)} in ${selectedScenario} view):</strong> `; // Added scenario context

        // --- Explain main sinks with more detail ---
        narrativeHTML += `Key capacity reductions include: `;

        // Standard Leave
        const annualUptakePercent = getTeamLeaveUptake(team, 'annual');
        const sickUptakePercent = getTeamLeaveUptake(team, 'sick');
        const annualDefaultDays = getDefaultLeaveDays('annual');
        const sickDefaultDays = getDefaultLeaveDays('sick');
        narrativeHTML += `Standard Leave (<strong>${toFixed(teamBreakdown.stdLeaveYrs)} SDE Yrs</strong>`;
        if (annualUptakePercent !== 100 || sickUptakePercent !== 100) { // Add detail only if not default
             narrativeHTML += `, based on applying team-specific uptake percentages such as ${annualUptakePercent}% for Annual Leave (${annualDefaultDays} default days) and ${sickUptakePercent}% for Sick Leave (${sickDefaultDays} default days) to the default days provided`;
        }
         narrativeHTML += `); `;

        // Variable Leave
        const varLeaveDays = calculateTotalVariableLeaveDays(team);
        narrativeHTML += `Variable Leave impact totalling <strong>${varLeaveDays.toFixed(0)} SDE-Days</strong> (from Maternity, Paternity, Medical, etc. inputs), equivalent to <strong>${toFixed(teamBreakdown.varLeaveYrs)} SDE Yrs</strong>; `;

        // Team Activities
        const teamActivityImpacts = calculateTeamActivityImpacts(team);
        narrativeHTML += `Team Activities impact of <strong>${toFixed(teamBreakdown.teamActivityYrs)} SDE Yrs</strong>`;
        // Optionally list top 1-2 activities contributing
        const topActivities = (team.teamCapacityAdjustments?.teamActivities || [])
            .filter(a => a.value > 0)
            .sort((a, b) => { // Crude sort: prioritize perSDE, then by value
                 if (a.estimateType === 'perSDE' && b.estimateType !== 'perSDE') return -1;
                 if (a.estimateType !== 'perSDE' && b.estimateType === 'perSDE') return 1;
                 return (b.value || 0) - (a.value || 0);
            })
            .slice(0, 2)
            .map(a => `'${a.name}' (${a.value} ${a.estimateType === 'perSDE' ? 'Days/SDE' : 'Total Days'})`)
            .join(', ');
        if (topActivities) {
            narrativeHTML += ` (driven primarily by ${topActivities})`;
        }
         narrativeHTML += `; `;

        // Overhead
        const overheadHrs = team.teamCapacityAdjustments?.avgOverheadHoursPerWeekPerSDE || 0;
        narrativeHTML += `Overhead based on <strong>${overheadHrs.toFixed(1)} Hrs/Wk/SDE</strong> input, converting to an impact of <strong>${toFixed(teamBreakdown.overheadYrs)} SDE Yrs</strong>; `;

        // Global Factors (already covered generally, just acknowledge their inclusion)
        narrativeHTML += `plus the team's share of global Holidays & Org Events. `;

        // Reconciliation Sentence
        const sumOfParts = (teamBreakdown.stdLeaveYrs || 0) + (teamBreakdown.varLeaveYrs || 0) + (teamBreakdown.holidayYrs || 0) + (teamBreakdown.orgEventYrs || 0) + (teamBreakdown.teamActivityYrs || 0) + (teamBreakdown.overheadYrs || 0);
        narrativeHTML += `The sum of these specific deductions reconciles to the total team deduction of <strong>${toFixed(totalSinkYrs)} SDE Yrs</strong> shown. `;


        // --- End Sink Details ---

        // Total Sink
        //narrativeHTML += `In total, this team loses approx. <strong>${totalSinkDays} SDE Days</strong> (<strong>${toFixed(totalSinkYrs)} SDE Yrs</strong>) to these factors in the ${selectedScenario} view. `; // Redundant now with reconciliation

        // Before/After across scenarios
        const netTeamBIS = calculatedMetrics[teamId]?.TeamBIS?.netYrs;
        const netEffectiveBIS = calculatedMetrics[teamId]?.EffectiveBIS?.netYrs;
        const netFundedHC = calculatedMetrics[teamId]?.FundedHC?.netYrs;
        narrativeHTML += `Resulting Net Project Capacity across scenarios: Team BIS = <strong>${toFixed(netTeamBIS)} Yrs</strong>, Effective BIS = <strong>${toFixed(netEffectiveBIS)} Yrs</strong>, Funded HC = <strong>${toFixed(netFundedHC)} Yrs</strong>.</p><hr style='border:none; border-top: 1px solid #eee; margin: 1em 0;'>`; // Add separator

    });

    // --- Final Paragraph: Overall Summary ---
    const totalNetYrs = totals[selectedScenario]?.netYrs || 0;
    narrativeHTML += `<p style="margin-top:1em;"><strong>Overall Summary (${selectedScenario}):</strong> `;
    narrativeHTML += `Summing across all teams for the <strong>${selectedScenario}</strong> scenario, the total Gross Capacity is <strong>${toFixed(totals[selectedScenario]?.grossYrs)} SDE Yrs</strong>. After accounting for all deductions totalling <strong>${toFixed(totals[selectedScenario]?.deductYrs)} SDE Yrs</strong>, the estimated final <strong>Net Project Capacity is ${toFixed(totalNetYrs)} SDE Years</strong> (${toDays(totalNetYrs)} SDE Days).</p>`;

    // --- Display Narrative ---
    narrativeContentContainer.innerHTML = narrativeHTML; // Set the content of the inner div
    console.log("Finished generating enhanced capacity narrative.");
}
// Make global if needed for direct calls (though usually called via updateCapacityCalculationsAndDisplay)
window.generateCapacityNarrative = generateCapacityNarrative;

/**
 * FINAL (Phase 7d - Waterfall Chart Implementation) - Generates the Capacity Waterfall Chart.
 * Includes dynamic container creation, collapsible behavior, Org View, and Chart.js rendering.
 * @param {object} calculatedMetrics - The object returned by calculateAllCapacityMetrics.
 * @param {string} selectedScenario - The key of the currently selected scenario ('TeamBIS', 'EffectiveBIS', 'FundedHC').
 */
function generateCapacityWaterfallChart(calculatedMetrics, selectedScenario) {
    console.log(`Generating Capacity Waterfall Chart section for scenario: ${selectedScenario}...`);

    const ORG_VIEW_ID = '__ORG_VIEW__'; // Identifier for Org View

    let chartContainer = document.getElementById('capacityChartContainer');
    const mainContainer = document.getElementById('capacityConfigView');
    const narrativeSection = document.getElementById('capacityNarrativeSection');
    const summarySection = document.getElementById('capacitySummarySection');

    // --- Ensure Chart Container Exists ---
    if (!chartContainer) {
        if (!mainContainer) {
            console.error("Main container #capacityConfigView not found."); return;
        }
        console.log("Creating chart container dynamically (collapsible)...");
        chartContainer = document.createElement('div');
        chartContainer.id = 'capacityChartContainer';
        chartContainer.style.marginTop = '20px';
        chartContainer.style.border = '1px solid #ccc';
        chartContainer.style.backgroundColor = '#f8f9fa';

        const chartHeader = document.createElement('h3');
        chartHeader.id = 'chartHeader';
        chartHeader.style.margin = '0'; chartHeader.style.padding = '10px 15px';
        chartHeader.style.cursor = 'pointer'; chartHeader.style.backgroundColor = '#e9ecef';
        chartHeader.style.borderBottom = '1px solid rgb(224, 224, 224)';
        chartHeader.title = 'Click to expand/collapse chart section';
        chartHeader.innerHTML = `<span class="toggle-indicator" id="chartToggleIndicator" style="font-weight:bold; margin-right:5px;">[+] </span>Capacity Visualization (Waterfall)`;
        chartContainer.appendChild(chartHeader);

        const chartContent = document.createElement('div');
        chartContent.id = 'chartContent';
        chartContent.style.padding = '15px'; chartContent.style.display = 'none'; // Start collapsed
        chartContainer.appendChild(chartContent); // Add content div

        const canvasElement = document.createElement('canvas');
        canvasElement.id = 'capacityWaterfallChart';
        canvasElement.style.width = '100%'; canvasElement.style.maxHeight = '450px';
        chartContent.appendChild(canvasElement);

        const teamSelectorDiv = document.createElement('div');
        teamSelectorDiv.id = 'chartTeamSelector';
        teamSelectorDiv.style.textAlign = 'center'; teamSelectorDiv.style.marginTop = '10px';
        teamSelectorDiv.innerHTML = `<p><i>Select a view:</i></p>`;
        chartContent.appendChild(teamSelectorDiv);

        chartHeader.onclick = () => { /* ... (toggle logic remains same) ... */
            const contentDiv = chartContainer.querySelector('#chartContent');
            const indicatorSpan = chartHeader.querySelector('#chartToggleIndicator');
            if (contentDiv && indicatorSpan) {
                const isHidden = contentDiv.style.display === 'none';
                contentDiv.style.display = isHidden ? 'block' : 'none';
                indicatorSpan.textContent = isHidden ? '[-] ' : '[+] ';
            }
        };

        // Append container
        if (narrativeSection && narrativeSection.parentNode === mainContainer) {
            narrativeSection.insertAdjacentElement('afterend', chartContainer);
        } else if (summarySection && summarySection.parentNode === mainContainer) {
            summarySection.insertAdjacentElement('afterend', chartContainer);
        } else {
            mainContainer.appendChild(chartContainer);
        }
    } else {
        chartContainer.style.display = 'block';
    }

    // --- Get references ---
    const teamSelectorContainer = document.getElementById('chartTeamSelector');
    const canvas = document.getElementById('capacityWaterfallChart');
    const chartContentDiv = document.getElementById('chartContent'); // Get content div

    if (!teamSelectorContainer || !canvas || !chartContentDiv) {
        console.error("Chart inner elements not found."); return;
    }

    // --- Populate View Selector Buttons ---
    teamSelectorContainer.innerHTML = '<strong style="margin-right: 10px;">Select View:</strong>';
    if (typeof currentChartTeamId === 'undefined') { currentChartTeamId = ORG_VIEW_ID; } // Ensure default

    // Org View Button
    const orgButton = document.createElement('button'); /* ... (button creation logic remains same) ... */
    orgButton.textContent = 'Org View'; orgButton.type = 'button';
    orgButton.style.cssText = `padding: 3px 8px; margin: 0 5px 5px 0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 0.85em;`;
    if (currentChartTeamId === ORG_VIEW_ID) { orgButton.style.backgroundColor = '#007bff'; orgButton.style.color = 'white'; orgButton.style.fontWeight = 'bold'; }
    else { orgButton.style.backgroundColor = '#e9ecef'; orgButton.style.color = '#495057'; }
    orgButton.onclick = () => { currentChartTeamId = ORG_VIEW_ID; generateCapacityWaterfallChart(calculatedMetrics, selectedScenario); };
    teamSelectorContainer.appendChild(orgButton);

    // Team Buttons
    if (currentSystemData && currentSystemData.teams && currentSystemData.teams.length > 0) {
        currentSystemData.teams.forEach(team => {
            const button = document.createElement('button'); /* ... (button creation logic remains same) ... */
             button.textContent = team.teamIdentity || team.teamName; button.type = 'button';
             button.style.cssText = `padding: 3px 8px; margin: 0 5px 5px 0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 0.85em;`;
             if (team.teamId === currentChartTeamId) { button.style.backgroundColor = '#007bff'; button.style.color = 'white'; button.style.fontWeight = 'bold'; }
             else { button.style.backgroundColor = '#e9ecef'; button.style.color = '#495057'; }
             button.onclick = () => { currentChartTeamId = team.teamId; generateCapacityWaterfallChart(calculatedMetrics, selectedScenario); };
             teamSelectorContainer.appendChild(button);
        });
    }

    // --- Chart Generation Logic ---
    console.log(`Generating chart for view: ${currentChartTeamId === ORG_VIEW_ID ? 'Org View' : currentChartTeamId}`);

    // Destroy previous chart instance
    if (capacityChartInstance) {
        capacityChartInstance.destroy();
        capacityChartInstance = null;
    }

    // Determine data source and label
    let viewData;
    let viewLabel;
    if (currentChartTeamId === ORG_VIEW_ID) {
        viewData = calculatedMetrics.totals?.[selectedScenario];
        viewLabel = 'Organization Total';
    } else {
        viewData = calculatedMetrics[currentChartTeamId]?.[selectedScenario];
        viewLabel = getTeamNameById(currentChartTeamId);
    }

    // Check if data exists
    if (!viewData || !viewData.deductionsBreakdown) {
        console.warn(`No metrics/breakdown found for view ${currentChartTeamId} and scenario ${selectedScenario}. Cannot generate chart.`);
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = '16px Arial'; ctx.fillStyle = '#666'; ctx.textAlign = 'center';
        ctx.fillText(`No data available for ${viewLabel} (${selectedScenario})`, canvas.width / 2, 50);
        return;
    }

    // --- Prepare Waterfall Data ---
    const labels = ['Gross', 'Holidays', 'Org Events', 'Std Leave', 'Var Leave', 'Activities', 'Overhead', 'Net Project'];
    const dataValues = [];
    const colors = [];
    const borderColors = [];

    const grossYrs = viewData.grossYrs || 0;
    const holidayYrs = viewData.deductionsBreakdown.holidayYrs || 0;
    const orgEventYrs = viewData.deductionsBreakdown.orgEventYrs || 0;
    const stdLeaveYrs = viewData.deductionsBreakdown.stdLeaveYrs || 0;
    const varLeaveYrs = viewData.deductionsBreakdown.varLeaveYrs || 0;
    const activityYrs = viewData.deductionsBreakdown.teamActivityYrs || 0; // Ensure correct key
    const overheadYrs = viewData.deductionsBreakdown.overheadYrs || 0;
    const netYrs = viewData.netYrs || 0;

    let currentLevel = 0;

    // Gross Capacity Bar (Positive)
    dataValues.push([currentLevel, grossYrs]);
    colors.push('rgba(75, 192, 192, 0.6)'); // Greenish
    borderColors.push('rgba(75, 192, 192, 1)');
    currentLevel = grossYrs;

    // Deduction Bars (Negative impact visually shown by starting point)
    const deductions = [holidayYrs, orgEventYrs, stdLeaveYrs, varLeaveYrs, activityYrs, overheadYrs];
    const deductionColors = [
        'rgba(255, 99, 132, 0.6)', // Red
        'rgba(255, 159, 64, 0.6)', // Orange
        'rgba(255, 205, 86, 0.6)', // Yellow
        'rgba(153, 102, 255, 0.6)', // Purple
        'rgba(201, 203, 207, 0.6)', // Grey
        'rgba(54, 162, 235, 0.6)' // Blue
    ];
    deductions.forEach((deduction, index) => {
        if (typeof deduction !== 'number' || isNaN(deduction) || deduction === 0) {
            // Skip zero or invalid deductions visually, or represent as 0 height bar?
             // Let's represent as [currentLevel, currentLevel] to keep label alignment
              dataValues.push([currentLevel, currentLevel]);
        } else {
             dataValues.push([currentLevel, currentLevel - deduction]);
             currentLevel -= deduction;
        }
         colors.push(deductionColors[index % deductionColors.length]); // Cycle colors if needed
         borderColors.push(deductionColors[index % deductionColors.length].replace('0.6', '1')); // Solid border
    });

    // Net Project Capacity Bar (Positive, starts from 0)
    dataValues.push([0, netYrs]);
    colors.push('rgba(75, 192, 192, 0.6)'); // Greenish
    borderColors.push('rgba(75, 192, 192, 1)');

    // --- Configure Chart.js ---
    const config = {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: `Capacity (SDE Years) - ${viewLabel} (${selectedScenario})`,
                data: dataValues,
                backgroundColor: colors,
                borderColor: borderColors,
                borderWidth: 1,
                barPercentage: 0.8, // Adjust bar width
                categoryPercentage: 0.9 // Adjust spacing between bars
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false, // Allow height to adjust
            indexAxis: 'x', // Waterfall typically vertical bars
            scales: {
                x: {
                    grid: { display: false } // Cleaner look
                },
                y: {
                    beginAtZero: true, // Start y-axis at zero
                    title: {
                        display: true,
                        text: 'Capacity (SDE Years)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false // Legend not very useful for waterfall
                },
                title: {
                    display: true,
                    text: `Capacity Waterfall: ${viewLabel} (${selectedScenario})`,
                    padding: { top: 10, bottom: 15 },
                    font: { size: 16 }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            let label = context.dataset.label || '';
                            if (label) { label += ': '; }
                            if (Array.isArray(value) && value.length === 2) {
                                const start = value[0];
                                const end = value[1];
                                const change = end - start;
                                // For deductions, show the negative change; for Gross/Net show the total
                                if (context.label === 'Gross' || context.label === 'Net Project') {
                                     label += `${end.toFixed(2)} SDE Yrs`;
                                } else {
                                     label += `${change.toFixed(2)} SDE Yrs`;
                                }

                            }
                            return label;
                        }
                    }
                }
            }
        }
    };

    // --- Create the Chart ---
    const ctx = canvas.getContext('2d');
    capacityChartInstance = new Chart(ctx, config); // Store instance

    console.log("Waterfall chart generated successfully.");
}
// Make global if needed
window.generateCapacityWaterfallChart = generateCapacityWaterfallChart;

// Helper to get team name (you might already have this or similar)
function getTeamNameById(teamId) {
    if (!currentSystemData || !currentSystemData.teams) return teamId; // Fallback
    const team = currentSystemData.teams.find(t => t.teamId === teamId);
    return team ? (team.teamIdentity || team.teamName) : teamId;
}

/**
 * REVISED Function (Phase 4b - SIMPLIFIED Team Activities UI)
 * - Removes Participation % column from Team Activities table.
 * - Clarifies 'Value' input meaning via tooltips based on 'Est. Type'.
 * - Includes previous functionality (Collapsible, Leave Uptake %, Variable Leave).
 */
function generateTeamConstraintsForms() {
    console.log("Generating Team Constraints Forms (Phase 4b - Simplified Activities)...");
    const container = document.getElementById('capacityConfigView');
    // --- Null checks ---
    if (!container) { console.error("Container #capacityConfigView not found."); return; }
    if (!currentSystemData || !currentSystemData.teams || !currentSystemData.capacityConfiguration?.leaveTypes) { console.error("Missing teams or global leaveTypes data."); /* Error display */ return; }

    // --- Find/create main container ---
    let teamsSection = document.getElementById('teamConstraintsSection');
    if (!teamsSection) { /* ... Create teamsSection ... */
        teamsSection = document.createElement('div'); teamsSection.id = 'teamConstraintsSection'; teamsSection.style.border = '1px solid #ccc'; teamsSection.style.padding = '15px'; teamsSection.style.marginTop = '20px'; const teamsTitle = document.createElement('h3'); teamsTitle.textContent = 'Team-Specific Adjustments'; teamsSection.appendChild(teamsTitle); container.appendChild(teamsSection);
    } else { const teamContainers = teamsSection.querySelectorAll('.team-constraint-container'); teamContainers.forEach(tc => tc.remove()); }

    const teams = currentSystemData.teams || [];
    const globalLeaveTypes = currentSystemData.capacityConfiguration.leaveTypes || [];

    // --- Helper: Update Total Standard Leave Display (no change) ---
    const updateTotalStdLeaveDisplay = (teamIndex) => { /* ... function code from previous version ... */
        const teamContainer = document.getElementById(`teamConstraintContainer_${teamIndex}`); if (!teamContainer) return; const totalDisplayElement = teamContainer.querySelector('.total-std-leave-display'); if (!totalDisplayElement) return; const team = currentSystemData.teams[teamIndex]; if (!team?.teamCapacityAdjustments?.leaveUptakeEstimates) return; let totalEffectiveDays = 0; globalLeaveTypes.forEach(leaveType => { if (!leaveType || !leaveType.id) return; const currentGlobalDefaultObj = currentSystemData.capacityConfiguration.leaveTypes.find(lt => lt.id === leaveType.id); const globalDefault = currentGlobalDefaultObj ? (currentGlobalDefaultObj.defaultEstimatedDays || 0) : 0; const teamUptake = team.teamCapacityAdjustments.leaveUptakeEstimates.find(est => est.leaveTypeId === leaveType.id); const uptakePercent = teamUptake ? (teamUptake.estimatedUptakePercent ?? 100) : 100; totalEffectiveDays += globalDefault * (uptakePercent / 100); }); totalDisplayElement.textContent = totalEffectiveDays.toFixed(1);
    };

    // --- Helper: Update Variable Leave Total Display (no change) ---
     const updateVariableLeaveTotalDisplay = (teamIndex, leaveKey) => { /* ... function code from previous version ... */
         const teamContainer = document.getElementById(`teamConstraintContainer_${teamIndex}`); if (!teamContainer) { console.warn(`updateVariableLeaveTotalDisplay: Cannot find container for team ${teamIndex}`); return; } const totalDisplayElement = teamContainer.querySelector(`.variable-leave-total-display[data-leave-key="${leaveKey}"]`); if (!totalDisplayElement) { console.warn(`updateVariableLeaveTotalDisplay: Cannot find total display span for team ${teamIndex}, key ${leaveKey}`); return; } const team = currentSystemData.teams[teamIndex]; const impact = team?.teamCapacityAdjustments?.variableLeaveImpact?.[leaveKey]; if (impact) { const affectedSDEs = impact.affectedSDEs ?? 0; const avgDays = impact.avgDaysPerAffectedSDE ?? 0; const totalDays = affectedSDEs * avgDays; totalDisplayElement.textContent = totalDays.toFixed(0); } else { totalDisplayElement.textContent = '0'; }
     };

    // --- Helper: Render SIMPLIFIED Team Activities Table ---
    const renderTeamActivitiesTable = (teamIndex, targetContainer) => {
        console.log(`Rendering SIMPLIFIED team activities table for team index ${teamIndex}`);
        targetContainer.innerHTML = ''; // Clear previous table content

        const team = currentSystemData.teams[teamIndex];
        if (!team?.teamCapacityAdjustments?.teamActivities) {
            if (team?.teamCapacityAdjustments) { team.teamCapacityAdjustments.teamActivities = []; }
            else { console.warn("Cannot render activities, missing teamCapacityAdjustments for team:", teamIndex); return; }
        }

        const activitiesTable = document.createElement('table');
        activitiesTable.style.width = '100%'; activitiesTable.style.fontSize = '0.9em'; activitiesTable.style.borderCollapse = 'collapse';
        // *** REMOVED Participation % Header ***
        activitiesTable.innerHTML = `
            <thead style="background-color: #f8f9fa;">
                <tr>
                    <th style="border: 1px solid #ccc; padding: 4px; width: 40%;">Activity Name</th>
                    <th style="border: 1px solid #ccc; padding: 4px; width: 20%;">Type</th>
                    <th style="border: 1px solid #ccc; padding: 4px; width: 20%;" title="Estimate per SDE or as a total for the team">Est. Type</th>
                    <th style="border: 1px solid #ccc; padding: 4px; width: 10%;" title="'Days/SDE' = Enter average days per SDE.\n'Total Team Days' = Enter total days impact for the whole team.">Value</th>
                    <th style="border: 1px solid #ccc; padding: 4px; width: 10%;">Action</th>
                </tr>
            </thead>
            <tbody></tbody>`;
        const activitiesTbody = activitiesTable.querySelector('tbody');

        // Populate Table Rows
        team.teamCapacityAdjustments.teamActivities.forEach((activity, activityIndex) => {
            const row = activitiesTbody.insertRow();
            row.style.borderBottom = '1px solid #eee';

            // Helper to create input/select cells
            const createCell = (elementType = 'input', attributes = {}, styles = {}, options = null) => {
                 const cell = row.insertCell(); const element = document.createElement(elementType); for (const attr in attributes) { element[attr] = attributes[attr]; } for (const style in styles) { element.style[style] = styles[style]; } if (elementType === 'select' && options) { options.forEach(opt => element.add(new Option(opt.text, opt.value))); }
                 element.onchange = (e) => {
                     const field = e.target.name; let value = e.target.value; if (e.target.type === 'number') value = parseFloat(value) || 0;
                     activity[field] = value; console.log(`Updated activity[${activityIndex}].${field} to ${value}`);
                     // Update value tooltip based on Est Type change
                     if (field === 'estimateType') {
                         const valueInput = row.querySelector('input[name="value"]');
                         if(valueInput) valueInput.title = value === 'perSDE' ? 'Enter TOTAL SDE-Days impact (e.g., # SDEs * Duration)' : 'Enter TOTAL calendar days for the activity (applies to whole team)';
                     }
                     updateCapacityCalculationsAndDisplay();
                 };
                 cell.appendChild(element); return element;
             };

            // Create Cells
            createCell('input', { type: 'text', value: activity.name || '', name: 'name', placeholder: 'e.g., AWS Training' }, { width: '95%' });
            createCell('input', { type: 'text', value: activity.type || '', name: 'type', placeholder: 'Optional' }, { width: '90%' });
            createCell('select', { value: activity.estimateType || 'perSDE', name: 'estimateType', title: 'Estimate per SDE or as a total for the team' }, { width: '95%' }, [{ text: 'Days/SDE', value: 'perSDE' }, { text: 'Total Team Days', value: 'total' }]);
            const initialValueTitle = (activity.estimateType === 'total') ? 'Enter TOTAL calendar days for the activity (applies to whole team)' : 'Enter TOTAL SDE-Days impact (e.g., # SDEs * Duration)';
            createCell('input', { type: 'number', value: activity.value || 0, name: 'value', min: '0', step: '0.5', title: initialValueTitle }, { width: '70px', textAlign: 'right' });
            // *** REMOVED Participation % Input Cell Creation ***

            // Action Cell (Remove)
            const actionCell = row.insertCell(); actionCell.style.textAlign = 'center';
            const removeBtn = document.createElement('button');
             removeBtn.textContent = 'X'; removeBtn.title = 'Remove Activity'; removeBtn.style.color = 'red'; removeBtn.style.fontSize = '0.8em'; removeBtn.style.padding = '1px 4px';
            removeBtn.onclick = () => {
                team.teamCapacityAdjustments.teamActivities.splice(activityIndex, 1);
                renderTeamActivitiesTable(teamIndex, targetContainer); // Re-render this specific table
                updateCapacityCalculationsAndDisplay();
            };
            actionCell.appendChild(removeBtn);
        }); // end forEach activity

        targetContainer.appendChild(activitiesTable); // Add table to container

        // Add "Add Activity" Button
        const addActivityBtn = document.createElement('button');
         addActivityBtn.textContent = 'Add Team Activity'; addActivityBtn.style.marginTop = '5px';
        addActivityBtn.onclick = () => {
            if (!team.teamCapacityAdjustments.teamActivities) team.teamCapacityAdjustments.teamActivities = [];
            // *** Add new activity WITHOUT participationPercent ***
            team.teamCapacityAdjustments.teamActivities.push({
                id: `act-${teamIndex}-${Date.now()}`, name: '', type: '', estimateType: 'perSDE', value: 0
                // participationPercent removed
            });
            renderTeamActivitiesTable(teamIndex, targetContainer); // Re-render table
        };
        targetContainer.appendChild(addActivityBtn);
    };
    // --- *** END Render Team Activities Table Helper *** ---

    // --- Helper Function to RENDER DETAILS for a single team ---
    const renderTeamConstraintDetails = (teamIndex, detailsContainer) => {
        console.log(`Rendering details for team index ${teamIndex}`);
        detailsContainer.innerHTML = ''; // Clear previous content
        const team = currentSystemData.teams[teamIndex]; if (!team) return;
        // --- Ensure data structures exist ---
         if (!team.teamCapacityAdjustments) { team.teamCapacityAdjustments = { leaveUptakeEstimates: [], variableLeaveImpact: { maternity: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }, paternity: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }, familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }, medical: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }}, teamActivities: [], recurringOverhead: [] }; } else { if (!team.teamCapacityAdjustments.leaveUptakeEstimates) team.teamCapacityAdjustments.leaveUptakeEstimates = []; if (!team.teamCapacityAdjustments.variableLeaveImpact) team.teamCapacityAdjustments.variableLeaveImpact = { maternity: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }, paternity: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }, familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }, medical: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }}; if (!team.teamCapacityAdjustments.teamActivities) team.teamCapacityAdjustments.teamActivities = []; if (!team.teamCapacityAdjustments.recurringOverhead) team.teamCapacityAdjustments.recurringOverhead = []; const varLeave = team.teamCapacityAdjustments.variableLeaveImpact; if (!varLeave.maternity) varLeave.maternity = { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }; if (!varLeave.paternity) varLeave.paternity = { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }; if (!varLeave.familyResp) varLeave.familyResp = { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }; if (!varLeave.medical) varLeave.medical = { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }; }

        // --- Standard Leave Estimates Section (%) ---
        // ... (Standard Leave UI generation - No change, uses simplified table) ...
         const stdLeaveTitle = document.createElement('h5'); stdLeaveTitle.textContent = 'Standard Leave Uptake Estimate (%)'; stdLeaveTitle.style.marginTop = '10px'; stdLeaveTitle.title = 'Estimate % of Org Default leave days taken per SDE (e.g., 80%). Blank=100%. Affects Annual, Sick, Study, etc.'; detailsContainer.appendChild(stdLeaveTitle); const stdLeaveTable = document.createElement('table'); stdLeaveTable.style.marginLeft = '20px'; stdLeaveTable.style.width = 'auto';
         stdLeaveTable.innerHTML = `<thead> <tr> <th style="text-align: left; padding: 4px 8px;">Leave Type</th> <th style="text-align: center; padding: 4px 8px;" title="Estimated % uptake for this team (0-100). Blank=100%">Team Uptake (%)</th> <th style="text-align: center; padding: 4px 8px;" title="Calculated Effective Days/SDE (Default * Uptake %)">Effective Days/SDE</th> </tr> </thead> <tbody></tbody>`;
         const stdLeaveTbody = stdLeaveTable.querySelector('tbody'); detailsContainer.appendChild(stdLeaveTable); const totalStdLeaveDiv = document.createElement('div'); totalStdLeaveDiv.style.marginLeft = '20px'; totalStdLeaveDiv.style.marginTop = '5px'; totalStdLeaveDiv.style.fontWeight = 'bold'; totalStdLeaveDiv.innerHTML = `Total Avg. Standard Leave Days/SDE: <span class="total-std-leave-display">0.0</span>`; detailsContainer.appendChild(totalStdLeaveDiv);
         let teamTotalAvgStdLeave = 0;
         globalLeaveTypes.forEach(leaveType => {
             if (!leaveType || !leaveType.id) return;
             const currentGlobalDefaultObj = currentSystemData.capacityConfiguration.leaveTypes.find(lt => lt.id === leaveType.id); const globalDefault = currentGlobalDefaultObj ? (currentGlobalDefaultObj.defaultEstimatedDays || 0) : 0;
             const teamUptakeObj = team.teamCapacityAdjustments.leaveUptakeEstimates.find(est => est.leaveTypeId === leaveType.id); const teamUptakePercentValue = teamUptakeObj ? (teamUptakeObj.estimatedUptakePercent ?? '') : ''; const displayUptakePercent = teamUptakeObj ? (teamUptakeObj.estimatedUptakePercent ?? 100) : 100; const effectiveDays = globalDefault * (displayUptakePercent / 100); teamTotalAvgStdLeave += effectiveDays;
             const row = stdLeaveTbody.insertRow(); row.insertCell().textContent = leaveType.name;
             const percentCell = row.insertCell(); percentCell.style.textAlign = 'center'; const percentInput = document.createElement('input'); percentInput.type = 'number'; percentInput.min = '0'; percentInput.max = '100'; percentInput.step = '5'; percentInput.value = teamUptakePercentValue; percentInput.placeholder = '100'; percentInput.style.width = '60px'; percentInput.style.textAlign = 'center'; percentInput.title = `Enter % uptake (0-100) for ${leaveType.name}. Blank means 100% of default: ${globalDefault}`; percentInput.setAttribute('data-leave-type-id', leaveType.id); percentInput.setAttribute('data-team-index', teamIndex); const effectiveDaysCell = row.insertCell(); effectiveDaysCell.id = `effectiveDays_${teamIndex}_${leaveType.id}`; effectiveDaysCell.textContent = effectiveDays.toFixed(1); effectiveDaysCell.style.textAlign = 'center'; effectiveDaysCell.style.fontWeight = 'bold';
              percentInput.addEventListener('change', (e) => {
                  const inputVal = e.target.value.trim();
                  const lTypeId = e.target.getAttribute('data-leave-type-id');
                  const tIdx = parseInt(e.target.getAttribute('data-team-index'));
                  const targetTeam = currentSystemData.teams[tIdx];
                  if (!targetTeam?.teamCapacityAdjustments?.leaveUptakeEstimates) return;
              
                  const estimateIndex = targetTeam.teamCapacityAdjustments.leaveUptakeEstimates.findIndex(est => est.leaveTypeId === lTypeId);
                  let validatedPercent = 100; // Default to 100%
              
                  // Validate input and update data model
                  if (inputVal !== '') {
                      const numericVal = parseInt(inputVal);
                      if (!isNaN(numericVal) && numericVal >= 0 && numericVal <= 100) {
                          validatedPercent = numericVal;
                      } else {
                          // Revert to previous value if invalid
                          const previousEstimate = (estimateIndex > -1) ? targetTeam.teamCapacityAdjustments.leaveUptakeEstimates[estimateIndex] : null;
                          e.target.value = previousEstimate ? (previousEstimate.estimatedUptakePercent ?? '') : ''; // Revert visual input
                          // Use previous % or default 100% for calculation this time
                          validatedPercent = previousEstimate ? (previousEstimate.estimatedUptakePercent ?? 100) : 100;
                      }
                  }
              
                  // Update the data structure based on validated percent
                  if (inputVal === '' || validatedPercent === 100) {
                      // If input is empty or 100%, ensure no specific entry exists for this leave type
                      if (estimateIndex > -1) {
                          targetTeam.teamCapacityAdjustments.leaveUptakeEstimates.splice(estimateIndex, 1);
                          console.log(`Removed leave uptake entry for team ${tIdx}, type ${lTypeId}`);
                      }
                      e.target.value = ''; // Keep input visually empty for 100% default
                      validatedPercent = 100; // Ensure 100 is used for current calculation cycle
                  } else {
                      // If a specific percentage (not 100) is entered
                      if (estimateIndex > -1) {
                          // Update existing entry
                          targetTeam.teamCapacityAdjustments.leaveUptakeEstimates[estimateIndex].estimatedUptakePercent = validatedPercent;
                          console.log(`Updated leave uptake for team ${tIdx}, type ${lTypeId} to ${validatedPercent}%`);
                      } else {
                          // Add new entry if it didn't exist
                          targetTeam.teamCapacityAdjustments.leaveUptakeEstimates.push({ leaveTypeId: lTypeId, estimatedUptakePercent: validatedPercent });
                          console.log(`Added leave uptake for team ${tIdx}, type ${lTypeId} as ${validatedPercent}%`);
                      }
                      e.target.value = validatedPercent; // Update input visually to the validated number
                  }
              
                  // Update the 'Effective Days/SDE' cell next to the input
                  const currentDefaultObj = currentSystemData.capacityConfiguration.leaveTypes.find(lt => lt.id === lTypeId);
                  const currentDefaultVal = currentDefaultObj ? (currentDefaultObj.defaultEstimatedDays || 0) : 0;
                  const effectiveCell = document.getElementById(`effectiveDays_${tIdx}_${lTypeId}`);
                  if (effectiveCell) effectiveCell.textContent = (currentDefaultVal * (validatedPercent / 100)).toFixed(1);
              
                  // Update the total display for standard leave
                  updateTotalStdLeaveDisplay(tIdx);
              
                  // --- Explicitly find the current scenario ---
                  let currentScenario = 'EffectiveBIS'; // Default assumption
                  const capacityButtonsDiv = document.getElementById('capacityScenarioButtons');
                  if (capacityButtonsDiv) {
                       const activeButton = capacityButtonsDiv.querySelector('button[style*="background-color: #007bff"]'); // Find the blue button
                       if (activeButton) {
                           const onclickText = activeButton.getAttribute('onclick');
                           if (onclickText && onclickText.includes('updateCapacityCalculationsAndDisplay(\'TeamBIS\')')) {
                               currentScenario = 'TeamBIS';
                           } else if (onclickText && onclickText.includes('updateCapacityCalculationsAndDisplay(\'FundedHC\')')) {
                               currentScenario = 'FundedHC';
                           }
                           // Otherwise, it remains 'EffectiveBIS'
                       } else {
                           console.warn("Could not find active scenario button, defaulting to EffectiveBIS.");
                       }
                   } else {
                       console.warn("Could not find capacity scenario buttons container, defaulting to EffectiveBIS.");
                   }
                  // --- End Find current scenario ---
              
                  // Call the main update function, PASSING the determined scenario
                  console.log(`Triggering capacity update from leave uptake change. Scenario: ${currentScenario}`);
                  updateCapacityCalculationsAndDisplay(currentScenario);
              });              
              percentCell.appendChild(percentInput);
         });
         const totalDisplaySpan = totalStdLeaveDiv.querySelector('.total-std-leave-display'); if(totalDisplaySpan) totalDisplaySpan.textContent = teamTotalAvgStdLeave.toFixed(1);
        // --- End Standard Leave Section ---

        // --- Variable Leave Estimates Section ---
        // ... (Variable Leave UI generation - No change) ...
         const varLeaveTitle = document.createElement('h5'); varLeaveTitle.textContent = 'Variable Leave Impact Estimate'; varLeaveTitle.style.marginTop = '15px'; varLeaveTitle.title = 'Estimate the total impact ON THE TEAM for variable leave (Maternity, Paternity, etc.). Enter # SDEs affected and Avg Days/SDE for each.'; detailsContainer.appendChild(varLeaveTitle); const varLeaveContainer = document.createElement('div'); varLeaveContainer.style.marginLeft = '20px';
         const handleVariableLeaveInputChange = (e) => { const input = e.target; const tIdx = parseInt(input.getAttribute('data-team-index')); const leaveKey = input.getAttribute('data-leave-key'); const field = input.getAttribute('data-field'); const targetTeam = currentSystemData.teams[tIdx]; if (!targetTeam?.teamCapacityAdjustments?.variableLeaveImpact?.[leaveKey] || !field) return; const value = parseInt(input.value); const validatedValue = (!isNaN(value) && value >= 0) ? value : 0; targetTeam.teamCapacityAdjustments.variableLeaveImpact[leaveKey][field] = validatedValue; input.value = validatedValue; console.log(`Updated ${leaveKey}.${field} for team ${tIdx} to ${validatedValue}`); updateVariableLeaveTotalDisplay(tIdx, leaveKey); updateCapacityCalculationsAndDisplay();};
         const createVarLeaveInputRow = (targetTeam, leaveKey, labelText) => { const div = document.createElement('div'); div.style.marginBottom = '5px'; div.style.display = 'flex'; div.style.alignItems = 'center'; const label = document.createElement('label'); label.textContent = `${labelText}: `; label.style.width = '180px'; label.style.marginRight = '10px'; div.appendChild(label); const sdesInput = document.createElement('input'); sdesInput.type = 'number'; sdesInput.min = '0'; sdesInput.step = '1'; sdesInput.value = targetTeam.teamCapacityAdjustments.variableLeaveImpact[leaveKey]?.affectedSDEs || 0; sdesInput.style.width = '60px'; sdesInput.style.marginRight = '5px'; sdesInput.title = '# SDEs Affected'; sdesInput.setAttribute('data-team-index', teamIndex); sdesInput.setAttribute('data-leave-key', leaveKey); sdesInput.setAttribute('data-field', 'affectedSDEs'); sdesInput.addEventListener('change', handleVariableLeaveInputChange); div.appendChild(sdesInput); div.appendChild(document.createTextNode(' SDEs * ')); const daysInput = document.createElement('input'); daysInput.type = 'number'; daysInput.min = '0'; daysInput.step = '1'; daysInput.value = targetTeam.teamCapacityAdjustments.variableLeaveImpact[leaveKey]?.avgDaysPerAffectedSDE || 0; daysInput.style.width = '60px'; daysInput.style.marginRight = '10px'; daysInput.title = 'Avg. Days per Affected SDE'; daysInput.setAttribute('data-team-index', teamIndex); daysInput.setAttribute('data-leave-key', leaveKey); daysInput.setAttribute('data-field', 'avgDaysPerAffectedSDE'); daysInput.addEventListener('change', handleVariableLeaveInputChange); div.appendChild(daysInput); div.appendChild(document.createTextNode(' Days/SDE = ')); const totalDisplay = document.createElement('span'); totalDisplay.className = 'variable-leave-total-display'; totalDisplay.setAttribute('data-leave-key', leaveKey); totalDisplay.style.fontWeight = 'bold'; totalDisplay.style.minWidth = '40px'; totalDisplay.style.display = 'inline-block'; const initialTotal = (sdesInput.valueAsNumber || 0) * (daysInput.valueAsNumber || 0); totalDisplay.textContent = initialTotal.toFixed(0); div.appendChild(totalDisplay); div.appendChild(document.createTextNode(' Total SDE Days')); return div; };
         varLeaveContainer.appendChild(createVarLeaveInputRow(team, 'maternity', 'Maternity Leave')); varLeaveContainer.appendChild(createVarLeaveInputRow(team, 'paternity', 'Paternity Leave')); varLeaveContainer.appendChild(createVarLeaveInputRow(team, 'familyResp', 'Family Responsibility')); varLeaveContainer.appendChild(createVarLeaveInputRow(team, 'medical', 'Medical Leave')); detailsContainer.appendChild(varLeaveContainer);
        // --- End Variable Leave Section ---

        // --- Team Activities Section (Phase 4b Implementation) ---
        const activitiesTitle = document.createElement('h5');
        activitiesTitle.textContent = 'Team Activities (Training, Conferences, etc.)';
        activitiesTitle.style.marginTop = '15px';
        activitiesTitle.title = 'Estimate impact of non-recurring team-specific activities.';
        detailsContainer.appendChild(activitiesTitle);
        const activitiesContainer = document.createElement('div');
        activitiesContainer.style.marginLeft = '20px';
        activitiesContainer.id = `teamActivitiesContainer_${teamIndex}`;
        renderTeamActivitiesTable(teamIndex, activitiesContainer); // Call the helper
        detailsContainer.appendChild(activitiesContainer);
        // --- END Team Activities Section ---

        // --- *** NEW: Recurring Overhead Section (Phase 4c) *** ---
        const overheadTitle = document.createElement('h5');
        overheadTitle.textContent = 'Recurring Overhead (Meetings, etc.)';
        overheadTitle.style.marginTop = '15px';
        detailsContainer.appendChild(overheadTitle);

        const overheadContainer = document.createElement('div');
        overheadContainer.style.marginLeft = '20px';

        const overheadLabel = document.createElement('label');
        overheadLabel.htmlFor = `avgOverheadHrs_${teamIndex}`;
        overheadLabel.textContent = 'Avg. Overhead (Hrs/Week/SDE): ';
        overheadLabel.title = 'Estimate the average hours PER SDE PER WEEK spent on ALL recurring activities (standups, planning, retros, 1:1s, syncs, admin, etc.)';
        overheadLabel.style.display = 'inline-block';
        overheadLabel.style.marginRight = '10px';

        const overheadInput = document.createElement('input');
        overheadInput.type = 'number';
        overheadInput.id = `avgOverheadHrs_${teamIndex}`;
        overheadInput.min = '0';
        overheadInput.step = '0.5'; // Allow half hours
        overheadInput.value = team.teamCapacityAdjustments.avgOverheadHoursPerWeekPerSDE || 0;
        overheadInput.style.width = '70px';
        overheadInput.dataset.originalTitle = overheadLabel.title; // Store original title        
        overheadInput.setAttribute('data-team-index', teamIndex);

        overheadInput.addEventListener('change', (e) => {
            const tIdx = parseInt(e.target.getAttribute('data-team-index'));
            const targetTeam = currentSystemData.teams[tIdx];
            if (!targetTeam?.teamCapacityAdjustments) return;
        
            const value = parseFloat(e.target.value);
            const validatedValue = (!isNaN(value) && value >= 0) ? value : 0;
            let warningMsg = ''; // Initialize warning message
        
            targetTeam.teamCapacityAdjustments.avgOverheadHoursPerWeekPerSDE = validatedValue;
            // Display with one decimal place, but store the potentially more precise value
            e.target.value = validatedValue.toFixed(1);
            console.log(`Updated avgOverheadHoursPerWeekPerSDE for team ${tIdx} to ${validatedValue}`);
        
            // --- Sanity Check ---
            if (validatedValue > 40) { // Example sanity check
                warningMsg = 'Value exceeds 40 Hrs/Week/SDE. Is this realistic?';
            }
            // --- End Sanity Check ---
        
            updateInputWarning(e.target, warningMsg); // Update warning display
            updateCapacityCalculationsAndDisplay();
        });

        overheadContainer.appendChild(overheadLabel);
        overheadContainer.appendChild(overheadInput);
        detailsContainer.appendChild(overheadContainer);
        // Initial check on load
        updateInputWarning(overheadInput, (parseFloat(overheadInput.value) > 40) ? 'Value exceeds 40 Hrs/Week/SDE. Is this realistic?' : '');        
        // --- *** END Recurring Overhead Section *** ---
        // --- End Placeholders ---

    }; // --- End renderTeamConstraintDetails ---

    // --- Iterate Through Teams and Setup Collapsible (No change) ---
    teams.forEach((team, teamIndex) => {
        if (!team || !team.teamId) return;
        const teamContainer = document.createElement('div'); /* ... Container setup ... */ teamContainer.id = `teamConstraintContainer_${teamIndex}`; teamContainer.className = 'team-constraint-container'; teamContainer.style.borderTop = '1px solid #ccc'; teamContainer.style.paddingTop = '10px'; teamContainer.style.marginTop = '10px'; const teamHeader = document.createElement('h4'); /* ... Header setup ... */ teamHeader.style.cursor = 'pointer'; teamHeader.style.backgroundColor = '#f8f9fa'; teamHeader.style.padding = '8px'; teamHeader.style.margin = '0'; teamHeader.title = `Click to expand/collapse settings for ${team.teamName || team.teamIdentity}`; const indicator = document.createElement('span'); indicator.id = `teamConstraintToggle_${teamIndex}`; indicator.className = 'toggle-indicator'; indicator.innerText = '(+) '; indicator.style.fontWeight = 'bold'; indicator.style.marginRight = '5px'; teamHeader.appendChild(indicator); teamHeader.appendChild(document.createTextNode(`Team: ${team.teamIdentity || team.teamName || team.teamId}`)); teamContainer.appendChild(teamHeader); const teamDetails = document.createElement('div'); /* ... Details div setup ... */ teamDetails.id = `teamConstraintContent_${teamIndex}`; teamDetails.style.display = 'none'; teamDetails.style.padding = '10px'; teamDetails.style.border = '1px solid #eee'; teamDetails.style.borderTop = 'none';
        teamHeader.onclick = () => { /* ... OnClick Handler (no change) ... */
             const contentDiv = teamDetails; const indicatorSpan = indicator; const isHidden = contentDiv.style.display === 'none' || contentDiv.style.display === ''; if (isHidden) { renderTeamConstraintDetails(teamIndex, contentDiv); contentDiv.style.display = 'block'; indicatorSpan.textContent = '(-)'; } else { contentDiv.style.display = 'none'; indicatorSpan.textContent = '(+)'; contentDiv.innerHTML = ''; }
         };
        teamContainer.appendChild(teamDetails); teamsSection.appendChild(teamContainer);
    }); // --- End teams.forEach ---

    // --- Placeholder for Overall Summary Section (no change) ---
    let summarySection = document.getElementById('capacitySummarySection'); /* ... Placeholder setup ... */
     if (!summarySection) { summarySection = document.createElement('div'); summarySection.id = 'capacitySummarySection'; summarySection.style.border = '1px solid #666'; summarySection.style.backgroundColor = '#f0f0f0'; summarySection.style.padding = '15px'; summarySection.style.marginTop = '20px'; const summaryTitle = document.createElement('h3'); summaryTitle.textContent = 'Calculated Net Project Capacity Summary'; summarySection.appendChild(summaryTitle); const summaryPlaceholder = document.createElement('p'); summaryPlaceholder.id = 'capacitySummaryPlaceholder'; summaryPlaceholder.textContent = '[Summary table with calculations will be added in Phase 5]'; summaryPlaceholder.style.fontStyle = 'italic'; summarySection.appendChild(summaryPlaceholder); container.appendChild(summarySection); } else { const placeholder = summarySection.querySelector('#capacitySummaryPlaceholder'); if (placeholder) placeholder.style.display = 'block'; const table = summarySection.querySelector('table'); if(table) table.style.display = 'none'; }

     // --- Add Save Button (no change) ---
     let saveButtonContainer = document.getElementById('capacitySaveButtonContainer'); /* ... Button setup ... */
      if (!saveButtonContainer) { saveButtonContainer = document.createElement('div'); saveButtonContainer.id = 'capacitySaveButtonContainer'; saveButtonContainer.style.textAlign = 'center'; saveButtonContainer.style.marginTop = '25px'; const saveButton = document.createElement('button'); saveButton.id = 'saveCapacityConfigButton'; saveButton.textContent = 'Save All Capacity Configuration'; saveButton.style.padding = '10px 20px'; saveButton.style.fontSize = '16px'; saveButton.style.backgroundColor = '#dc3545'; saveButton.style.color = 'white'; saveButton.style.border = 'none'; saveButton.style.borderRadius = '5px'; saveButton.style.cursor = 'pointer'; saveButton.onclick = saveCapacityConfiguration; saveButtonContainer.appendChild(saveButton); container.appendChild(saveButtonContainer); }

    console.log("Finished setting up Team Constraints structure (Phase 4b Simplified Activities).");
}
window.generateTeamConstraintsForms = generateTeamConstraintsForms;

/**
 * REVISED Function (Phase 6 - CORRECTED Save Logic + Store Calculated Metrics)
 * - Saves capacity configuration directly to localStorage using the correct system name.
 * - Avoids calling the incorrect saveSystemChanges function.
 * - Includes validation for workingDaysPerYear.
 * - Calculates metrics using calculateAllCapacityMetrics() and stores the result in currentSystemData.calculatedCapacityMetrics before saving.
 */
function saveCapacityConfiguration() {
    console.log("Attempting to save capacity configuration (including calculated metrics)...");
    if (!currentSystemData || !currentSystemData.systemName) {
        alert("Cannot save configuration: No system data loaded or system name is missing.");
        return;
    }

    const systemNameKey = currentSystemData.systemName; // Use the name stored in the data

    // Optional: Validation check before saving
    const workingDays = currentSystemData.capacityConfiguration?.workingDaysPerYear;
    console.log(`Validating workingDaysPerYear: Value=${workingDays}, Type=${typeof workingDays}`); // Added log for debugging
    if (workingDays === undefined || workingDays === null || workingDays <= 0) {
        if (!confirm(`Warning: 'Standard Working Days Per Year' (${workingDays}) is not set or is invalid. Calculations might be incorrect. Save anyway?`)) {
            const wdInput = document.getElementById('workingDaysInput');
            if(wdInput) wdInput.focus();
            return;
        }
    }

    try {
        // --- *** NEW: Calculate metrics BEFORE saving *** ---
        console.log("Calculating metrics before saving...");
        const calculatedMetrics = calculateAllCapacityMetrics(); // Assumes it uses global currentSystemData
        if (calculatedMetrics) {
            currentSystemData.calculatedCapacityMetrics = calculatedMetrics; // Store the results
            console.log("Stored calculated metrics in currentSystemData.calculatedCapacityMetrics.");
        } else {
            console.error("Failed to calculate metrics, calculatedCapacityMetrics will not be updated in saved data.");
            // Decide if you want to proceed saving without calculated metrics or stop
            // currentSystemData.calculatedCapacityMetrics = null; // Or set to null
        }
        // --- ****************************************** ---

        // 1. Get existing systems from localStorage
        const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');

        // 2. Update the data for the current system using its correct name
        // Now currentSystemData includes the calculatedCapacityMetrics
        systems[systemNameKey] = currentSystemData;
        console.log(`Updating localStorage for key: "${systemNameKey}"`);

        // 3. Save the entire systems object back to localStorage
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

        alert(`Capacity configuration for system "${systemNameKey}" saved successfully.`);
        console.log("Capacity configuration (with calculated metrics) saved.");

    } catch (error) {
        console.error("Error during saveCapacityConfiguration:", error);
        alert("An error occurred while trying to save the capacity configuration. Check console.");
    }
}
// Ensure it's globally accessible if button calls it directly
window.saveCapacityConfiguration = saveCapacityConfiguration;



/*****************************/
/** Save Sample Systems to Local Storage **/
function saveSampleSystemsToLocalStorage() {
    if (!localStorage.getItem(LOCAL_STORAGE_KEY)) {
        const systems = {
            'StreamView': sampleSystemDataStreamView,
            'ConnectPro': sampleSystemDataContactCenter
        };
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));
    }
}


// Call the function to save sample systems on page load
saveSampleSystemsToLocalStorage();

/** Show Saved Systems **/

/** REVISED (v3 - Corrected Template Literal) Show Saved Systems - Uses modal list with Load buttons */
function showSavedSystems() {
    console.log("Showing saved systems list (v3 - Corrected)...");
    // Retrieve the systems from local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    const systemNames = Object.keys(systems);

    // If no systems are saved, alert the user
    if (systemNames.length === 0) {
        alert('No saved systems found.');
        return;
    }

    // --- Create a modal/div to list systems for loading ---
    // Remove any existing list first (either load or delete)
    const existingLoadListDiv = document.getElementById('systemLoadListDiv');
    if (existingLoadListDiv) document.body.removeChild(existingLoadListDiv);
    const existingDeleteListDiv = document.getElementById('systemDeleteListDiv');
    if (existingDeleteListDiv) document.body.removeChild(existingDeleteListDiv);


    let systemListDiv = document.createElement('div');
    systemListDiv.id = 'systemLoadListDiv'; // Use a specific ID for the load list

    let systemListHtml = '<h2>Select a System to Load</h2><ul>';
    // Loop through the actual system names fetched from local storage
    systemNames.forEach(systemName => {
        // *** This template literal correctly inserts the systemName variable ***
        systemListHtml += `
            <li style="margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                <span>${systemName}</span>
                <button onclick="loadSavedSystem('${systemName}')" style="margin-left: 15px; padding: 3px 8px; font-size: 0.9em;">Load</button>
            </li>`;
        // **********************************************************************
    });
    systemListHtml += '</ul>';
    systemListDiv.innerHTML = systemListHtml;

    // Add a close button
    let closeButton = document.createElement('button');
    closeButton.innerText = 'Cancel';
    closeButton.style.marginTop = '15px';
    closeButton.onclick = function() {
        if (systemListDiv.parentNode === document.body) {
             document.body.removeChild(systemListDiv);
        }
    };
    systemListDiv.appendChild(closeButton);

    // Style the div (consistent with delete modal)
    systemListDiv.style.position = 'fixed';
    systemListDiv.style.top = '50%';
    systemListDiv.style.left = '50%';
    systemListDiv.style.transform = 'translate(-50%, -50%)';
    systemListDiv.style.backgroundColor = '#fff';
    systemListDiv.style.padding = '20px';
    systemListDiv.style.border = '1px solid #ccc';
    systemListDiv.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
    systemListDiv.style.zIndex = '1001'; // Ensure it's above other elements
    systemListDiv.style.maxHeight = '80vh';
    systemListDiv.style.overflowY = 'auto';
    systemListDiv.style.minWidth = '300px';


    // Append the div to the body
    document.body.appendChild(systemListDiv);
    console.log("Load system prompt displayed.");
}
// Ensure it's globally accessible if called directly via onclick
window.showSavedSystems = showSavedSystems;

function buildGlobalPlatformDependencies() {
    const platformDepsSet = new Set();

    // Iterate over services to collect platform dependencies
    currentSystemData.services.forEach(service => {
        if (service.platformDependencies) {
            service.platformDependencies.forEach(dep => {
                platformDepsSet.add(dep);
            });
        }
    });

    // Convert the set to an array and assign to currentSystemData
    currentSystemData.platformDependencies = Array.from(platformDepsSet);
}

/** REVISED (v4) Load Saved System using switchView */
function loadSavedSystem(systemName) {
    // --- Find System Data (No Change) ---
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    const systemData = systems[systemName];
    console.log('Loaded systems from local storage:', systems);
    if (!systemData) { alert('System not found.'); return; }
    currentSystemData = systemData;
    console.log('Selected system to load:', currentSystemData);
    // --- End Find System Data ---

    // --- Remove System Load List Popup ---
    const systemLoadListDiv = document.getElementById('systemLoadListDiv'); // <-- NEW ID
    if (systemLoadListDiv) {
      document.body.removeChild(systemLoadListDiv);
      console.log("Removed system load list modal.");
    }
    // --- End Remove Popup ---

    // --- Clear previous visualization content ---
    d3.selectAll('.tooltip').remove(); // Remove any lingering tooltips
    // Clear specific legend divs if they still exist, although switchView handles main containers
    const legendDivs = ['legend', 'teamLegend', 'serviceLegend', 'dependencyLegend'];
    legendDivs.forEach(id => {
        const el = document.getElementById(id);
        if(el) el.innerHTML = '';
    });
    // --- End Clear ---

     // --- Re-initialize uniqueEngineers and build platform deps (No Change) ---
     uniqueEngineers = [];
     (currentSystemData.teams || []).forEach(team => {
         (team.engineers || []).forEach(engineer => {
            if (engineer && engineer.name) {
                 uniqueEngineers.push({ engineerName: engineer.name, teamId: team.teamId });
             }
         });
     });
     buildGlobalPlatformDependencies();
     // --- End Data Prep ---

    // --- USE switchView TO SHOW OVERVIEW ---
    // This replaces setting display styles and managing buttons/title manually
    switchView('visualizationCarousel'); // Show the carousel (overview); this also sets mode and shows edit-menu/return-home
    const serviceDepsTableDiv = document.getElementById('serviceDependenciesTable');
     if (serviceDepsTableDiv) serviceDepsTableDiv.style.display = 'block'; // Explicitly show table too
    // --- End switchView ---

    // --- Regenerate Overview Content ---
    // (Must happen AFTER switchView makes containers visible)
    try {
         // Populate dropdowns needed for carousel items
         populateServiceSelection();
         populateDependencyServiceSelection();

        // Generate visualizations (even if initially hidden by carousel)
         generateVisualization(currentSystemData);
         generateTeamVisualization(currentSystemData);
         // The specific service/dependency views are generated when shown by showVisualization

        // Generate separate dependencies table
         generateServiceDependenciesTable();

         // Show the FIRST item in the carousel - This triggers updates if needed
         showVisualization(0);

        console.log("Finished loading and displaying system:", currentSystemData.systemName);
     } catch (error) {
         console.error("Error regenerating system overview content during load:", error);
          const carouselDiv = document.getElementById('visualizationCarousel');
          if(carouselDiv) carouselDiv.innerHTML = '<p style="color:red">Error loading visualizations.</p>';
          if(serviceDepsTableDiv) serviceDepsTableDiv.innerHTML = '<p style="color:red">Error loading dependencies table.</p>';
    }
     // --- End Regeneration ---
}
window.loadSavedSystem = loadSavedSystem;

/**
 * REVISED (v2) - Shows the visualization item at the specified index and hides others.
 * Updates the carousel title and triggers specific D3 updates *after* display.
 * @param {number} index - The index of the visualization item to show.
 */
function showVisualization(index) {
    const carouselContainer = document.getElementById('visualizationCarousel');
    if (!carouselContainer) {
        console.error("Carousel container #visualizationCarousel not found.");
        return; // Exit if carousel isn't relevant
    }

    const items = carouselContainer.querySelectorAll('.carousel-item');
    const titleElement = document.getElementById('visualizationTitle');

    if (index < 0 || index >= items.length || items.length === 0) {
        console.error("Invalid visualization index or no items:", index);
        // Optionally hide all or show a default message
        items.forEach(item => item.style.display = 'none');
        if (titleElement) titleElement.textContent = 'No Visualization';
        return;
    }

    // Hide all items first
    items.forEach((item, i) => {
        item.style.display = 'none'; // Ensure all are hidden initially
        item.classList.remove('active'); // Remove active class if using transitions later
    });

    // Get the target item *before* trying to display it
    const targetItemId = visualizationItems[index]?.id; // Safely get ID
    const targetItem = targetItemId ? document.getElementById(targetItemId) : null;

    if (targetItem) {
         // *** Make the target item visible FIRST ***
         targetItem.style.display = 'block';
         targetItem.classList.add('active'); // Add active class

         console.log(`Showing visualization: ${visualizationItems[index].title}`);

         // Update the title
         if (titleElement) {
             titleElement.textContent = visualizationItems[index].title;
         }

         // *** NOW trigger the specific D3 generation/update for the VISIBLE item ***
         // This ensures the D3 functions calculate dimensions based on the visible container
         switch (targetItemId) {
            case 'visualization':
                // Assume generateVisualization was called on load/overview.
                // If layout issues persist, uncommenting this might help, but could be slow.
                // generateVisualization(currentSystemData);
                console.log("System Visualization shown.");
                break;
            case 'teamVisualization':
                // Assume generateTeamVisualization was called on load/overview.
                // generateTeamVisualization(currentSystemData);
                 console.log("Team Visualization shown.");
                break;
            case 'serviceRelationshipsVisualization':
                // Repopulate dropdown and trigger D3 update for service-specific views
                populateServiceSelection();
                updateServiceVisualization(); // This calls generateServiceVisualization
                console.log("Service Relationships shown & updated.");
                break;
            case 'dependencyVisualization':
                 // Repopulate dropdown and trigger D3 update for service-specific views
                populateDependencyServiceSelection();
                updateDependencyVisualization(); // This calls generateDependencyForceVisualization
                console.log("Dependency Visualization shown & updated.");
                break;
         }
         // *** End D3 Trigger ***

    } else {
        console.error("Target visualization element not found for ID:", targetItemId);
        if (titleElement) titleElement.textContent = 'Error';
    }

    currentVisualizationIndex = index; // Update the global index
}

/**
 * Navigates the visualization carousel forward or backward.
 * @param {number} direction - 1 for next, -1 for previous.
 */
function navigateVisualizations(direction) {
    let newIndex = currentVisualizationIndex + direction;
    const totalItems = visualizationItems.length;

    // Wrap around
    if (newIndex >= totalItems) {
        newIndex = 0; // Wrap to the first item
    } else if (newIndex < 0) {
        newIndex = totalItems - 1; // Wrap to the last item
    }

    showVisualization(newIndex);
}

/**
 * REVISED (v2) - Generates the main system visualization (Services, APIs, Platforms).
 * - Fixes static graph issue by stopping drag event propagation to prevent zoom interference.
 * - Ensures consistent use of event.subject in drag handler.
 */
function generateVisualization(systemData) {
    let svg = d3.select('#systemSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // --- Get SVG Dimensions ---
    const container = document.getElementById('visualization');
    if (!container) {
        console.error("Container #visualization not found for generateVisualization.");
        return;
    }
    const svgRect = container.getBoundingClientRect();
    const width = svgRect.width > 0 ? svgRect.width : 800;
    const height = parseInt(svg.style('height')) || 600;
    console.log(`generateVisualization calculated width: ${width}, height: ${height}`);
    // --- End Dimensions ---

    // --- Zoom Setup ---
    let graphGroup = svg.append('g').attr('class', 'graph-group'); // Container for zoomable elements

    let zoom = d3.zoom()
        .scaleExtent([0.1, 5]) // Adjusted scale extent slightly
        .on('zoom', zoomed);

    // Apply zoom AFTER appending graphGroup, call it on SVG element
    svg.call(zoom);

    function zoomed(event) {
        graphGroup.attr('transform', event.transform); // Apply transform to the group
    }
    // --- End Zoom Setup ---

    // Define node radius
    const radius = 10;

    // --- Prepare Nodes and Links ---
    let nodes = [];
    let links = [];
    let nodeMap = {};

    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = (systemData.teams || []).map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Create nodes for services and APIs
    (systemData.services || []).forEach(service => {
        let teamId = service.owningTeamId || 'unassigned';
        let nodeColor = teamColorScale(teamId);

        nodes.push({ id: service.serviceName, type: 'service', teamId: teamId, color: nodeColor });
        nodeMap[service.serviceName] = { id: service.serviceName, type: 'service' };

        (service.apis || []).forEach(api => {
            nodes.push({ id: api.apiName, type: 'api', teamId: teamId, color: nodeColor });
            nodeMap[api.apiName] = { id: api.apiName, type: 'api' };
            links.push({
                source: api.apiName,
                target: service.serviceName,
                type: 'api-service'
            });
        });
    });

    // Add platform dependencies as nodes
    (systemData.services || []).forEach(service => {
        (service.platformDependencies || []).forEach(platform => {
            if (!nodeMap[platform]) {
                nodes.push({ id: platform, type: 'platform', color: '#a04040' }); // Distinct platform color
                nodeMap[platform] = { id: platform, type: 'platform' };
            }
            links.push({
                source: service.serviceName,
                target: platform,
                type: 'platform-dependency'
            });
        });
    });

    // Create links based on dependencies
    (systemData.services || []).forEach(service => {
        (service.serviceDependencies || []).forEach(dependency => {
            if (nodeMap[dependency]) {
                links.push({
                    source: service.serviceName,
                    target: dependency,
                    type: 'service-dependency'
                });
            }
        });
        (service.apis || []).forEach(api => {
            (api.dependentApis || []).forEach(depApi => {
                if (nodeMap[depApi]) {
                    links.push({
                        source: api.apiName,
                        target: depApi,
                        type: 'api-dependency'
                    });
                }
            });
        });
    });
    // --- End Node/Link Prep ---

    // --- Simulation Setup ---
    const nodeCount = nodes.length;
    let chargeStrength = -300;
    let linkDistance = 100;
    if (nodeCount > 100) { chargeStrength = -100; linkDistance = 30; }
    else if (nodeCount > 50) { chargeStrength = -200; linkDistance = 50; }

    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(linkDistance))
        .force('charge', d3.forceManyBody().strength(chargeStrength))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 20)); // Increased collision radius slightly
    // --- End Simulation ---

    // --- Draw Elements (Append to graphGroup) ---
    let link = graphGroup.append('g') // Append links to graphGroup
        .attr('class', 'links')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-dasharray', d => {
            if (d.type === 'api-service') return '2,2';
            else if (d.type === 'service-dependency') return '5,5';
            else if (d.type === 'platform-dependency') return '10,5';
            else if (d.type === 'api-dependency') return '3,3';
            else return '1,0';
        })
        .attr('stroke-width', 1.5);

    let node = graphGroup.append('g') // Append nodes to graphGroup
        .attr('class', 'nodes')
        .attr('stroke', '#fff')
        .attr('stroke-width', 1.5)
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', radius)
        .attr('fill', d => d.color)
        .call(drag(simulation)); // Apply drag behavior

    let labels = graphGroup.append('g') // Append labels to graphGroup
        .attr('class', 'labels')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 0) // Center horizontally over node
        .attr('dy', -radius - 5) // Position above node
        .attr('text-anchor', 'middle') // Center text
        .style('font-size', '10px') // Smaller font size
        .style('pointer-events', 'none') // Prevent text from blocking node events
        .text(d => d.id);
    // --- End Draw Elements ---

    // --- Tooltip ---
    let tooltip = d3.select('body').selectAll('.tooltip').data([null]).join('div') // Reuse or create tooltip
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let info = '';
        if (d.type === 'service') {
            let service = (systemData.services || []).find(s => s.serviceName === d.id);
            let team = service ? (systemData.teams || []).find(t => t.teamId === service.owningTeamId) : null;
            info = `<strong>Service:</strong> ${d.id}<br>
                    <strong>Team:</strong> ${team ? (team.teamName || team.teamIdentity) : 'Unassigned'}<br>
                    <strong>Description:</strong> ${service?.serviceDescription || 'N/A'}`;
        } else if (d.type === 'api') {
            let api, serviceName;
            (systemData.services || []).forEach(service => {
                (service.apis || []).forEach(a => {
                    if (a.apiName === d.id) { api = a; serviceName = service.serviceName; }
                });
            });
            info = `<strong>API:</strong> ${d.id}<br>
                    <strong>Service:</strong> ${serviceName || 'N/A'}<br>
                    <strong>Description:</strong> ${api?.apiDescription || 'N/A'}`;
        } else if (d.type === 'platform') {
            info = `<strong>Platform:</strong> ${d.id}`;
        }
        tooltip.transition().duration(200).style('opacity', .9);
        tooltip.html(info).style('left', (event.pageX + 10) + 'px').style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition().duration(500).style('opacity', 0);
    });
    // --- End Tooltip ---

    // --- Simulation Tick ---
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5); // Keep label position relative to node
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });
    // --- End Tick ---

    // --- Drag Functions (with fix) ---
    function drag(simulation) {
        function dragstarted(event, d) {
            // *** FIX: Stop event propagation to prevent zoom/pan interference ***
            if (event.sourceEvent) { // Ensure sourceEvent exists
                 event.sourceEvent.stopPropagation();
            }
            // *******************************************************************
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x; // Use event.subject which is the datum 'd'
            event.subject.fy = event.subject.y;
        }
        function dragged(event, d) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }
    // --- End Drag Functions ---

    // --- Legend ---
    d3.select('#legend').selectAll('*').remove(); // Clear previous legend in the dedicated div
    let legendData = (systemData.teams || []).map(team => ({
        teamIdentity: team.teamIdentity || team.teamName || team.teamId, // Use identity, fallback to name/ID
        color: teamColorScale(team.teamId)
    }));
    // Add platform legend item
    legendData.push({ teamIdentity: 'Platform Dependency', color: '#a04040' });

    let legend = d3.select('#legend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item'); // Use existing CSS class

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('border-radius', '50%') // Circles for legend
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
    // --- End Legend ---
} // --- End generateVisualization ---


/** Generate Team Relationships Visualization **/
function generateTeamVisualization(systemData) {
    let svg = d3.select('#teamSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // Set SVG dimensions
    // Get SVG element and its parent container
    const container = document.getElementById('teamVisualization'); // Get the container div
    if (!container) {
         console.error("Container #teamVisualization not found for generateTeamVisualization.");
         return;
    }
    const svgRect = container.getBoundingClientRect(); // Get dimensions of the container
    const width = svgRect.width > 0 ? svgRect.width : 800; // Use container width or default
    // Keep height fixed or get from container style if needed
    const height = parseInt(svg.style('height')) || 600;
    console.log(`generateTeamVisualization calculated width: ${width}, height: ${height}`);

    // Define node radius
    const radius = 20;
    
    // Prepare nodes and links data
    let nodes = [];
    let links = [];
    let nodeMap = {};

    // Create a color scale for teams
    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = systemData.teams.map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Map teamId to services
    let teamServicesMap = {};
    systemData.services.forEach(service => {
        let teamId = service.owningTeamId;
        if (teamId) { // Ensure teamId is valid
            if (!teamServicesMap[teamId]) {
                teamServicesMap[teamId] = [];
            }
            teamServicesMap[teamId].push(service.serviceName);
        }
    });

    // Create nodes for teams
    systemData.teams.forEach(team => {
        if (team.teamId) { // Ensure teamId is valid
            nodes.push({
                id: team.teamId,
                name: team.teamIdentity,
                type: 'team',
                color: teamColorScale(team.teamId),
                services: teamServicesMap[team.teamId] || []
            });
            nodeMap[team.teamId] = { id: team.teamId };
        }
    });

    // Create links based on service dependencies
    let teamDependencies = {};

    systemData.services.forEach(service => {
        let owningTeamId = service.owningTeamId;
        if (owningTeamId && systemData.teams.some(t => t.teamId === owningTeamId)) { // Ensure owningTeamId is valid
            if (service.serviceDependencies.length > 0) {
                service.serviceDependencies.forEach(dependentServiceName => {
                    let dependentService = systemData.services.find(s => s.serviceName === dependentServiceName);
                    if (dependentService) {
                        let dependentTeamId = dependentService.owningTeamId;
                        if (dependentTeamId && owningTeamId !== dependentTeamId && systemData.teams.some(t => t.teamId === dependentTeamId)) {
                            let linkKey = owningTeamId + '-' + dependentTeamId;
                            if (!teamDependencies[linkKey]) {
                                teamDependencies[linkKey] = true;
                                links.push({
                                    source: owningTeamId,
                                    target: dependentTeamId,
                                    type: 'team-dependency'
                                });
                            }
                        }
                    }
                });
            }
        }
    });

    // Set up the simulation
    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 30));

    // Add links to the SVG
    let link = svg.append('g')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-width', 2);

    // Add nodes to the SVG
    let node = svg.append('g')
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', 20)
        .attr('fill', d => d.color)
        .call(drag(simulation));

    // Add labels to nodes
    let labels = svg.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 0)
        .attr('dy', 4)
        .attr('text-anchor', 'middle')
        .text(d => d.name);

    // Tooltip
    let tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let team = systemData.teams.find(t => t.teamId === d.id);
        let sdm = systemData.sdms.find(s => s.sdmId === team.sdmId);
        let pmt = systemData.pmts.find(p => p.pmtId === team.pmtId);
        let services = d.services.join(', ') || 'None';
        let info = `<strong>Team Identity:</strong> ${team.teamIdentity}<br>
                    <strong>Team Name:</strong> ${team.teamName}<br>
                    <strong>SDM:</strong> ${sdm ? sdm.sdmName : 'N/A'}<br>
                    <strong>PMT:</strong> ${pmt ? pmt.pmtName : 'N/A'}<br>
                    <strong>Size of Team:</strong> ${team.sizeOfTeam}<br>
                    <strong>Engineer Names:</strong> ${team.engineerNames}<br>
                    <strong>Services Owned:</strong> ${services}`;
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5);
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    // Add legend for teams
    let legendData = systemData.teams.map(team => ({
        teamIdentity: team.teamIdentity,
        color: teamColorScale(team.teamId)
    }));

    let legend = d3.select('#teamLegend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item');

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
}

/** DEBUGGING VERSION - Generate Team Breakdown Table - Adds Extensive Logging */
function generateTeamTable(systemData) {
    console.log("[DEBUG] ENTER generateTeamTable"); // Log function entry

    const teamTable = document.getElementById('teamTable');
    console.log("[DEBUG] Found teamTable element:", teamTable); // Log table element found

    // Add checks immediately after getting elements
    if (!teamTable) {
        console.error("[DEBUG] EXIT generateTeamTable: Could not find #teamTable element.");
        if (document.getElementById('teamBreakdown')) {
             document.getElementById('teamBreakdown').innerHTML = '<p style="color:red;">Error: Cannot find table element with ID "teamTable".</p>';
        }
        return;
    }

    const tableHead = teamTable.querySelector('thead'); // Removed optional chaining temporarily for clearer errors if teamTable is null
    const tableBody = teamTable.querySelector('tbody');
    const tableFoot = teamTable.querySelector('tfoot');
    console.log("[DEBUG] Found thead:", tableHead);
    console.log("[DEBUG] Found tbody:", tableBody);
    console.log("[DEBUG] Found tfoot:", tableFoot);

    if (!tableHead || !tableBody || !tableFoot) {
        console.error("[DEBUG] EXIT generateTeamTable: Could not find required inner table elements (thead, tbody, tfoot).");
        if (document.getElementById('teamBreakdown')) {
             document.getElementById('teamBreakdown').innerHTML = '<p style="color:red;">Error: Table structure incomplete (missing thead/tbody/tfoot).</p>';
        }
        return;
    }
    console.log("[DEBUG] All table elements found. Proceeding to clear content...");

    // --- Clear previous content ---
    try {
        tableBody.innerHTML = '';
        tableHead.innerHTML = '';
        tableFoot.innerHTML = '';
        console.log("[DEBUG] Cleared table head, body, and foot.");
    } catch (error) {
        console.error("[DEBUG] EXIT generateTeamTable: Error clearing table content:", error);
        return;
    }

    // --- 1. Rebuild Column Headers ---
    console.log("[DEBUG] Rebuilding column headers...");
    const headerRow = tableHead.insertRow();
    const headersConfig = [ /* ... headersConfig array remains the same ... */
        { text: 'Senior Manager', title: 'Senior Manager overseeing the SDM(s).' },
        { text: 'SDM', title: 'Software Development Manager for the team(s).' },
        { text: 'Team Identity', title: 'Unique identifier or codename for the team.' },
        { text: 'Team Name', title: 'Official name of the team.' },
        { text: 'PMT', title: 'Product Management counterpart for the team.' },
        { text: 'Team BIS', title: 'Builders In Seats: Count of actual engineers assigned to this team.' },
        { text: 'Finance Approved Funding', title: 'Official budgeted headcount allocated by finance.' },
        { text: 'Effective BIS to deliver initiatives', title: 'Total building capacity including team members and away-team resources (Team BIS + Away-Team BIS).' },
        { text: 'BIS Hiring Gap', title: 'Gap between Finance Approved Funding and actual Team BIS (Funded - Team BIS). Shows hiring need.' },
        { text: 'Engineers (Level)', title: 'List of engineers assigned to this team and their level.' },
        { text: 'Away-Team Members', title: 'List of engineers borrowed from other teams/orgs, their level, and source.' },
        { text: 'Services Owned', title: 'List of services this team owns.' }
     ];
    try {
        headersConfig.forEach(config => {
            const th = document.createElement('th');
            th.textContent = config.text;
            th.title = config.title;
            th.style.border = '1px solid #ccc'; th.style.padding = '8px'; th.style.textAlign = 'left';
            th.style.backgroundColor = '#f2f2f2'; th.style.position = 'sticky'; th.style.top = '0'; th.style.zIndex = '1';
            headerRow.appendChild(th);
        });
        console.log("[DEBUG] Successfully rebuilt headers.");
    } catch (error) {
        console.error("[DEBUG] EXIT generateTeamTable: Error rebuilding headers:", error);
        return;
    }
    // --- End Header Rebuild ---

    // --- 2. Defensive checks for core data ---
    console.log("[DEBUG] Performing defensive data checks...");
    if (!systemData || !systemData.teams || !Array.isArray(systemData.teams)) {
        console.error("[DEBUG] EXIT generateTeamTable: Invalid or missing systemData.teams");
        let errRow = tableBody.insertRow(); let cell = errRow.insertCell();
        cell.colSpan = headersConfig.length; cell.textContent = "Error: Team data is missing or invalid."; cell.style.color = 'red';
        tableFoot.innerHTML = '';
        const levelKeyElement = document.getElementById('levelKey'); if (levelKeyElement) levelKeyElement.innerHTML = '';
        return;
    }
    const services = systemData.services || []; const sdms = systemData.sdms || []; const pmts = systemData.pmts || []; const seniorManagers = systemData.seniorManagers || [];
    console.log("[DEBUG] Data checks passed.");
    // --- End Defensive Checks ---

    // --- 3. Totals Initialization ---
    let totalFundedHC = 0; let totalTeamBIS = 0; let totalEffectiveBIS = 0;
    console.log("[DEBUG] Initialized totals.");
    // --- End Totals Init ---

    // --- 4. Helper Functions --- (Defined but not logged during definition)
    const getSeniorManagerName = (srMgrId) => { if (!srMgrId) return 'No Senior Manager'; const srMgr = seniorManagers.find(s => s.seniorManagerId === srMgrId); return srMgr ? srMgr.seniorManagerName : `Unknown (${srMgrId})`; };
    const getSdmName = (sdmId) => { if (!sdmId) return 'No SDM'; const sdm = sdms.find(s => s.sdmId === sdmId); return sdm ? sdm.sdmName : `Unknown (${sdmId})`; };
    const getPmtName = (pmtId) => { if (!pmtId) return 'N/A'; const pmt = pmts.find(p => p.pmtId === pmtId); return pmt ? pmt.pmtName : `Unknown (${pmtId})`; };
    // --- End Helpers ---

    // --- 5. Map teamId to services ---
    console.log("[DEBUG] Mapping services to teams...");
    let teamServicesMap = {};
    try {
        services.forEach(service => { let teamId = service.owningTeamId; if (teamId) { if (!teamServicesMap[teamId]) teamServicesMap[teamId] = []; teamServicesMap[teamId].push(service.serviceName); } });
        console.log("[DEBUG] Service mapping complete.");
    } catch(error) {
        console.error("[DEBUG] EXIT generateTeamTable: Error mapping services:", error);
        return;
    }
    // --- End Service Map ---

    // --- 6. Group teams by Senior Manager -> SDM ---
    console.log("[DEBUG] Grouping teams...");
    let groupedData = {};
    try {
        systemData.teams.forEach(team => { if (!team) return; const sdm = sdms.find(s => s.sdmId === team.sdmId); const srMgrId = sdm ? (sdm.seniorManagerId || 'no-sr-mgr') : 'no-sdm'; const sdmId = team.sdmId || 'no-sdm'; if (!groupedData[srMgrId]) groupedData[srMgrId] = {}; if (!groupedData[srMgrId][sdmId]) groupedData[srMgrId][sdmId] = []; groupedData[srMgrId][sdmId].push(team); });
        console.log("[DEBUG] Team grouping complete.");
    } catch (error) {
        console.error("[DEBUG] EXIT generateTeamTable: Error grouping teams:", error);
        return;
    }
    // --- End Grouping ---

    // --- 7. Populate Table Body ---
    console.log("[DEBUG] Starting table body population...");
    try {
        let rowCount = 0;
        for (const srMgrId in groupedData) {
            // ... (rest of the body population logic - no changes, just wrapped in try) ...
            const srMgrData = groupedData[srMgrId];
            const srMgrNameDisplay = (srMgrId === 'no-sr-mgr' || srMgrId === 'no-sdm') ? 'No Assigned Senior Manager' : getSeniorManagerName(srMgrId);
            let isFirstRowForSrMgr = true;
            let srMgrRowspan = 0;
            for (const sdmId in srMgrData) { srMgrRowspan += srMgrData[sdmId].length; }

            for (const sdmId in srMgrData) {
                const teams = srMgrData[sdmId];
                const sdmNameDisplay = (sdmId === 'no-sdm') ? 'No Assigned SDM' : getSdmName(sdmId);
                let isFirstRowForSdm = true;

                teams.forEach((team) => {
                    if (!team) return;
                    let row = tableBody.insertRow();
                    rowCount++;

                    // Standard Grouping Cells
                    if (isFirstRowForSrMgr) { let srMgrCell = row.insertCell(); srMgrCell.innerText = srMgrNameDisplay; srMgrCell.rowSpan = srMgrRowspan; srMgrCell.style.verticalAlign = 'top'; isFirstRowForSrMgr = false; }
                    if (isFirstRowForSdm) { let sdmCell = row.insertCell(); sdmCell.innerText = sdmNameDisplay; sdmCell.rowSpan = teams.length; sdmCell.style.verticalAlign = 'top'; isFirstRowForSdm = false; }
                    row.insertCell().innerText = team.teamIdentity || 'N/A';
                    row.insertCell().innerText = team.teamName || 'N/A';
                    row.insertCell().innerText = getPmtName(team.pmtId);

                    // Capacity Calculations & Cells
                    const fundedHC = team.fundedHeadcount ?? 0;
                    const teamBIS = team.engineers?.length ?? 0;
                    const awayTeamBIS = team.awayTeamMembers?.length ?? 0;
                    const effectiveBIS = teamBIS + awayTeamBIS;
                    const hiringGap = fundedHC - teamBIS;

                    const teamBISCell = row.insertCell(); teamBISCell.innerText = teamBIS; teamBISCell.style.textAlign = 'center';
                    row.insertCell().innerText = fundedHC.toFixed(2);
                    const effectiveBISCell = row.insertCell(); effectiveBISCell.innerText = effectiveBIS.toFixed(2); effectiveBISCell.title = `Team BIS: ${teamBIS}, Away-Team BIS: ${awayTeamBIS}`; effectiveBISCell.style.textAlign = 'center'; if (awayTeamBIS > 0) effectiveBISCell.style.fontWeight = 'bold';
                    let hiringGapCell = row.insertCell(); hiringGapCell.innerText = hiringGap; hiringGapCell.style.color = hiringGap < 0 ? 'blue' : (hiringGap > 0 ? 'orange' : 'green'); hiringGapCell.style.textAlign = 'center'; if (hiringGap < 0) { hiringGapCell.title = `Team BIS (${teamBIS}) exceeds Funded HC (${fundedHC}) by ${Math.abs(hiringGap)}`; hiringGapCell.style.fontWeight = 'bold'; } else if (hiringGap > 0) { hiringGapCell.title = `Need to hire ${hiringGap} to reach Funded HC (${fundedHC})`; } else { hiringGapCell.title = `Team BIS matches Funded HC`; }

                    // Accumulate Totals
                    totalFundedHC += fundedHC; totalTeamBIS += teamBIS; totalEffectiveBIS += effectiveBIS;

                    // Engineers (Level) Cell
                    let engineersCell = row.insertCell(); if (team.engineers && Array.isArray(team.engineers) && team.engineers.length > 0) { engineersCell.innerHTML = team.engineers .map(eng => { if (typeof eng !== 'object' || eng === null) return 'Invalid Eng Data'; const name = eng.name || 'Unnamed'; const level = eng.level ?? '?'; return name + ' (L' + level + ')'; }) .join('<br>'); } else { engineersCell.innerText = 'None'; } engineersCell.style.whiteSpace = 'pre-line';

                    // Away-Team Members Cell
                    let awayTeamCell = row.insertCell(); if (team.awayTeamMembers && Array.isArray(team.awayTeamMembers) && team.awayTeamMembers.length > 0) { awayTeamCell.innerHTML = team.awayTeamMembers .map(awayEng => { if (typeof awayEng !== 'object' || awayEng === null) return 'Invalid Away Data'; const name = awayEng.name || 'Unnamed'; const level = awayEng.level ?? '?'; const source = awayEng.sourceTeam || 'Unknown Source'; return `${name} (L${level}) - ${source}`; }) .join('<br>'); } else { awayTeamCell.innerText = 'None'; } awayTeamCell.style.whiteSpace = 'pre-line'; awayTeamCell.style.fontSize = '0.9em'; awayTeamCell.style.color = '#333';

                    // Services Owned Cell
                    let servicesOwnedCell = row.insertCell(); servicesOwnedCell.innerText = team.teamId && teamServicesMap[team.teamId] ? teamServicesMap[team.teamId].join(', ') : 'None';
                }); // End teams.forEach
            } // End sdmId loop
        } // End srMgrId loop
        console.log(`[DEBUG] Finished table body population. Inserted ${rowCount} rows.`);
    } catch (error) {
         console.error("[DEBUG] EXIT generateTeamTable: Error populating table body:", error);
         return;
    }
    // --- End Populate Body ---

    // --- 8. REBUILD Footer Totals ---
    console.log("[DEBUG] Rebuilding footer...");
    try {
        const totalHiringGap = totalFundedHC - totalTeamBIS;
        let footerRow1 = tableFoot.insertRow();

        let totalsLabelCell = footerRow1.insertCell();
        totalsLabelCell.textContent = 'Totals:';
        totalsLabelCell.colSpan = 5; // Using explicit 5
        totalsLabelCell.style.textAlign = 'right';
        totalsLabelCell.style.fontWeight = 'bold';

        let totalTeamBISCell = footerRow1.insertCell(); totalTeamBISCell.textContent = totalTeamBIS.toFixed(2); totalTeamBISCell.id = 'totalTeamBIS';
        let totalFundedHCCell = footerRow1.insertCell(); totalFundedHCCell.textContent = totalFundedHC.toFixed(2); totalFundedHCCell.id = 'totalFundedHC';
        let totalEffectiveBISCell = footerRow1.insertCell(); totalEffectiveBISCell.textContent = totalEffectiveBIS.toFixed(2); totalEffectiveBISCell.id = 'totalEffectiveBIS';
        let totalHiringGapCell = footerRow1.insertCell(); totalHiringGapCell.textContent = totalHiringGap; totalHiringGapCell.id = 'totalGap';

        let remainingFooterCols = headersConfig.length - totalsLabelCell.colSpan - 4;
        for(let i=0; i < remainingFooterCols; i++) { footerRow1.insertCell(); }

        [totalTeamBISCell, totalFundedHCCell, totalEffectiveBISCell, totalHiringGapCell].forEach(cell => { /* ... styling ... */
             cell.style.fontWeight = 'bold'; cell.style.textAlign = 'center';
             cell.style.border = '1px solid #ccc'; cell.style.padding = '8px'; cell.style.backgroundColor = '#f8f9fa';
        });
        totalHiringGapCell.style.color = totalHiringGap < 0 ? 'blue' : (totalHiringGap > 0 ? 'orange' : 'green');

        let footerRow2 = tableFoot.insertRow();
        let gapNoteCell = footerRow2.insertCell();
        gapNoteCell.colSpan = headersConfig.length;
        gapNoteCell.id = 'gapNote'; /* ... styling ... */
        gapNoteCell.style.textAlign = 'right'; gapNoteCell.style.fontStyle = 'italic'; gapNoteCell.style.fontSize = '0.9em'; gapNoteCell.style.paddingTop = '5px'; gapNoteCell.style.borderTop = '1px solid #ddd';

        let gapNoteText = `Overall BIS Hiring Gap: ${totalHiringGap} (Finance Approved Funding vs Team BIS). `;
        if (totalHiringGap > 0) { gapNoteText += `Need to hire ${totalHiringGap}.`; }
        else if (totalHiringGap < 0) { gapNoteText += `Over hiring target by ${Math.abs(totalHiringGap)}.`; }
        else { gapNoteText += `At hiring target.`; }
        if (totalEffectiveBIS > totalTeamBIS) { gapNoteText += ` Effective capacity boosted to ${totalEffectiveBIS.toFixed(2)} by away-teams.` }
        gapNoteCell.innerText = gapNoteText;
        console.log("[DEBUG] Footer rebuilt successfully.");
    } catch (error) {
        console.error("[DEBUG] EXIT generateTeamTable: Error rebuilding footer:", error);
        return;
    }
    // --- End Footer Rebuild ---

    // --- 9. Populate Level Key ---
    console.log("[DEBUG] Populating level key...");
    try {
        const levelKeyElement = document.getElementById('levelKey');
        if (levelKeyElement) {
            levelKeyElement.innerHTML = `Level Key: L1=SDE 1 (Junior), L2=SDE 2 (Intermediate), L3=SDE 3 (Senior), L4=Principal SDE, L5=Senior Principal SDE`;
        } else {
             console.warn("[DEBUG] Could not find #levelKey element.");
        }
        console.log("[DEBUG] Level key populated.");
    } catch (error) {
        console.error("[DEBUG] EXIT generateTeamTable: Error populating level key:", error);
        return;
    }
    // --- End Level Key ---
    console.log("[DEBUG] EXIT generateTeamTable - Successful completion."); // Log function end
}
// Ensure it's globally accessible
window.generateTeamTable = generateTeamTable;

/** Enter Edit Mode **/

/** REVISED Enter Edit Mode - Calls showSystemEditForm which uses switchView */
function enterEditMode(creatingNewSystem = false) { // Default creatingNewSystem to false
    const mode = creatingNewSystem ? Modes.CREATING : Modes.EDITING;
    console.log(`Entering mode: ${mode}`);
    currentMode = mode; // Set the mode

    if (!currentSystemData) {
        alert("No system data to edit.");
        returnToHome();
        return;
    }
    // Show the system edit form, populated with current data
    showSystemEditForm(currentSystemData);
}
// No need to add enterEditMode to window, called by button onclick

/** REVISED (v4) Show System Edit Form using switchView */
function showSystemEditForm(systemData) {
    console.log("Entering Edit System form (Focus Mode)...");
    if (!systemData) { console.error("showSystemEditForm called without systemData."); return; }

    // Use switchView to handle showing the form and managing buttons/title
    switchView('systemEditForm', Modes.EDITING); // Explicitly set EDITING mode

    // --- Populate form fields ---
    const nameInput = document.getElementById('systemNameInput');
    const descInput = document.getElementById('systemDescriptionInput');
    if(nameInput) nameInput.value = systemData.systemName || '';
    if(descInput) descInput.value = systemData.systemDescription || '';
    console.log("Populated edit form: Name=", nameInput?.value, "Desc=", descInput?.value);

    // Populate services and teams (existing logic)
    try {
         displayServicesForEditing(systemData.services || [], 'editServicesManagement');
         displayTeamsForEditing(systemData.teams || []);
    } catch (error) {
         console.error("Error populating services/teams in edit form:", error);
          const editFormDiv = document.getElementById('systemEditForm');
          if(editFormDiv) editFormDiv.innerHTML = `<p style="color:red;">Error populating form details. Check console.</p>`;
    }
    // ---------------------------------------------
}
// No need to add to window, it's called internally by enterEditMode

/** Helper to create Label + Input pairs (Revised for BIS display update) */
function createInputLabelPair(id, labelText, value, type = 'text', index, field, isReadOnly = false, tooltip = null) {
    let div = document.createElement('div');
    div.style.marginBottom = '10px';
    let label = document.createElement('label');
    label.htmlFor = id;
    label.innerText = labelText;
    label.style.display = 'block';
    if (tooltip) {
        label.title = tooltip; // Add tooltip to label if provided
    }

    let inputElement; // Could be input, textarea, or span

    if (isReadOnly) {
        inputElement = document.createElement('span');
        inputElement.id = id;
        inputElement.textContent = value;
        inputElement.style.fontWeight = 'bold'; // Make read-only values stand out
        if (tooltip) {
            inputElement.title = tooltip; // Add tooltip to value span as well
        }
    } else if (type === 'textarea') {
        inputElement = document.createElement('textarea');
        inputElement.rows = 2;
        inputElement.style.width = '90%';
        inputElement.id = id;
        inputElement.value = value;
        inputElement.setAttribute('data-team-index', index);
        inputElement.setAttribute('data-field', field);
        inputElement.addEventListener('change', handleTeamInputChange); // Use generic handler
    } else { // Default to input
        inputElement = document.createElement('input');
        inputElement.type = type;
        if (type === 'number') {
            inputElement.min = 0;
             // Add step=1 for integer headcount fields if needed
             if (field === 'fundedHeadcount') inputElement.step = 1;
        }
        inputElement.style.width = '90%';
        inputElement.id = id;
        inputElement.value = value;
        inputElement.setAttribute('data-team-index', index);
        inputElement.setAttribute('data-field', field);
        inputElement.addEventListener('change', handleTeamInputChange); // Use generic handler
    }

    div.appendChild(label);
    div.appendChild(inputElement);
    return div;
}

// Add a generic handler for team input changes (if not already present)
// This replaces the specific listeners previously inside createInputLabelPair
function handleTeamInputChange(event) {
    const input = event.target;
    const teamIndex = parseInt(input.getAttribute('data-team-index'));
    const fieldName = input.getAttribute('data-field');
    let value = input.value;

    if (input.type === 'number') {
        value = parseInt(value);
        if (isNaN(value)) value = 0;
    }

    if (currentSystemData && currentSystemData.teams && teamIndex >= 0 && teamIndex < currentSystemData.teams.length) {
        currentSystemData.teams[teamIndex][fieldName] = value;
        console.log(`Updated team[${teamIndex}].${fieldName} to:`, value);

        // If team identity or name changed, update the header
        if (fieldName === 'teamIdentity' || fieldName === 'teamName') {
            const teamDiv = input.closest('.team-edit');
            const header = teamDiv?.querySelector('h4');
            if (header) {
                 const indicator = header.querySelector('span');
                 const teamData = currentSystemData.teams[teamIndex];
                 header.textContent = `Team: ${teamData.teamIdentity || teamData.teamName || 'New Team'}`;
                 if(indicator) header.insertBefore(indicator, header.firstChild);
            }
        }
    } else {
        console.warn(`Could not update team data for index ${teamIndex}, field ${fieldName}`);
    }
}


/** Helper to display Senior Manager Assignment UI within SDM section */
function displaySeniorManagerAssignment(sdmSectionContainer, teamIndex, currentSdmId) {
    // Find the specific container using teamIndex (or could use sdmId if unique)
    let srMgrContainer = sdmSectionContainer.querySelector(`#srMgrAssignmentContainer_${teamIndex}`);
    if (!srMgrContainer) {
         console.error("Could not find Sr Mgr container for team index", teamIndex);
         return;
     }
    srMgrContainer.innerHTML = ''; // Clear previous content
    srMgrContainer.style.paddingLeft = '20px'; // Indent slightly

    // Ensure global data is available
    const allSdms = currentSystemData.sdms || [];
    const allSeniorManagers = currentSystemData.seniorManagers || [];

    const currentSdm = allSdms.find(sdm => sdm && sdm.sdmId === currentSdmId);

    if (!currentSdm) {
        srMgrContainer.innerText = 'Assign an SDM to manage Senior Manager assignment.';
        return; // No SDM assigned, nothing to show
    }

    let title = document.createElement('h6');
    title.innerText = `Senior Manager for SDM: ${currentSdm.sdmName}`;
    srMgrContainer.appendChild(title);

    const currentSrMgr = allSeniorManagers.find(sr => sr && sr.seniorManagerId === currentSdm.seniorManagerId);

    const srMgrDualList = createDualListContainer( // Call global helper
        teamIndex, // Pass teamIndex for context if needed by callbacks
        'Current Sr. Mgr:', 'Available Sr. Mgrs:',
        currentSrMgr ? [{ value: currentSrMgr.seniorManagerId, text: currentSrMgr.seniorManagerName }] : [],
        allSeniorManagers.filter(sr => sr && sr.seniorManagerId !== currentSdm.seniorManagerId)
                         .map(sr => ({ value: sr.seniorManagerId, text: sr.seniorManagerName })), // Map to value/text
        `currentSrMgr_${currentSdmId}`, // Field names specific to this SDM
        `availableSrMgrs_${currentSdmId}`,
        (movedSrMgrId, direction) => { // Callback on Sr Mgr move
            // Find the SDM in the main data again to modify it
            const sdmToUpdate = currentSystemData.sdms.find(s => s.sdmId === currentSdmId);
            if (sdmToUpdate) {
                 sdmToUpdate.seniorManagerId = (direction === 'add') ? movedSrMgrId : null;
                 console.log(`Set Sr Mgr for SDM ${currentSdmId} to ${sdmToUpdate.seniorManagerId}`);
             } else {
                 console.warn("Could not find SDM to update Sr Mgr for:", currentSdmId);
             }
        },
        false, // singleSelectLeft = true for current Sr Mgr (set multiSelectLeft to false)
        true, // Allow adding new Sr Mgrs
        'Enter New Sr. Manager Name',
        (newSrMgrName) => { // Callback for adding new Sr Mgr
            if (!newSrMgrName || newSrMgrName.trim() === '') return null;
            newSrMgrName = newSrMgrName.trim();
            let existingSrMgr = (currentSystemData.seniorManagers || []).find(s => s && s.seniorManagerName.toLowerCase() === newSrMgrName.toLowerCase()); // check s
            if (existingSrMgr) {
                alert(`Senior Manager "${newSrMgrName}" already exists.`);
                return null;
            }
            const newSrMgrId = 'srMgr-' + Date.now();
            const newSrMgr = { seniorManagerId: newSrMgrId, seniorManagerName: newSrMgrName };
            if (!currentSystemData.seniorManagers) currentSystemData.seniorManagers = []; // Ensure array exists
            currentSystemData.seniorManagers.push(newSrMgr); // Add to main data
            // We might need to update the local 'allSeniorManagers' if it's used elsewhere before a full refresh
            console.log("Added new Senior Manager:", newSrMgr);
            return { value: newSrMgrId, text: newSrMgrName }; // Return for UI update
        }
    );
    srMgrContainer.appendChild(srMgrDualList);
 }
// -----------------------------------

/** Helper to create Dual List Selectors */
function createDualListContainer(contextIndex, leftLabel, rightLabel, currentOptions, availableOptions, leftField, rightField, moveCallback, multiSelectLeft = true, allowAddNew = false, addNewPlaceholder = '', addNewCallback = null) {
    let container = document.createElement('div');
    container.className = 'dual-list-container';
    container.style.display = 'flex';
    container.style.alignItems = 'center';
    container.style.marginBottom = '10px';

    // Left List (Current)
    let leftDiv = document.createElement('div');
    leftDiv.style.flex = '1'; leftDiv.style.marginRight = '5px';
    let currentLabel = document.createElement('label');
    currentLabel.innerText = leftLabel; currentLabel.style.display = 'block';
    let currentSelect = document.createElement('select');
    currentSelect.multiple = multiSelectLeft; currentSelect.size = 5; currentSelect.style.width = '100%';
    currentSelect.setAttribute('data-list-context-index', contextIndex);
    currentSelect.setAttribute('data-field', leftField);
    (currentOptions || []).forEach(opt => currentSelect.appendChild(new Option(opt.text, opt.value)));
    leftDiv.appendChild(currentLabel); leftDiv.appendChild(currentSelect);

    // Buttons
    let buttonsDiv = document.createElement('div');
    buttonsDiv.style.display = 'flex'; buttonsDiv.style.flexDirection = 'column'; buttonsDiv.style.alignItems = 'center'; buttonsDiv.style.margin = '0 5px';
    let removeBtn = document.createElement('button'); removeBtn.type = 'button'; removeBtn.innerHTML = '&gt;'; removeBtn.title = 'Remove selected item(s)'; removeBtn.style.marginBottom = '5px';
    let addBtn = document.createElement('button'); addBtn.type = 'button'; addBtn.innerHTML = '&lt;'; addBtn.title = 'Add selected item(s)';

    // Right List (Available)
    let rightDiv = document.createElement('div');
    rightDiv.style.flex = '1'; rightDiv.style.marginLeft = '5px';
    let availableLabel = document.createElement('label');
    availableLabel.innerText = rightLabel; availableLabel.style.display = 'block';
    let availableSelect = document.createElement('select');
    availableSelect.multiple = true; availableSelect.size = 5; availableSelect.style.width = '100%';
    availableSelect.setAttribute('data-list-context-index', contextIndex);
    availableSelect.setAttribute('data-field', rightField);
    (availableOptions || []).forEach(opt => availableSelect.appendChild(new Option(opt.text, opt.value)));
    rightDiv.appendChild(availableLabel); rightDiv.appendChild(availableSelect);

    // Add New Item Input/Button
    let addNewContainer = null;
    if (allowAddNew && addNewCallback) {
        addNewContainer = document.createElement('div'); addNewContainer.style.marginTop = '5px'; addNewContainer.style.display = 'flex';
        let addNewInput = document.createElement('input'); addNewInput.type = 'text'; addNewInput.placeholder = addNewPlaceholder; addNewInput.style.flexGrow = '1'; addNewInput.style.marginRight = '5px';
        let addNewBtn = document.createElement('button'); addNewBtn.type = 'button'; addNewBtn.innerText = 'Add';
        addNewBtn.onclick = (e) => {
            e.preventDefault();
            const newItemData = addNewCallback(addNewInput.value);
            if (newItemData && newItemData.value && newItemData.text) {
                 const exists = Array.from(availableSelect.options).some(opt => opt.value === newItemData.value) || Array.from(currentSelect.options).some(opt => opt.value === newItemData.value);
                 if (!exists) { availableSelect.appendChild(new Option(newItemData.text, newItemData.value)); }
                 else if (!newItemData.preventAdd) { console.warn("Item already exists in lists:", newItemData.text); }
                 addNewInput.value = '';
             } else if (newItemData && newItemData.preventAdd) { addNewInput.value = ''; }
        };
        addNewContainer.appendChild(addNewInput); addNewContainer.appendChild(addNewBtn);
        rightDiv.appendChild(addNewContainer);
    }

    // Button Actions
    removeBtn.onclick = (e) => {
         e.preventDefault();
        Array.from(currentSelect.selectedOptions).forEach(option => { availableSelect.appendChild(option); moveCallback(option.value, 'remove', contextIndex); });
    };
    addBtn.onclick = (e) => {
         e.preventDefault();
        Array.from(availableSelect.selectedOptions).forEach(option => {
             if (!multiSelectLeft) {
                 while (currentSelect.options.length > 0) { let existingOption = currentSelect.options[0]; availableSelect.appendChild(existingOption); moveCallback(existingOption.value, 'remove', contextIndex); }
             }
             currentSelect.appendChild(option); moveCallback(option.value, 'add', contextIndex);
        });
    };

    buttonsDiv.appendChild(addBtn); buttonsDiv.appendChild(removeBtn);
    container.appendChild(leftDiv); container.appendChild(buttonsDiv); container.appendChild(rightDiv);
    return container;
} // --- End createDualListContainer ---

/** Display Teams for Editing **/
/** REVISED Display Teams for Editing - Adds Away-Team Management Section */
function displayTeamsForEditing(teams, expandedIndex = -1) {
    const teamsDiv = document.getElementById('teamsManagement');
    teamsDiv.innerHTML = ''; // Clear existing content

    // Pre-fetch global lists (keep as before)
    const allServices = (currentSystemData.services || []).map(service => ({ value: service.serviceName, text: service.serviceName, owningTeamId: service.owningTeamId || null }));
    const allSdms = currentSystemData.sdms || [];
    const allPmts = currentSystemData.pmts || [];
    const allSeniorManagers = currentSystemData.seniorManagers || [];
    // Note: Away-team list is per-team, not global selection here

    (teams || []).forEach((team, index) => {
        if (!team) { console.warn("Skipping invalid team object at index", index); return; }

        let teamDiv = document.createElement('div');
        teamDiv.className = 'team-edit';
        teamDiv.setAttribute('data-team-render-index', index); // Keep render index if needed

        // --- Header (Collapsible) - No Change ---
        let teamHeader = document.createElement('h4');
        teamHeader.style.cursor = 'pointer';
        let indicator = document.createElement('span');
        indicator.innerText = (index === expandedIndex) ? '- ' : '+ ';
        teamHeader.appendChild(indicator);
        teamHeader.appendChild(document.createTextNode(`Team: ${team.teamIdentity || team.teamName || 'New Team'}`));

        let teamDetails = document.createElement('div');
        teamDetails.className = 'team-details';
        teamDetails.style.display = (index === expandedIndex) ? 'block' : 'none';

        // Toggle Functionality (Keep as before, but refresh away-team list too)
        teamHeader.onclick = () => {
            const content = teamDetails;
            const isCurrentlyCollapsed = content.style.display === 'none' || content.style.display === '';
            content.style.display = isCurrentlyCollapsed ? 'block' : 'none';
            indicator.innerText = isCurrentlyCollapsed ? '- ' : '+ ';
            if (isCurrentlyCollapsed) {
                 // Refresh Available Services
                 refreshAvailableListsInDualList(content, 'currentServices', 'availableServices',
                    (currentSystemData.services || []).map(s => ({ value: s.serviceName, text: s.serviceName, owningTeamId: s.owningTeamId || null })),
                    team.teamId
                 );
                 // Refresh Sr Mgr display
                 displaySeniorManagerAssignment(content.querySelector(`#sdmSection_${index}`), index, team.sdmId);
                 // Refresh Away-Team List Display (in case data changed elsewhere)
                 displayAwayTeamMembers(team.awayTeamMembers || [], index);
                 // Refresh Effective BIS display
                 updateEffectiveBISDisplay(index);
            }
        };
        // --- End Header ---

        // --- Basic Info Inputs (Using revised helper) ---
        teamDetails.appendChild(createInputLabelPair(`teamIdentity_${index}`, 'Team Identity:', team.teamIdentity || '', 'text', index, 'teamIdentity'));
        teamDetails.appendChild(createInputLabelPair(`teamName_${index}`, 'Team Name:', team.teamName || '', 'text', index, 'teamName'));
        teamDetails.appendChild(createInputLabelPair(`teamDescription_${index}`, 'Team Description:', team.teamDescription || '', 'textarea', index, 'teamDescription'));
        // --- End Basic Info ---

        // --- Services Owned Dual List (Keep as before) ---
        const currentServices = allServices.filter(s => s.owningTeamId === team.teamId);
        const availableServices = allServices.filter(s => s.owningTeamId !== team.teamId);
        const servicesContainer = createDualListContainer(
             index, 'Services Owned:', 'Available Services:',
             currentServices, availableServices,
             'currentServices', 'availableServices',
             (movedOptionValue, direction, contextIndex) => { /* ... service move callback (no change) ... */
                const service = currentSystemData.services.find(s => s.serviceName === movedOptionValue);
                const targetTeam = currentSystemData.teams[contextIndex];
                if (service && targetTeam) {
                    service.owningTeamId = (direction === 'add') ? targetTeam.teamId : null;
                }
             }
        );
        teamDetails.appendChild(servicesContainer);
        teamDetails.appendChild(document.createElement('br'));
        // --- End Services ---

        // --- SDM Assignment & Senior Manager Assignment (Keep as before) ---
        const sdmSection = document.createElement('div'); /* ... sdm section setup (no change) ... */
        sdmSection.id = `sdmSection_${index}`; sdmSection.style.border = '1px dashed #ccc'; sdmSection.style.padding = '10px'; sdmSection.style.marginBottom = '10px';
        let sdmSectionTitle = document.createElement('h5'); sdmSectionTitle.innerText = 'SDM Assignment'; sdmSection.appendChild(sdmSectionTitle);
        const currentSdm = allSdms.find(sdm => sdm && sdm.sdmId === team.sdmId);
        const sdmContainer = createDualListContainer( /* ... sdm dual list setup (no change) ... */
            index, 'Current SDM:', 'Available SDMs:',
            currentSdm ? [{ value: currentSdm.sdmId, text: currentSdm.sdmName }] : [],
            allSdms.filter(sdm => sdm && sdm.sdmId !== team.sdmId).map(sdm => ({ value: sdm.sdmId, text: sdm.sdmName })),
            'currentSdm', 'availableSdms',
            (movedOptionValue, direction, contextIndex) => { // SDM Move Callback
                const targetTeam = currentSystemData.teams[contextIndex];
                if(targetTeam){
                    const newSdmId = (direction === 'add') ? movedOptionValue : null;
                    targetTeam.sdmId = newSdmId;
                    // Refresh Sr. Mgr section using the specific sdmSection container
                    displaySeniorManagerAssignment(sdmSection, contextIndex, newSdmId);
                }
            },
            false, true, 'Enter New SDM Name', // Single select left, allow add new
            (newSdmName) => { /* ... add new sdm callback (no change) ... */
                if (!newSdmName || newSdmName.trim() === '') return null; newSdmName = newSdmName.trim();
                let existingSdm = allSdms.find(s => s && s.sdmName.toLowerCase() === newSdmName.toLowerCase());
                if (existingSdm) { alert(`SDM "${newSdmName}" already exists.`); return null; }
                const newSdmId = 'sdm-' + Date.now(); const newSdm = { sdmId: newSdmId, sdmName: newSdmName, seniorManagerId: null };
                currentSystemData.sdms.push(newSdm); allSdms.push(newSdm); // Update local cache too
                console.log("Added new SDM:", newSdm); return { value: newSdmId, text: newSdmName };
             }
        );
        sdmSection.appendChild(sdmContainer);
        let srMgrAssignmentContainer = document.createElement('div'); srMgrAssignmentContainer.id = `srMgrAssignmentContainer_${index}`; srMgrAssignmentContainer.style.marginTop = '10px';
        sdmSection.appendChild(srMgrAssignmentContainer);
        teamDetails.appendChild(sdmSection); teamDetails.appendChild(document.createElement('br'));
        // Initial population of Sr Mgr (will also happen on expand)
        if (teamDetails.style.display === 'block') {
            displaySeniorManagerAssignment(sdmSection, index, team.sdmId);
        }
        // --- End SDM/SrMgr ---

        // --- PMT Assignment (Keep as before) ---
        const currentPmt = allPmts.find(pmt => pmt && pmt.pmtId === team.pmtId);
        const pmtContainer = createDualListContainer(/* ... pmt dual list setup (no change) ... */
            index, 'Current PMT:', 'Available PMTs:',
            currentPmt ? [{ value: currentPmt.pmtId, text: currentPmt.pmtName }] : [],
            allPmts.filter(pmt => pmt && pmt.pmtId !== team.pmtId).map(pmt => ({ value: pmt.pmtId, text: pmt.pmtName })),
            'currentPmt', 'availablePmts',
            (movedOptionValue, direction, contextIndex) => { // PMT Move Callback
                const targetTeam = currentSystemData.teams[contextIndex];
                if(targetTeam) targetTeam.pmtId = (direction === 'add') ? movedOptionValue : null;
            },
            false, true, 'Enter New PMT Name', // Single select left, allow add new
             (newPmtName) => { /* ... add new pmt callback (no change) ... */
                 if (!newPmtName || newPmtName.trim() === '') return null; newPmtName = newPmtName.trim();
                 let existingPmt = allPmts.find(p => p && p.pmtName.toLowerCase() === newPmtName.toLowerCase());
                 if (existingPmt) { alert(`PMT "${newPmtName}" already exists.`); return null; }
                 const newPmtId = 'pmt-' + Date.now(); const newPmt = { pmtId: newPmtId, pmtName: newPmtName };
                 currentSystemData.pmts.push(newPmt); allPmts.push(newPmt); // Update local cache
                 console.log("Added new PMT:", newPmt); return { value: newPmtId, text: newPmtName };
              }
        );
        teamDetails.appendChild(pmtContainer); teamDetails.appendChild(document.createElement('br'));
        // --- End PMT ---

        // --- Headcount Section ---
        teamDetails.appendChild(createInputLabelPair(`fundedHeadcount_${index}`, 'Finance Approved Funding:', team.fundedHeadcount ?? 0, 'number', index, 'fundedHeadcount'));

        // ** UPDATED: Display Effective BIS (Read Only) **
        const teamBIS = team.engineers?.length ?? 0;
        const awayTeamBIS = team.awayTeamMembers?.length ?? 0;
        const effectiveBIS = teamBIS + awayTeamBIS;
        const bisTooltip = `Team BIS: ${teamBIS}, Away-Team BIS: ${awayTeamBIS}`;
        teamDetails.appendChild(
            createInputLabelPair(`effectiveBIS_${index}`, 'Effective BIS:', effectiveBIS, 'text', index, 'effectiveBIS', true, bisTooltip) // isReadOnly = true
        );
        teamDetails.appendChild(document.createElement('br'));
        // --- End Headcount ---

        // --- Engineer Assignment (Keep as before) ---
        let engineersSectionTitle = document.createElement('h5'); /* ... engineer section setup (no change) ... */
        engineersSectionTitle.innerText = 'Team Engineer Assignment'; engineersSectionTitle.style.marginTop = '15px'; teamDetails.appendChild(engineersSectionTitle);
        const currentEngineerOptions = (team.engineers || []).map(eng => ({ value: eng.name, text: `${eng.name} (L${eng.level ?? '?'})` })); // Show level in list
        // Available needs to be calculated carefully now
        let allEngineerNamesMap = new Map();
        (currentSystemData.teams || []).forEach(t => { (t.engineers || []).forEach(eng => { if (eng?.name) allEngineerNamesMap.set(eng.name, t.teamId); }); });
        const availableEngineerOptions = Array.from(allEngineerNamesMap.keys()).filter(name => allEngineerNamesMap.get(name) !== team.teamId).map(name => ({ value: name, text: name }));

        const engineerContainer = createDualListContainer( /* ... engineer dual list setup (no change in basic structure) ... */
            index, 'Current Engineers:', 'Available Engineers:', currentEngineerOptions, availableEngineerOptions,
            'currentEngineers', 'availableEngineers',
            (movedEngineerName, direction, contextIndex) => { // Engineer Move Callback
                 const currentTeam = currentSystemData.teams[contextIndex]; if (!currentTeam) return;
                 if (direction === 'add') { /* ... remove from other teams, add to current (no change) ... */
                    let engineerLevel = 1; // Default level
                    // Try find the engineer on another team to get their level
                    currentSystemData.teams.forEach(otherTeam => {
                         const existingEng = (otherTeam.engineers || []).find(eng => eng.name === movedEngineerName);
                         if (existingEng) engineerLevel = existingEng.level ?? 1;
                    });

                     // Remove from *all* other teams first
                     currentSystemData.teams.forEach((otherTeam, otherIdx) => {
                         if (otherTeam.teamId !== currentTeam.teamId && otherTeam.engineers) {
                             const initialLength = otherTeam.engineers.length;
                             otherTeam.engineers = otherTeam.engineers.filter(eng => eng.name !== movedEngineerName);
                             if (otherTeam.engineers.length < initialLength) {
                                 updateEffectiveBISDisplay(otherIdx); // Update other team's displayed BIS
                             }
                         }
                     });
                    // Add engineer to current team if not already present
                    if (!currentTeam.engineers) currentTeam.engineers = [];
                    if (!currentTeam.engineers.some(eng => eng.name === movedEngineerName)) {
                        currentTeam.engineers.push({ name: movedEngineerName, level: engineerLevel }); // Use found/default level
                        console.log(`Added ${movedEngineerName} to team ${currentTeam.teamId}`);
                    }
                 } else { // Remove from current team
                     if (currentTeam.engineers) {
                        currentTeam.engineers = currentTeam.engineers.filter(eng => eng.name !== movedEngineerName);
                        console.log(`Removed ${movedEngineerName} from team ${currentTeam.teamId}`);
                     }
                 }
                 // Update Effective BIS display for the current team
                 updateEffectiveBISDisplay(contextIndex);
                 // Refresh available lists for *all* team editors after moving an engineer
                 refreshAllAvailableEngineerLists();

            },
            true, false, '', null // multiSelectLeft = true, allowAddNew = false for engineers
        );
        engineerContainer.id = `engineersList_${index}`; teamDetails.appendChild(engineerContainer);
        // --- End Engineers ---

        // *** NEW: Away-Team Management Section ***
        let awayTeamSection = document.createElement('div');
        awayTeamSection.style.marginTop = '15px';
        awayTeamSection.style.padding = '10px';
        awayTeamSection.style.border = '1px solid #add8e6'; // Light blue border
        awayTeamSection.style.backgroundColor = '#f0f8ff'; // Alice blue background

        let awayTeamTitle = document.createElement('h5');
        awayTeamTitle.innerText = 'Away-Team Members';
        awayTeamSection.appendChild(awayTeamTitle);

        // Container to display current away-team members
        let awayMemberListDiv = document.createElement('div');
        awayMemberListDiv.id = `awayMemberList_${index}`;
        awayMemberListDiv.style.marginBottom = '10px';
        awayMemberListDiv.style.maxHeight = '150px'; // Prevent excessive height
        awayMemberListDiv.style.overflowY = 'auto'; // Add scroll if needed
        awayMemberListDiv.style.border = '1px solid #ccc';
        awayMemberListDiv.style.padding = '5px';
        awayTeamSection.appendChild(awayMemberListDiv);
        // Initial population of the list happens later in displayAwayTeamMembers

        // Form to add new away-team members
        let addAwayForm = document.createElement('div');
        addAwayForm.style.marginTop = '10px';
        addAwayForm.innerHTML = `
            <label for="newAwayName_${index}" style="margin-right: 5px;">Name:</label>
            <input type="text" id="newAwayName_${index}" placeholder="Away Member Name" style="width: 150px; margin-right: 10px;">
            <label for="newAwayLevel_${index}" style="margin-right: 5px;">Level:</label>
            <input type="number" id="newAwayLevel_${index}" min="1" max="5" placeholder="1-5" style="width: 50px; margin-right: 10px;">
            <label for="newAwaySource_${index}" style="margin-right: 5px;">Source:</label>
            <input type="text" id="newAwaySource_${index}" placeholder="Source Team/Org" style="width: 150px; margin-right: 10px;">
            <button type="button" id="addAwayBtn_${index}">Add Away Member</button>
        `;
        awayTeamSection.appendChild(addAwayForm);

        teamDetails.appendChild(awayTeamSection);
        teamDetails.appendChild(document.createElement('br'));

        // Attach event listener to the 'Add Away Member' button
        // Need to do this *after* the button is added to the DOM
         setTimeout(() => { // Use setTimeout to ensure element exists
            const addBtn = document.getElementById(`addAwayBtn_${index}`);
            if (addBtn) {
                 addBtn.onclick = () => handleAddAwayTeamMember(index);
             } else {
                 console.warn(`Could not find Add Away button for team index ${index}`);
             }
             // Initial population of the away team list display
             displayAwayTeamMembers(team.awayTeamMembers || [], index);
         }, 0);
        // *** END Away-Team Section ***


        // --- Action Buttons (Save/Delete Team) - No Change ---
        let actionButtonsDiv = document.createElement('div');
        actionButtonsDiv.style.marginTop = '15px';
        let saveButton = document.createElement('button'); saveButton.type = 'button'; saveButton.innerText = 'Save Team Changes'; saveButton.onclick = () => saveTeamChanges(index); actionButtonsDiv.appendChild(saveButton);
        let deleteButton = document.createElement('button'); deleteButton.type = 'button'; deleteButton.innerText = 'Delete Team'; deleteButton.style.marginLeft = '10px'; deleteButton.style.color = 'red'; deleteButton.onclick = () => deleteTeam(index); actionButtonsDiv.appendChild(deleteButton);
        teamDetails.appendChild(actionButtonsDiv);
        // --- End Actions ---

        teamDiv.appendChild(teamHeader);
        teamDiv.appendChild(teamDetails);
        teamsDiv.appendChild(teamDiv);
    }); // End teams.forEach
} // --- End displayTeamsForEditing ---


// *** NEW HELPER FUNCTIONS FOR AWAY TEAM MANAGEMENT ***

/** Displays the list of current away team members for a specific team */
function displayAwayTeamMembers(awayMembers, teamIndex) {
    const listDiv = document.getElementById(`awayMemberList_${teamIndex}`);
    if (!listDiv) {
        console.error(`Could not find away member list div for team index ${teamIndex}`);
        return;
    }
    listDiv.innerHTML = ''; // Clear current list

    if (!awayMembers || awayMembers.length === 0) {
        listDiv.innerHTML = '<em style="color: #666;">No away-team members assigned.</em>';
        return;
    }

    awayMembers.forEach((member, memberIndex) => {
        const itemDiv = document.createElement('div');
        itemDiv.style.display = 'flex';
        itemDiv.style.justifyContent = 'space-between';
        itemDiv.style.alignItems = 'center';
        itemDiv.style.marginBottom = '3px';
        itemDiv.style.padding = '2px';
        itemDiv.style.borderBottom = '1px dashed #eee';

        const memberInfo = document.createElement('span');
        memberInfo.textContent = `${member.name || 'Unnamed'} (L${member.level ?? '?'}) - ${member.sourceTeam || 'Unknown Source'}`;
        itemDiv.appendChild(memberInfo);

        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove';
        removeBtn.style.fontSize = '0.8em';
        removeBtn.style.padding = '1px 4px';
        removeBtn.style.cursor = 'pointer';
        removeBtn.onclick = () => handleRemoveAwayTeamMember(teamIndex, memberIndex);
        itemDiv.appendChild(removeBtn);

        listDiv.appendChild(itemDiv);
    });
}

/** Handles clicking the 'Add Away Member' button */
function handleAddAwayTeamMember(teamIndex) {
    const nameInput = document.getElementById(`newAwayName_${teamIndex}`);
    const levelInput = document.getElementById(`newAwayLevel_${teamIndex}`);
    const sourceInput = document.getElementById(`newAwaySource_${teamIndex}`);

    const name = nameInput?.value.trim();
    const level = parseInt(levelInput?.value);
    const sourceTeam = sourceInput?.value.trim();

    // Validation
    if (!name) { alert('Please enter a name for the away-team member.'); return; }
    if (isNaN(level) || level < 1 || level > 5) { alert('Please enter a valid level (1-5).'); return; }
    if (!sourceTeam) { alert('Please enter the source team/organization.'); return; }

    // Add to data model
    const team = currentSystemData.teams[teamIndex];
    if (!team) { console.error(`Cannot add away member, team index ${teamIndex} not found.`); return; }
    if (!team.awayTeamMembers) { team.awayTeamMembers = []; }

    // Check if member with same name already exists *in this team's away list*
    if (team.awayTeamMembers.some(m => m.name.toLowerCase() === name.toLowerCase())) {
        alert(`An away-team member named "${name}" is already assigned to this team.`);
        return;
    }

    team.awayTeamMembers.push({ name, level, sourceTeam });
    console.log(`Added away member to team ${teamIndex}:`, { name, level, sourceTeam });

    // Clear inputs
    if (nameInput) nameInput.value = '';
    if (levelInput) levelInput.value = '';
    if (sourceInput) sourceInput.value = '';

    // Refresh display
    displayAwayTeamMembers(team.awayTeamMembers, teamIndex);
    updateEffectiveBISDisplay(teamIndex); // Update the read-only BIS display
}

/** Handles clicking the 'Remove' button for an away-team member */
function handleRemoveAwayTeamMember(teamIndex, memberIndex) {
    const team = currentSystemData.teams[teamIndex];
    if (!team || !team.awayTeamMembers || memberIndex >= team.awayTeamMembers.length) {
        console.error(`Cannot remove away member, invalid indices: team ${teamIndex}, member ${memberIndex}`);
        return;
    }

    const removedMember = team.awayTeamMembers.splice(memberIndex, 1);
    console.log(`Removed away member from team ${teamIndex}:`, removedMember);

    // Refresh display
    displayAwayTeamMembers(team.awayTeamMembers, teamIndex);
    updateEffectiveBISDisplay(teamIndex); // Update the read-only BIS display
}

/** Helper to update the read-only Effective BIS display for a team */
function updateEffectiveBISDisplay(teamIndex) {
    const team = currentSystemData.teams[teamIndex];
    if (!team) return;

    const teamBIS = team.engineers?.length ?? 0;
    const awayTeamBIS = team.awayTeamMembers?.length ?? 0;
    const effectiveBIS = teamBIS + awayTeamBIS;
    const bisTooltip = `Team BIS: ${teamBIS}, Away-Team BIS: ${awayTeamBIS}`;

    const effectiveBISSpan = document.getElementById(`effectiveBIS_${teamIndex}`);
    const effectiveBISLabel = effectiveBISSpan?.previousElementSibling; // Get label for tooltip update

    if (effectiveBISSpan) {
        effectiveBISSpan.textContent = effectiveBIS;
        effectiveBISSpan.title = bisTooltip; // Update value tooltip
    }
     if (effectiveBISLabel) {
        effectiveBISLabel.title = bisTooltip; // Update label tooltip
     }
}

/** Helper to refresh available engineer lists in all open team edit sections */
function refreshAllAvailableEngineerLists() {
     console.log("Refreshing all available engineer lists...");
     const allTeamEditDivs = document.querySelectorAll('#teamsManagement .team-edit');
     let allEngineerNamesMap = new Map(); // Recalculate global map
     (currentSystemData.teams || []).forEach(t => { (t.engineers || []).forEach(eng => { if (eng?.name) allEngineerNamesMap.set(eng.name, t.teamId); }); });

     allTeamEditDivs.forEach((teamDiv, index) => {
         // Only refresh if the details are potentially visible (no easy way to know for sure without checking style)
         // This is a simplification; ideally, only refresh *actually* visible ones.
         const teamData = currentSystemData.teams[index]; // Assuming render index matches data index
         if (!teamData) return;

         const availableEngineersSelect = teamDiv.querySelector('select[data-field="availableEngineers"]');
         const currentEngineersSelect = teamDiv.querySelector('select[data-field="currentEngineers"]');

         if (availableEngineersSelect && currentEngineersSelect) {
             const currentTeamEngineers = Array.from(currentEngineersSelect.options).map(opt => opt.value);
             availableEngineersSelect.innerHTML = ''; // Clear current options
             Array.from(allEngineerNamesMap.keys())
                 .filter(name => !currentTeamEngineers.includes(name)) // Filter out engineers already in the current list
                 .forEach(name => {
                     availableEngineersSelect.appendChild(new Option(name, name));
                 });
         }
     });
}

/** Helper to refresh available options in a specific dual list (used for services) */
function refreshAvailableListsInDualList(contentContainer, currentListField, availableListField, allOptionsData, currentTeamId) {
    const currentSelect = contentContainer.querySelector(`select[data-field='${currentListField}']`);
    const availableSelect = contentContainer.querySelector(`select[data-field='${availableListField}']`);

    if (currentSelect && availableSelect) {
        const currentlyAssignedValues = Array.from(currentSelect.options).map(opt => opt.value);
        availableSelect.innerHTML = ''; // Clear
        allOptionsData.forEach(optionData => {
            // For services, filter out those owned by the current team OR already in the 'current' list
             if (optionData.owningTeamId !== currentTeamId && !currentlyAssignedValues.includes(optionData.value)) {
                 availableSelect.appendChild(new Option(optionData.text, optionData.value));
             }
        });
        console.log(`Refreshed available list for field: ${availableListField}`);
    } else {
         console.warn(`Could not find select lists for refresh: ${currentListField} / ${availableListField}`);
    }
}

/** NEW Helper Function: Creates a summary string of away-team sources */
function getSourceSummary(awayTeamMembers) {
    if (!awayTeamMembers || awayTeamMembers.length === 0) {
        return '';
    }
    const sources = awayTeamMembers
        .map(m => m.sourceTeam)
        .filter(source => source && source.trim() !== ''); // Get non-empty sources

    const uniqueSources = [...new Set(sources)]; // Get unique sources

    if (uniqueSources.length === 0) {
        return 'Unknown Source'; // Fallback if sources were empty strings
    } else if (uniqueSources.length === 1) {
        return uniqueSources[0];
    } else if (uniqueSources.length === 2) {
        return uniqueSources.join(', ');
    } else {
        return `${uniqueSources.slice(0, 1).join(', ')} & Others`; // Show first + others if more than 2
    }
}

// *** END NEW HELPER FUNCTIONS ***


function updateTeamSize(teamIndex, newSize) {
    currentSystemData.teams[teamIndex].sizeOfTeam = newSize;

    // Update the UI element for "Size of Team"
    const teamDiv = document.querySelectorAll('.team-edit')[teamIndex];
    const sizeInput = teamDiv.querySelector('input[data-field="sizeOfTeam"]');
    sizeInput.value = newSize;

    // **Update sizeOfTeam in currentSystemData**
    currentSystemData.teams[teamIndex].sizeOfTeam = newSize;
}

function updateAvailableEngineersInOtherTeams(engineerName, assignedTeamId) {
    // Loop through all teams
    currentSystemData.teams.forEach((team, idx) => {
        // Skip the team where the engineer was just added or removed
        if (team.teamId === assignedTeamId) {
            return;
        }

        const teamDiv = document.querySelectorAll('.team-edit')[idx];
        const availableEngineersSelect = teamDiv.querySelector('select[data-field="availableEngineers"]');
        const currentEngineersSelect = teamDiv.querySelector('select[data-field="currentEngineers"]');

        if (assignedTeamId) {
            // Remove from availableEngineersSelect
            const option = Array.from(availableEngineersSelect.options).find(opt => opt.value === engineerName);
            if (option) {
                availableEngineersSelect.removeChild(option);
            }
        } else {
            // Add to availableEngineersSelect if not already present
            const optionExists = Array.from(availableEngineersSelect.options).some(opt => opt.value === engineerName);
            const inCurrentEngineers = Array.from(currentEngineersSelect.options).some(opt => opt.value === engineerName);
            if (!optionExists && !inCurrentEngineers) {
                let option = document.createElement('option');
                option.value = engineerName;
                option.text = engineerName;
                availableEngineersSelect.appendChild(option);
            }
        }
    });
}

function updateAvailableServicesInOtherTeams(serviceName, assignedTeamId) {
    // Loop through all teams
    currentSystemData.teams.forEach((team, idx) => {
        // Skip the team where the service was just added or removed
        if (team.teamId === assignedTeamId) {
            return;
        }

        const teamDiv = document.querySelectorAll('.team-edit')[idx];
        const availableServicesSelect = teamDiv.querySelector('select[data-field="availableServices"]');
        const currentServicesSelect = teamDiv.querySelector('select[data-field="currentServices"]');

        if (assignedTeamId) {
            // Remove from availableServicesSelect
            const option = Array.from(availableServicesSelect.options).find(opt => opt.value === serviceName);
            if (option) {
                availableServicesSelect.removeChild(option);
            }
        } else {
            // Add to availableServicesSelect if not already present
            const optionExists = Array.from(availableServicesSelect.options).some(opt => opt.value === serviceName);
            const inCurrentServices = Array.from(currentServicesSelect.options).some(opt => opt.value === serviceName);
            if (!optionExists && !inCurrentServices) {
                let option = document.createElement('option');
                option.value = serviceName;
                option.text = serviceName;
                availableServicesSelect.appendChild(option);
            }
        }
    });
}

function removeServiceFromPreviousTeam(serviceName, prevTeamId) {
    const prevTeamIndex = currentSystemData.teams.findIndex(t => t.teamId === prevTeamId);
    if (prevTeamIndex !== -1) {
        const prevTeamDiv = document.querySelectorAll('.team-edit')[prevTeamIndex];
        const prevCurrentServicesSelect = prevTeamDiv.querySelector('select[data-field="currentServices"]');
        const prevOption = Array.from(prevCurrentServicesSelect.options).find(opt => opt.value === serviceName);
        if (prevOption) {
            prevCurrentServicesSelect.removeChild(prevOption);
            // Add to availableServicesSelect of previous team
            const prevAvailableServicesSelect = prevTeamDiv.querySelector('select[data-field="availableServices"]');
            prevAvailableServicesSelect.appendChild(prevOption.cloneNode(true));
        }
    }
}

function removeEngineerFromPreviousTeam(engineerName, prevTeamId) {
    const prevTeamIndex = currentSystemData.teams.findIndex(t => t.teamId === prevTeamId);
    if (prevTeamIndex !== -1) {
        const prevTeamDiv = document.querySelectorAll('.team-edit')[prevTeamIndex];
        const prevCurrentEngineersSelect = prevTeamDiv.querySelector('select[data-field="currentEngineers"]');
        const prevOption = Array.from(prevCurrentEngineersSelect.options).find(opt => opt.value === engineerName);
        if (prevOption) {
            prevCurrentEngineersSelect.removeChild(prevOption);
            // Update uniqueEngineers
            const engineer = uniqueEngineers.find(e => e.engineerName === engineerName);
            if (engineer) engineer.teamId = null;
        }
    }
}

function validateTeamChanges() {
    // Check for engineers assigned to multiple teams
    const engineerAssignments = {};
    currentSystemData.teams.forEach(team => {
        const teamEngineers = team.engineerNames ? team.engineerNames.split(',').map(name => name.trim()) : [];
        teamEngineers.forEach(engineerName => {
            if (engineerName) {
                if (engineerAssignments[engineerName]) {
                    engineerAssignments[engineerName].push(team.teamName || team.teamIdentity || 'Unnamed Team');
                } else {
                    engineerAssignments[engineerName] = [team.teamName || team.teamIdentity || 'Unnamed Team'];
                }
            }
        });
    });

    const conflictingEngineers = Object.entries(engineerAssignments).filter(([_, teams]) => teams.length > 1);

    // Check for services owned by multiple teams
    const serviceAssignments = {};
    currentSystemData.services.forEach(service => {
        if (service.owningTeamId) {
            if (serviceAssignments[service.serviceName]) {
                serviceAssignments[service.serviceName].push(service.owningTeamId);
            } else {
                serviceAssignments[service.serviceName] = [service.owningTeamId];
            }
        }
    });

    const conflictingServices = Object.entries(serviceAssignments).filter(([_, teams]) => teams.length > 1);

    let validationErrors = '';

    if (conflictingEngineers.length > 0) {
        validationErrors += 'The following engineers are assigned to multiple teams:\n';
        conflictingEngineers.forEach(([engineerName, teams]) => {
            validationErrors += `- ${engineerName}: ${teams.join(', ')}\n`;
        });
    }

    if (conflictingServices.length > 0) {
        validationErrors += 'The following services are owned by multiple teams:\n';
        conflictingServices.forEach(([serviceName, teamIds]) => {
            const teamNames = teamIds.map(teamId => {
                const team = currentSystemData.teams.find(t => t.teamId === teamId);
                return team ? (team.teamName || team.teamIdentity || 'Unnamed Team') : 'Unknown Team';
            });
            validationErrors += `- ${serviceName}: ${teamNames.join(', ')}\n`;
        });
    }

    if (validationErrors) {
        alert('Validation Errors:\n' + validationErrors);
        return false;
    }

    return true;
}


/** Updated Save Team Changes **/
/** Updated Save Team Changes - Includes Collapse Logic & Validation Call **/
function saveTeamChanges(index) {
    // Get the specific team object
    if (!currentSystemData || !currentSystemData.teams || index >= currentSystemData.teams.length) {
        console.error("Cannot save team, invalid index or data:", index);
        return;
    }
    const team = currentSystemData.teams[index];

    // --- Data is assumed to be updated by input listeners and dual-list callbacks ---

    // Recalculate Builders In Seats just to be sure it matches the array
    team.buildersInSeats = team.engineers ? team.engineers.length : 0;

    // Validate required fields for this team
    if (!team.teamIdentity || !team.teamName) {
        alert('Team Identity and Team Name are required.');
        return; // Don't proceed if basic info missing
    }

    // *** Add cross-team validation before saving system state ***
    if (!validateEngineerAssignments()) { // Call validation function
        return; // Stop saving if validation fails
    }
    // *********************************************************

    console.log("Saving changes for team (via saveSystemChanges):", JSON.stringify(team, null, 2));

    // --- Save the entire system data to local storage ---
    saveSystemChanges(); // This function now also includes validation internally

    // --- Update related UI elements ---
    generateTeamTable(currentSystemData); // Update main Team Breakdown table
    generateTeamVisualization(currentSystemData); // Update Team Visualization

    alert(`Changes for team "${team.teamName || team.teamIdentity}" potentially saved (system state saved).`);

    // --- Collapse the edit section after saving attempt ---
    const teamDivs = document.querySelectorAll('#teamsManagement .team-edit');
    if (index < teamDivs.length) {
         const teamDiv = teamDivs[index];
         const teamDetails = teamDiv.querySelector('.team-details');
         const indicator = teamDiv.querySelector('h4 > span');
         // Check if elements exist before modifying
         if (teamDetails) teamDetails.style.display = 'none';
         if (indicator) indicator.innerText = '+ ';
     }
    // -----------------------------------------------------
}


/** Display Services for Editing **/

/** REVISED Display Services for Editing - Refresh on Add Platform Dep **/
function displayServicesForEditing(services, containerId, expandedIndex = -1) {
    const servicesDiv = document.getElementById(containerId);
    servicesDiv.innerHTML = ''; // Clear existing content

    // Get a list of existing teams for the owning team selection
    const teamOptions = (currentSystemData.teams || []).map(team => ({ // Added default empty array
        teamId: team.teamId,
        teamIdentity: team.teamIdentity
    }));

    // Ensure platformDependencies is initialized and rebuilt
    if (!currentSystemData.platformDependencies) {
        currentSystemData.platformDependencies = [];
    }

    (services || []).forEach((service, index) => { // Added default empty array
        if (!service) return; // Skip potentially null entries if array was modified externally

        let serviceDiv = document.createElement('div');
        serviceDiv.className = 'service-edit';
        serviceDiv.setAttribute('data-service-index', index); // Add index for easier selection

        // Header (collapsible)
        let serviceHeader = document.createElement('h4');
        // Ensure serviceName exists before using it
        const headerText = service.serviceName || 'New Service';
        serviceHeader.style.cursor = 'pointer';
        let indicator = document.createElement('span');
        indicator.innerText = (index === expandedIndex) ? '- ' : '+ '; // Set initial state based on expandedIndex
        serviceHeader.appendChild(indicator);
        serviceHeader.appendChild(document.createTextNode(`Service: ${headerText}`));

        // Details container
        let serviceDetails = document.createElement('div');
        serviceDetails.className = 'service-details';
        serviceDetails.style.display = (index === expandedIndex) ? 'block' : 'none'; // Set initial state

        // Toggle Functionality - Modified to refresh lists on expand
        serviceHeader.onclick = () => {
            const content = serviceDetails; // Use variable already defined
            const isCurrentlyCollapsed = content.style.display === 'none' || content.style.display === '';
            content.style.display = isCurrentlyCollapsed ? 'block' : 'none';
            indicator.innerText = isCurrentlyCollapsed ? '- ' : '+ ';

            // Refresh available lists only when expanding
            if (isCurrentlyCollapsed) {
                console.log("Refreshing lists on expand for service:", service.serviceName);
                // Refresh Available Platform Dependencies
                const otherPlatDepsSelect = content.querySelector('select[data-field="availablePlatformDependencies"]');
                const currentPlatDepsSelect = content.querySelector('select[data-field="currentPlatformDependencies"]');
                if (otherPlatDepsSelect && currentPlatDepsSelect) {
                    const currentPlatDeps = Array.from(currentPlatDepsSelect.options).map(opt => opt.value);
                    otherPlatDepsSelect.innerHTML = ''; // Clear
                     (currentSystemData.platformDependencies || []).forEach(dep => {
                        if (!currentPlatDeps.includes(dep)) {
                            otherPlatDepsSelect.appendChild(new Option(dep, dep));
                        }
                    });
                }

                // Refresh Available Service Dependencies
                const otherSvcDepsSelect = content.querySelector('select[data-field="availableServiceDependencies"]');
                const currentSvcDepsSelect = content.querySelector('select[data-field="currentServiceDependencies"]');
                if (otherSvcDepsSelect && currentSvcDepsSelect) {
                    const currentSvcDeps = Array.from(currentSvcDepsSelect.options).map(opt => opt.value);
                    otherSvcDepsSelect.innerHTML = ''; // Clear
                     (currentSystemData.services || []).forEach(otherSvc => {
                        if (otherSvc.serviceName !== service.serviceName && !currentSvcDeps.includes(otherSvc.serviceName)) {
                            otherSvcDepsSelect.appendChild(new Option(otherSvc.serviceName, otherSvc.serviceName));
                        }
                    });
                }

                // Refresh Available APIs for each API within this service
                const apiEditDivs = content.querySelectorAll('.api-edit');
                const allApisList = (currentSystemData.services || []).flatMap(s => (s.apis || []).map(a => a.apiName));
                apiEditDivs.forEach((apiDiv, apiIdx) => {
                     const currentApiName = service.apis[apiIdx]?.apiName; // Get current API name
                     const otherApiDepsSelect = apiDiv.querySelector('select[data-field="availableApis"]');
                     const currentApiDepsSelect = apiDiv.querySelector('select[data-field="currentDependentApis"]');
                     if (otherApiDepsSelect && currentApiDepsSelect && currentApiName) {
                         const currentApiDeps = Array.from(currentApiDepsSelect.options).map(opt => opt.value);
                         otherApiDepsSelect.innerHTML = ''; // Clear
                         allApisList.forEach(apiName => {
                             if (apiName !== currentApiName && !currentApiDeps.includes(apiName)) {
                                 otherApiDepsSelect.appendChild(new Option(apiName, apiName));
                             }
                         });
                     }
                 });
            }
        };

        // --- Service Name & Description ---
        let nameLabel = document.createElement('label');
        nameLabel.innerText = 'Service Name:';
        let nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = service.serviceName || '';
        nameInput.setAttribute('data-service-index', index);
        nameInput.setAttribute('data-field', 'serviceName');
        nameInput.addEventListener('change', handleServiceInputChange); // Use shared handler
        serviceDetails.appendChild(nameLabel); serviceDetails.appendChild(document.createElement('br'));
        serviceDetails.appendChild(nameInput); serviceDetails.appendChild(document.createElement('br'));

        let descLabel = document.createElement('label');
        descLabel.innerText = 'Service Description:';
        let descTextarea = document.createElement('textarea');
        descTextarea.rows = 2; descTextarea.style.width = '90%';
        descTextarea.value = service.serviceDescription || '';
        descTextarea.setAttribute('data-service-index', index);
        descTextarea.setAttribute('data-field', 'serviceDescription');
        descTextarea.addEventListener('change', handleServiceInputChange); // Use shared handler
        serviceDetails.appendChild(descLabel); serviceDetails.appendChild(document.createElement('br'));
        serviceDetails.appendChild(descTextarea); serviceDetails.appendChild(document.createElement('br'));
        // -----------------------------------

        // --- Platform Dependencies ---
        const currentPlatDeps = (service.platformDependencies || []).map(dep => ({ value: dep, text: dep }));
        const availablePlatDeps = (currentSystemData.platformDependencies || []).filter(dep => !(service.platformDependencies || []).includes(dep)).map(dep => ({ value: dep, text: dep }));
        const platformContainer = createDualListContainer(
            index, 'Current Platform Deps:', 'Available Platform Deps:',
            currentPlatDeps, availablePlatDeps,
            'currentPlatformDependencies', 'availablePlatformDependencies',
            (movedDep, direction, serviceIdx) => { // Callback updates data model directly
                const targetService = currentSystemData.services[serviceIdx];
                if (!targetService.platformDependencies) targetService.platformDependencies = [];
                if (direction === 'add') {
                    if (!targetService.platformDependencies.includes(movedDep)) targetService.platformDependencies.push(movedDep);
                } else {
                    targetService.platformDependencies = targetService.platformDependencies.filter(d => d !== movedDep);
                }
            },
            true, true, 'Enter New Platform Dependency', // multiSelectLeft = true, allowAddNew = true
            (newDepName) => { // Add New Callback for Platform Deps (Simplified like SDM/PMT)
                        const textInput = platformContainer.querySelector('input[type="text"]'); // Get input relative to this dual list
                        if (!newDepName || newDepName.trim() === '') {
                            if(textInput) textInput.value = ''; // Clear input even if empty
                            return null;
                        }
                        newDepName = newDepName.trim();

                        // Ensure global platform dependencies array exists
                        if (!currentSystemData.platformDependencies) {
                            currentSystemData.platformDependencies = [];
                        }

                        const alreadyExistsGlobally = currentSystemData.platformDependencies.includes(newDepName);

                        // Find the specific select lists for THIS service instance to check if already visible
                        const currentPlatDepsSelect = platformContainer.querySelector('select[data-field="currentPlatformDependencies"]');
                        const availablePlatDepsSelect = platformContainer.querySelector('select[data-field="availablePlatformDependencies"]');

                        if (!currentPlatDepsSelect || !availablePlatDepsSelect) {
                             console.error("Could not find platform dependency select lists for service index:", index);
                             if(textInput) textInput.value = '';
                             return null;
                         }

                        const inCurrentList = Array.from(currentPlatDepsSelect.options).some(opt => opt.value === newDepName);
                        const inAvailableList = Array.from(availablePlatDepsSelect.options).some(opt => opt.value === newDepName);

                        if (inCurrentList || inAvailableList) {
                             alert(`Platform dependency "${newDepName}" is already listed for this service.`);
                             if(textInput) textInput.value = '';
                             return null; // Already present for this service, do nothing more
                         }

                        // If it doesn't exist globally, add it to the global data list
                        if (!alreadyExistsGlobally) {
                            currentSystemData.platformDependencies.push(newDepName);
                            console.log("Added new global platform dependency to data:", newDepName);
                        } else {
                            console.log(`"${newDepName}" already exists globally.`);
                        }

                        // --- ALWAYS RETURN THE ITEM ---
                        // Let createDualListContainer handle adding it to the 'Available' list for *this instance*.
                        // The fact it's in currentSystemData.platformDependencies ensures it's available later.
                        if (textInput) textInput.value = ''; // Clear the input field
                        return { value: newDepName, text: newDepName };
                    }
        );
        serviceDetails.appendChild(platformContainer);
        serviceDetails.appendChild(document.createElement('br'));
        // ---------------------------

         // --- Service Dependencies ---
         const currentSvcDeps = (service.serviceDependencies || []).map(dep => ({ value: dep, text: dep }));
         const availableSvcDeps = (currentSystemData.services || [])
             .filter(s => s.serviceName !== service.serviceName && !(service.serviceDependencies || []).includes(s.serviceName))
             .map(s => ({ value: s.serviceName, text: s.serviceName }));
         const serviceDepContainer = createDualListContainer(
             index, 'Current Service Deps:', 'Available Services:',
             currentSvcDeps, availableSvcDeps,
             'currentServiceDependencies', 'availableServiceDependencies',
             (movedSvc, direction, serviceIdx) => { // Callback updates data model directly
                 const targetService = currentSystemData.services[serviceIdx];
                 if (!targetService.serviceDependencies) targetService.serviceDependencies = [];
                 if (direction === 'add') {
                     if (!targetService.serviceDependencies.includes(movedSvc)) targetService.serviceDependencies.push(movedSvc);
                 } else {
                     targetService.serviceDependencies = targetService.serviceDependencies.filter(d => d !== movedSvc);
                 }
             },
             true // multiSelectLeft = true
             // Cannot add new *services* from here, only from main 'Add New Service' button
         );
         serviceDetails.appendChild(serviceDepContainer);
         serviceDetails.appendChild(document.createElement('br'));
        // ------------------------

        // --- APIs Section ---
        let apisContainer = document.createElement('div');
        apisContainer.className = 'apis-container';
        let apisLabel = document.createElement('h5');
        apisLabel.innerText = 'APIs:'; apisLabel.style.marginTop = '15px';
        apisContainer.appendChild(apisLabel);

        const allApisList = (currentSystemData.services || []).flatMap(s => (s.apis || []).map(a => a.apiName));

        (service.apis || []).forEach((api, apiIndex) => {
            let apiDiv = document.createElement('div');
            apiDiv.className = 'api-edit';

            let apiNameLabel = document.createElement('label'); apiNameLabel.innerText = 'API Name:';
            let apiNameInput = document.createElement('input'); apiNameInput.type = 'text'; apiNameInput.value = api.apiName || '';
            apiNameInput.setAttribute('data-service-index', index); apiNameInput.setAttribute('data-api-index', apiIndex); apiNameInput.setAttribute('data-field', 'apiName');
            apiNameInput.addEventListener('change', handleApiInputChange); // Use shared handler
            apiDiv.appendChild(apiNameLabel); apiDiv.appendChild(document.createElement('br'));
            apiDiv.appendChild(apiNameInput); apiDiv.appendChild(document.createElement('br'));

            let apiDescLabel = document.createElement('label'); apiDescLabel.innerText = 'API Description:';
            let apiDescTextarea = document.createElement('textarea'); apiDescTextarea.rows = 2; apiDescTextarea.style.width = '90%'; apiDescTextarea.value = api.apiDescription || '';
            apiDescTextarea.setAttribute('data-service-index', index); apiDescTextarea.setAttribute('data-api-index', apiIndex); apiDescTextarea.setAttribute('data-field', 'apiDescription');
            apiDescTextarea.addEventListener('change', handleApiInputChange); // Use shared handler
            apiDiv.appendChild(apiDescLabel); apiDiv.appendChild(document.createElement('br'));
            apiDiv.appendChild(apiDescTextarea); apiDiv.appendChild(document.createElement('br'));

            // API Dependencies Dual List
            const currentApiDeps = (api.dependentApis || []).map(dep => ({ value: dep, text: dep }));
            const availableApiDeps = allApisList
                .filter(aName => aName !== api.apiName && !(api.dependentApis || []).includes(aName))
                .map(aName => ({ value: aName, text: aName }));
            const apiDepsContainer = createDualListContainer(
                 apiIndex, // Context is the API index within the service
                 'Current API Deps:', 'Available APIs:',
                 currentApiDeps, availableApiDeps,
                 'currentDependentApis', 'availableApis',
                 (movedApi, direction, currentApiIndex) => { // Callback updates data model directly
                     const targetService = currentSystemData.services[index]; // Outer service index
                     const targetApi = targetService?.apis[currentApiIndex];
                     if (targetApi) {
                         if (!targetApi.dependentApis) targetApi.dependentApis = [];
                         if (direction === 'add') {
                             if (!targetApi.dependentApis.includes(movedApi)) targetApi.dependentApis.push(movedApi);
                         } else {
                             targetApi.dependentApis = targetApi.dependentApis.filter(d => d !== movedApi);
                         }
                     }
                 },
                 true // multiSelectLeft = true
                 // Cannot add *new* APIs here, only via the service's 'Add New API' button
             );
             apiDiv.appendChild(apiDepsContainer);
             apiDiv.appendChild(document.createElement('br'));


            let deleteApiButton = document.createElement('button'); deleteApiButton.type = 'button'; deleteApiButton.innerText = 'Delete API';
            deleteApiButton.onclick = () => deleteApi(index, apiIndex, containerId); // Pass containerId
            apiDiv.appendChild(deleteApiButton);

            apisContainer.appendChild(apiDiv);
        });

        let addApiButton = document.createElement('button'); addApiButton.type = 'button'; addApiButton.innerText = 'Add New API';
        addApiButton.onclick = () => addNewApi(index, containerId); // Pass containerId
        apisContainer.appendChild(addApiButton);
        serviceDetails.appendChild(apisContainer);
        serviceDetails.appendChild(document.createElement('br'));
        // --------------------

        // --- Action Buttons ---
        let deleteServiceButton = document.createElement('button'); deleteServiceButton.type = 'button'; deleteServiceButton.innerText = 'Delete Service';
        deleteServiceButton.style.color = 'red'; deleteServiceButton.style.marginLeft = '10px';
        deleteServiceButton.onclick = () => { if (confirm('Are you sure?')) deleteService(index, containerId); }; // Pass containerId
        serviceDetails.appendChild(deleteServiceButton);

        let saveServiceButton = document.createElement('button'); saveServiceButton.type = 'button'; saveServiceButton.innerText = 'Save Service Changes';
        saveServiceButton.style.marginLeft = '10px';
        saveServiceButton.onclick = () => saveServiceChanges(index); // Saves only this service's state from currentSystemData
        serviceDetails.appendChild(saveServiceButton);
        // --------------------

        serviceDiv.appendChild(serviceHeader);
        serviceDiv.appendChild(serviceDetails);
        servicesDiv.appendChild(serviceDiv);
    }); // End services.forEach

    // --- Shared Event Handlers for Inputs ---
    function handleServiceInputChange(event) {
        const serviceIndex = parseInt(event.target.getAttribute('data-service-index'));
        const field = event.target.getAttribute('data-field');
        const value = event.target.value;
        if (serviceIndex >= 0 && serviceIndex < currentSystemData.services.length) {
            currentSystemData.services[serviceIndex][field] = value;
            // If service name changed, update the header
            if (field === 'serviceName') {
                 const header = event.target.closest('.service-edit')?.querySelector('h4');
                 if (header) {
                     const indicatorSpan = header.querySelector('span');
                     header.textContent = `Service: ${value || 'New Service'}`; // Recreate text
                     if(indicatorSpan) header.insertBefore(indicatorSpan, header.firstChild); // Add indicator back
                 }
            }
        }
    }

     function handleApiInputChange(event) {
        const serviceIndex = parseInt(event.target.getAttribute('data-service-index'));
        const apiIndex = parseInt(event.target.getAttribute('data-api-index'));
        const field = event.target.getAttribute('data-field');
        const value = event.target.value;
        if (serviceIndex >= 0 && serviceIndex < currentSystemData.services.length &&
            apiIndex >= 0 && apiIndex < currentSystemData.services[serviceIndex].apis.length) {
            currentSystemData.services[serviceIndex].apis[apiIndex][field] = value;
        }
    }
    // ------------------------------------

    // --- Helper to find current expanded service index ---
     function findExpandedServiceIndex(containerId = 'editServicesManagement') { // Default containerId
         const servicesContainerDiv = document.getElementById(containerId);
         if (!servicesContainerDiv) {
             console.warn("findExpandedServiceIndex: Could not find container with ID:", containerId);
             return -1;
         }
         const serviceDetailDivs = servicesContainerDiv.querySelectorAll('.service-details'); // Use class selector
         for (let i = 0; i < serviceDetailDivs.length; i++) {
             // Check the display style directly
             if (serviceDetailDivs[i].style.display === 'block') {
                 // Find the parent service-edit div to get the index attribute
                 const parentEditDiv = serviceDetailDivs[i].closest('.service-edit');
                 if (parentEditDiv) {
                     const indexAttr = parentEditDiv.getAttribute('data-service-index');
                     if (indexAttr !== null) {
                         return parseInt(indexAttr); // Return the index from the attribute
                     }
                 }
             }
         }
         return -1; // Not found or none expanded
     }

} // --- End displayServicesForEditing ---

function saveServiceChanges(serviceIndex) {
    // Perform validation (optional)
    const service = currentSystemData.services[serviceIndex];
    if (!service.serviceName || service.serviceName.trim() === '') {
        alert('Service name cannot be empty.');
        return;
    }

    const serviceEditDivs = document.querySelectorAll('.service-edit');
    const currentServiceDiv = serviceEditDivs[serviceIndex];

    // Update Platform Dependencies
    const currentDepsSelect = currentServiceDiv.querySelector('select[data-field="currentPlatformDependencies"]');
    const selectedDependencies = Array.from(currentDepsSelect.options).map(option => option.value);
    service.platformDependencies = selectedDependencies;

    // Update Service Dependencies
    const currentServiceDepsSelect = currentServiceDiv.querySelector('select[data-field="currentServiceDependencies"]');
    const selectedServiceDependencies = Array.from(currentServiceDepsSelect.options).map(option => option.value);
    service.serviceDependencies = selectedServiceDependencies;

    // **Update APIs and their Dependent APIs**
    const apisContainer = currentServiceDiv.querySelector('.apis-container');
    const apiEditDivs = apisContainer.querySelectorAll('.api-edit');

    service.apis.forEach((api, apiIndex) => {
        const apiDiv = apiEditDivs[apiIndex];

        // Update API fields
        const apiNameInput = apiDiv.querySelector('input[data-field="apiName"]');
        api.apiName = apiNameInput.value;

        const apiDescTextarea = apiDiv.querySelector('textarea[data-field="apiDescription"]');
        api.apiDescription = apiDescTextarea.value;

        // Update Dependent APIs
        const currentDependentApisSelect = apiDiv.querySelector('select[data-field="currentDependentApis"]');
        const selectedDependentApis = Array.from(currentDependentApisSelect.options).map(option => option.value);
        api.dependentApis = selectedDependentApis;
    });

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    systems[currentSystemData.systemName] = currentSystemData;
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    alert('Service changes saved.');

    // **Update the Team Breakdown and Service Dependencies Tables**
    generateTeamTable(currentSystemData);
    generateServiceDependenciesTable();
    
    // Optionally collapse the service details or provide additional feedback
}

/** Add New Service in Edit Form **/
function addNewEditService() {
    // Create a new service object with default values
    const newService = {
        serviceName: 'New Service',
        serviceDescription: '',
        owningTeamId: '',
        apis: [],
        serviceDependencies: [],
        platformDependencies: []
    };

    // Add to the system data
    if (!currentSystemData.services) {
        currentSystemData.services = [];
    }
    currentSystemData.services.push(newService);

    // Refresh the service editing display for the edit form
    displayServicesForEditing(currentSystemData.services, 'editServicesManagement');
}

/** Add New Service **/

/** REVISED Add New Service - Simplified Refresh Call **/
function addNewService() {
    // Create a new service object with default values
    const newService = {
        serviceName: 'New Service ' + ((currentSystemData.services?.length || 0) + 1),
        serviceDescription: '',
        owningTeamId: null,
        apis: [],
        serviceDependencies: [],
        platformDependencies: []
    };

    // Add to the system data
    if (!currentSystemData.services) {
        currentSystemData.services = [];
    }
    currentSystemData.services.push(newService);
    console.log("Added new service to data:", newService); // Log data addition

    // --- Refresh BOTH Service and Team editing displays ---
    // Call display functions WITHOUT trying to preserve expanded index for now
    console.log("Refreshing service editors...");
    try {
        displayServicesForEditing(currentSystemData.services, 'editServicesManagement');
    } catch (error) {
         console.error("Error during displayServicesForEditing:", error);
         alert("Error refreshing service list. Check console.");
         return; // Stop if service display fails
    }


    console.log("Refreshing team editors...");
    try {
         displayTeamsForEditing(currentSystemData.teams);
     } catch (error) {
         console.error("Error during displayTeamsForEditing:", error);
         alert("Error refreshing team list. Check console.");
         return; // Stop if team display fails
     }
    console.log("UI refresh attempt complete after adding service.");
    // ------------------------------------------------------
}

/** Delete Service **/

function deleteService(serviceIndex, containerId) {
    // Remove the service from the system data
    currentSystemData.services.splice(serviceIndex, 1);

    // **Update the Team Breakdown and Service Dependencies Tables**
    generateTeamTable(currentSystemData);
    generateServiceDependenciesTable();
    
    // Refresh the service editing display
    displayServicesForEditing(currentSystemData.services, containerId,serviceIndex);
}

/** Add New API **/

/** REVISED Add New API - Refresh UI **/
function addNewApi(serviceIndex, containerId = 'editServicesManagement') { // Added containerId parameter
    // Find the service
    if (!currentSystemData || !currentSystemData.services || serviceIndex >= currentSystemData.services.length) {
        console.error("Cannot add API, invalid service index:", serviceIndex);
        return;
    }
    const service = currentSystemData.services[serviceIndex];

    // Create a new API object with default values
    const newApi = {
        apiName: 'New API ' + ((service.apis?.length || 0) + 1), // Slightly more unique default name
        apiDescription: '',
        dependentApis: []
    };

    // Add to the service's APIs
    if (!service.apis) {
        service.apis = [];
    }
    service.apis.push(newApi);

    // --- Refresh the service editing display ---
    // Re-rendering ensures all 'Available APIs' lists are updated
    console.log(`Refreshing service editors after adding new API to service index ${serviceIndex}...`);
    displayServicesForEditing(currentSystemData.services, containerId, serviceIndex); // Try to re-expand the current service
    // -----------------------------------------
}

/** Delete API **/

function deleteApi(serviceIndex, apiIndex, containerId) {
    // Remove the API from the service's APIs
    currentSystemData.services[serviceIndex].apis.splice(apiIndex, 1);

    // Refresh the service editing display
    displayServicesForEditing(currentSystemData.services, containerId, serviceIndex);
}


/** Add New Team **/

/** Updated Add New Team **/
function addNewTeam() {
    // Generate a unique teamId (simple approach for now)
    const newTeamId = 'team-' + Date.now();

    // Create a new team object with the updated default structure
    const newTeam = {
        teamId: newTeamId,
        teamName: '', // Blank initially
        teamIdentity: '', // Blank initially
        teamDescription: '', // Added field
        fundedHeadcount: 0, // Default funded HC
        buildersInSeats: 0, // Default BIS (no engineers yet)
        engineers: [], // Start with an empty array for engineers
        sdmId: null, // No default SDM assigned
        pmtId: null  // No default PMT assigned
        // Removed sdmName, pmtName as they are derived via IDs
    };

    // Add to the system data
    if (!currentSystemData.teams) {
        currentSystemData.teams = [];
    }
    currentSystemData.teams.push(newTeam);

    // Get the index of the newly added team
    const newTeamIndex = currentSystemData.teams.length - 1;

    // Refresh the team editing display and expand the new team
    // Pass -1 if displayTeamsForEditing doesn't handle expansion correctly, or pass newTeamIndex
    displayTeamsForEditing(currentSystemData.teams, newTeamIndex);
}

/** Delete Team **/

function deleteTeam(index) {
    const team = currentSystemData.teams[index];
    const confirmDelete = confirm(`Are you sure you want to delete the team "${team.teamName}"? This action cannot be undone.`);
    if (confirmDelete) {
        // Remove the team from currentSystemData.teams
        currentSystemData.teams.splice(index, 1);

        // Update services that reference this team
        currentSystemData.services.forEach(service => {
            if (service.owningTeamId === team.teamId) {
                service.owningTeamId = null;
            }
        });

        // Update uniqueEngineers array
        uniqueEngineers = uniqueEngineers.filter(engineer => engineer.teamId !== team.teamId);

        // Update team assignments in engineers
        currentSystemData.teams.forEach(t => {
            if (t.teamId !== team.teamId) {
                const engineers = t.engineerNames ? t.engineerNames.split(',').map(name => name.trim()) : [];
                t.engineerNames = engineers.filter(name => {
                    const engineer = uniqueEngineers.find(e => e.engineerName === name);
                    return engineer && engineer.teamId === t.teamId;
                }).join(', ');
            }
        });

        // Save changes to local storage
        saveSystemChanges();
        
        // Notify the user
        alert(`Team "${team.teamName}" has been deleted.`);

        // Refresh the teams editing interface
        displayTeamsForEditing(currentSystemData.teams);

        // Update other UI components
        generateTeamTable(currentSystemData);
        generateTeamVisualization(currentSystemData);
        generateServiceDependenciesTable();
        populateServiceSelection();
        populateDependencyServiceSelection();
        updateServiceVisualization();
        updateDependencyVisualization();
    }
}

/** Save System Details **/

function saveSystemDetails() {
    // Get updated system name and description
    console.log("*** 1 document.getElementById('systemNameInput').value",document.getElementById('systemNameInput').value);    
    console.log("*** 2 document.getElementById('systemDescriptionInput'",document.getElementById('systemDescriptionInput').value);    
    
    const systemNameInput = document.getElementById('systemNameInput');
    const systemDescriptionTextarea = document.getElementById('systemDescriptionInput');

    console.log("*** 3 systemNameInput = ", systemNameInput.value);
    console.log("*** 4 systemDescriptionTextarea = ", systemDescriptionTextarea.value);  
  
    const oldSystemName = currentSystemData.systemName;
    const newSystemName = systemNameInput.value.trim();

    if (!newSystemName) {
        alert('System name cannot be empty.');
        return;
    }

    currentSystemData.systemName = newSystemName;
    currentSystemData.systemDescription = systemDescriptionTextarea.value.trim();

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');

    systems[newSystemName] = currentSystemData;

    console.log('Saving to local storage:', systems);

    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    alert('System details saved, please continue to update the services and teams. Note: If you changed the system name, it is treated as a new system');

    if (currentMode == Modes.EDITING) {
      // Update UI components
      generateTeamTable(currentSystemData);
      generateServiceDependenciesTable();
      updateServiceVisualization();
      updateDependencyVisualization();
    }
}

/** Save All Changes **/

/** REVISED Save All Changes - Handles Creation and Updates */
function saveAllChanges() {
//    if (currentMode !== Modes.CREATING && currentMode !== Modes.EDITING) {
//         alert('Not in creation or edit mode. No changes to save.');
//         return;
//    }

    // --- Get Final System Name and Description from Form ---
    const systemNameInput = document.getElementById('systemNameInput');
    const systemDescriptionTextarea = document.getElementById('systemDescriptionInput');
    const finalSystemName = systemNameInput.value.trim();
    const finalSystemDescription = systemDescriptionTextarea.value.trim();

    if (!finalSystemName) {
        alert('System Name cannot be empty. Please enter a name before saving.');
        systemNameInput.focus(); // Focus the input field
        return;
    }
    // Basic check for description, can be optional
    if (!finalSystemDescription) {
         if (!confirm('System Description is empty. Save anyway?')) {
             systemDescriptionTextarea.focus();
             return;
         }
    }
    // --------------------------------------------------

    // --- Update currentSystemData with final name/desc ---
    // This ensures the object being saved has the correct top-level info
    const oldSystemNameKey = currentSystemData.systemName; // Store the name *before* updating
    currentSystemData.systemName = finalSystemName;
    currentSystemData.systemDescription = finalSystemDescription;
    console.log(`Attempting to save system as: "${finalSystemName}"`);
    // -----------------------------------------------------

    // --- Perform Validation ---
    // Ensure engineer assignments are valid before saving
    if (!validateEngineerAssignments()) {
         // If validation fails, revert name/desc change in the data object
         // to avoid potential mismatches if user cancels or tries again.
         currentSystemData.systemName = oldSystemNameKey;
         currentSystemData.systemDescription = document.getElementById('systemDescriptionInput').value; // Or revert based on how it was before validation
         return; // Stop the save
    }
    // Add other validation checks here if needed (e.g., required fields for teams/services)
    // ------------------------
    
    // --- Save to Local Storage ---
    try {
        const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');

         // Check if renaming an existing system or creating a new one
         if (currentMode === Modes.EDITING && oldSystemNameKey && oldSystemNameKey !== finalSystemName) {
             // If the name changed during editing, remove the old entry
             if (systems[oldSystemNameKey]) {
                 delete systems[oldSystemNameKey];
                 console.log(`Removed old system entry for key: "${oldSystemNameKey}" due to rename.`);
             }
         }
         // Check if overwriting another system with the new name (relevant for 'Create New' if name exists)
         if (systems[finalSystemName] && (currentMode === Modes.CREATING || oldSystemNameKey !== finalSystemName)) {
            if (!confirm(`A system named "${finalSystemName}" already exists. Overwrite it?`)) {
                // Revert data object name change before cancelling
                currentSystemData.systemName = oldSystemNameKey;
                currentSystemData.systemDescription = document.getElementById('systemDescriptionInput').value; // Revert desc too
                return; // User cancelled overwrite
            }
         }


        // Save the current data under the final name
        systems[finalSystemName] = currentSystemData;
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

        alert(`System "${finalSystemName}" saved successfully.`);

        // --- Post-Save Actions ---
        if (currentMode === Modes.CREATING) {
             // After successfully creating, switch to Browse mode for the new system
             currentMode = Modes.Browse;
             // Optionally reload the view for the newly saved system
             loadSavedSystem(finalSystemName); // Load it properly
        } else {
             // If editing, maybe exit edit mode or refresh views
              exitEditMode(); // Go back to Browse mode
        }
        // -----------------------

    } catch (error) {
        console.error("Error saving system to local storage:", error);
        alert("An error occurred while trying to save the system. Please check the console for details.");
         // Revert data object name change on error
         currentSystemData.systemName = oldSystemNameKey;
         currentSystemData.systemDescription = document.getElementById('systemDescriptionInput').value;
    }
    // -------------------------
}

/** REVISED (v2) Exit Edit Mode - Calls showSystemOverview which uses switchView */
function exitEditMode() {
    if (currentMode === Modes.CREATING) {
        // If cancelling creation, go all the way home
        if (confirm('Are you sure you want to cancel creating the new system? All unsaved changes will be lost.')) {
            returnToHome(); // Use the refactored returnToHome
        }
        // If user cancels the confirm dialog, do nothing, stay in edit mode.
    } else {
        // If cancelling an edit, simply go back to the system overview
        console.log("Exiting edit mode, returning to system overview...");
        showSystemOverview(); // Use the refactored showSystemOverview
    }
}
 // No need to add exitEditMode to window, called by button onclick

/** Updated function to handle "Create New Software System" button click **/
function createNewSystem() {
    currentMode = Modes.CREATING;

    // Default Senior Managers Data
    const defaultSeniorManagersData = [
        { seniorManagerId: 'srMgr1', seniorManagerName: 'Enter Sr. Manager Name Here' }
    ];

    // Default SDMs Data (with seniorManagerId)
    const defaultSDMsData = [
        { sdmId: 'sdm1', sdmName: 'Enter SDM Name Here', seniorManagerId: 'srMgr1' } // Added seniorManagerId
    ];

    // Default PMTs Data
    const defaultPMTsData = [
        { pmtId: 'pmt1', pmtName: 'Enter PMT Name Here' }
    ];

    // Default Teams Data (using new structure)
    const defaultTeamsData = [
        {
            teamId: 'team1', // Will be regenerated on save if needed, but useful for default service
            teamName: 'Enter Team Name Here',
            teamIdentity: 'Enter Team Identity Here',
            teamDescription: 'Enter Team Description Here...', // Added description field based on usage elsewhere
            fundedHeadcount: 1, // Example default
            buildersInSeats: 1, // Matches the single default engineer
            engineers: [ // Changed from engineerNames string to engineers array
                { name: 'Enter Engineer Name Here', level: 2 } // Example default engineer with level
            ],
            awayTeamMembers: [], // Initialize away team members
            sdmId: 'sdm1', // Reference to the default SDM
            pmtId: 'pmt1', // Reference to the default PMT
            teamCapacityAdjustments: {
                leaveUptakeEstimates: [], // Empty by default
                variableLeaveImpact: { // New structure
                    maternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                    paternity:  { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                    familyResp: { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 },
                    medical:    { affectedSDEs: 0, avgDaysPerAffectedSDE: 0 }
                },
                teamActivities: [],
                recurringOverhead: [],
                avgOverheadHoursPerWeekPerSDE: 0 // Add new field for simple UI
            }
        }
    ];

    // Default Services Data
    const defaultServicesData = [
        {
            serviceName: 'Enter Service Name Here',
            serviceDescription: 'Enter Service Description Here...',
            owningTeamId: 'team1', // Reference to the default Team
            apis: [
                {
                    apiName: 'Enter API Name Here',
                    apiDescription: 'Enter API Description Here...',
                    dependentApis: []
                }
            ],
            serviceDependencies: [],
            platformDependencies: []
        }
    ];

    // Default System Data (including seniorManagers)
    const defaultSystemData = {
        systemName: '', // Start blank, user must enter in form
        systemDescription: '', // Start blank, user must enter in form
        seniorManagers: defaultSeniorManagersData, // Added
        sdms: defaultSDMsData,
        pmts: defaultPMTsData,
        teams: defaultTeamsData,
        services: defaultServicesData,
        platformDependencies: [],
        // Capacity constraints configuration
        capacityConfiguration: {
            workingDaysPerYear: 261, // To be configured - but assume 261
            standardHoursPerDay: 8,  // Default
            globalConstraints: {
                publicHolidays: null, // To be configured
                orgEvents: [
                    // User will add events via UI later
                ]
            },
            leaveTypes: [ // Define standard leave types globally
                { id: "annual", name: "Annual Leave", defaultEstimatedDays: 0 },
                { id: "sick", name: "Sick Leave", defaultEstimatedDays: 0 },
                { id: "study", name: "Study Leave", defaultEstimatedDays: 0 },
                { id: "inlieu", name: "Time off In-lieu Leave", defaultEstimatedDays: 0 }
                //{ id: "paternity", name: "Paternity Leave", defaultEstimatedDays: 0 },
                //{ id: "family", name: "Family Responsibility", defaultEstimatedDays: 0 }
            ]
        },
        yearlyInitiatives: [],
        // *** NEW: Add placeholder for calculated capacity metrics ***
        calculatedCapacityMetrics: null
        // **********************************************************
    };

    // Assign to currentSystemData
    currentSystemData = defaultSystemData;

    // Use enterEditMode (which now uses switchView) to show the edit form
    enterEditMode(true); // Pass true flag for creation mode
}

/** REVISED (v3) Return to Home using switchView */
function returnToHome() {
    console.log("Returning to home view (Clearing System)...");
    switchView(null); // Passing null shows the home screen and resets state
    console.log("Home view displayed.");
}
window.returnToHome = returnToHome;

function resetToDefaults() {
    if (confirm('This will erase all your saved systems and restore the default sample systems. Do you want to proceed?')) {
        // Clear the local storage for systems
        localStorage.removeItem(LOCAL_STORAGE_KEY);

        // Re-initialize with sample systems
        const systems = {
            'StreamView': sampleSystemDataStreamView,
            'ConnectPro': sampleSystemDataContactCenter
        };
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

        alert('Systems have been reset to defaults.');

        // Return to the home page
        returnToHome();
    }
}

function populateServiceSelection() {
    const serviceSelection = document.getElementById('serviceSelection');
    serviceSelection.innerHTML = ''; // Clear existing options

    // Add "All Services View" option
    let allServicesOption = document.createElement('option');
    allServicesOption.value = 'all';
    allServicesOption.text = 'All Services View';
    serviceSelection.appendChild(allServicesOption);

    // Add individual services
    currentSystemData.services.forEach(service => {
        let option = document.createElement('option');
        option.value = service.serviceName;
        option.text = service.serviceName;
        serviceSelection.appendChild(option);
    });
}

function getServiceDependencies(service, collectedServices = {}, visitedServices = {}) {
    if (!service || visitedServices[service.serviceName]) {
        return [];
    }
    visitedServices[service.serviceName] = true;
    collectedServices[service.serviceName] = service;

    // Recursively collect dependencies
    service.serviceDependencies.forEach(depName => {
        const depService = currentSystemData.services.find(s => s.serviceName === depName);
        getServiceDependencies(depService, collectedServices, visitedServices);
    });

    return Object.values(collectedServices);
}

function updateServiceVisualization() {
    const selectedService = document.getElementById('serviceSelection').value;

    // Ensure the service selection is populated with the latest data
    populateServiceSelection();
    
    if (selectedService === 'all') {
        generateServiceVisualization(currentSystemData.services, null); // No service is selected
    } else {
        // Find the selected service and its dependencies
        const selectedServiceData = currentSystemData.services.find(service => service.serviceName === selectedService);
        const relatedServices = getServiceDependencies(selectedServiceData);

        generateServiceVisualization(relatedServices, selectedService);
    }
}

function generateServiceVisualization(services, selectedServiceName) {
    let svg = d3.select('#serviceSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // Prepare nodes and links data
    let nodes = [];
    let links = [];
    let nodeMap = {};
   
    // Set SVG dimensions
    // Get SVG element and its parent container
    const container = document.getElementById('serviceRelationshipsVisualization'); // Get the container div
    if (!container) {
         console.error("Container #serviceRelationshipsVisualization not found for generateServiceVisualization.");
         return;
    }
    const svgRect = container.getBoundingClientRect(); // Get dimensions of the container
    const width = svgRect.width > 0 ? svgRect.width : 800; // Use container width or default
    // Keep height fixed or get from container style if needed
    const height = parseInt(svg.style('height')) || 600;
    console.log(`generateServiceVisualization calculated width: ${width}, height: ${height}`);

    // Define node radius
    const radius = 20;
   
    // Create a color scale based on teams
    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = currentSystemData.teams.map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Map service names to services for quick lookup
    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    // Create nodes for services
    services.forEach(service => {
        let teamId = service.owningTeamId || 'unassigned';
        let nodeColor = teamColorScale(teamId);

        // Check if this is the selected service
        let isSelected = service.serviceName === selectedServiceName;

        nodes.push({
            id: service.serviceName,
            type: 'service',
            teamId: teamId,
            color: nodeColor,
            isSelected: isSelected
        });
        nodeMap[service.serviceName] = { id: service.serviceName, type: 'service' };
    });

    // Add platform dependencies as nodes
    services.forEach(service => {
        if (service.platformDependencies) {
            service.platformDependencies.forEach(platform => {
                if (!nodeMap[platform]) {
                    nodes.push({ id: platform, type: 'platform', color: '#a04040', isSelected: false }); // Add isSelected property
                    nodeMap[platform] = { id: platform, type: 'platform' };
                }
                // Link service to platform
                links.push({
                    source: service.serviceName,
                    target: platform,
                    type: 'platform-dependency'
                });
            });
        }
    });

    // Create links based on service dependencies
    services.forEach(service => {
        // Service dependencies
        service.serviceDependencies.forEach(dependency => {
            if (nodeMap[dependency]) {
                links.push({
                    source: service.serviceName,
                    target: dependency,
                    type: 'service-dependency'
                });
            }
        });
    });

    // Set up the simulation
    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 30));

    // **Corrected Node Creation and Attribute Setting**

    let node = svg.append('g')
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', d => d.isSelected ? 25 : 20) // Increase radius for selected node
        .attr('fill', d => d.color)
        .attr('stroke', d => d.isSelected ? 'red' : '#fff') // Change stroke color to red for selected node
        .attr('stroke-width', d => d.isSelected ? 4 : 2) // Increase stroke width for selected node
        .call(drag(simulation));

    // Add labels to nodes
    let labels = svg.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 0)
        .attr('dy', 4)
        .attr('text-anchor', 'middle')
        .text(d => d.id)
        .attr('fill', d => d.isSelected ? 'red' : 'black'); // Change text color to red for selected node

    // Tooltip
    let tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let info = '';
        if (d.type === 'service') {
            let service = serviceMap[d.id];
            let team = currentSystemData.teams.find(t => t.teamId === service.owningTeamId);
            info = `<strong>Service Name:</strong> ${service.serviceName}<br>
                    <strong>Description:</strong> ${service.serviceDescription}<br>
                    <strong>Team:</strong> ${team ? `${team.teamName} (${team.teamIdentity})` : 'Unassigned'}`;
        } else if (d.type === 'platform') {
            info = `<strong>Platform Dependency:</strong> ${d.id}`;
        }
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5);
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    // **Add links to the SVG after nodes are created**
    let link = svg.append('g')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-dasharray', d => {
            if (d.type === 'service-dependency') return '5,5';
            else if (d.type === 'platform-dependency') return '10,5';
            else return '1,0';
        })
        .attr('stroke-width', 2);

    // Add legend for teams
    let legendData = currentSystemData.teams.map(team => ({
        teamIdentity: team.teamIdentity,
        color: teamColorScale(team.teamId)
    }));

    let legend = d3.select('#serviceLegend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item');

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
}

//Create a function to populate the dropdown menu with available services.
function populateDependencyServiceSelection() {
    const serviceSelection = document.getElementById('dependencyServiceSelection');
    serviceSelection.innerHTML = ''; // Clear existing options

    // Add individual services
    currentSystemData.services.forEach(service => {
        let option = document.createElement('option');
        option.value = service.serviceName;
        option.text = service.serviceName;
        serviceSelection.appendChild(option);
    });
}

//We need to build a graph with nodes and links, ensuring that nodes are not duplicated and circular dependencies are handled.
//We use a breadth-first search (BFS) traversal to explore both upstream and downstream services, handling cycles by keeping track of visited services.
//We build nodes and links without duplicating nodes.
//Ensure the edges are defined in the correct direction (from upstream to downstream).
function buildDependencyGraph(serviceName) {
    const nodes = [];
    const links = [];
    const nodeMap = {};

    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    const queue = [];
    const visited = new Set();

    queue.push(serviceName);
    visited.add(serviceName);

    while (queue.length > 0) {
        const currentServiceName = queue.shift();
        const currentService = serviceMap[currentServiceName];

        if (!nodeMap[currentServiceName]) {
            nodes.push({ id: currentServiceName, type: 'service' });
            nodeMap[currentServiceName] = true;
        }

        // Process upstream dependencies
        currentService.serviceDependencies.forEach(depName => {
            if (!nodeMap[depName]) {
                nodes.push({ id: depName, type: 'service' });
                nodeMap[depName] = true;
            }
            // Edge from dependency to current service
            links.push({
                source: depName,
                target: currentServiceName,
                type: 'service-dependency',
            });
            if (!visited.has(depName)) {
                visited.add(depName);
                queue.push(depName);
            }
        });

        // Process platform dependencies
        if (currentService.platformDependencies) {
            currentService.platformDependencies.forEach(platform => {
                if (!nodeMap[platform]) {
                    nodes.push({ id: platform, type: 'platform' });
                    nodeMap[platform] = true;
                }
                // Edge from platform to current service
                links.push({
                    source: platform,
                    target: currentServiceName,
                    type: 'platform-dependency',
                });
            });
        }

        // Process downstream dependents
        currentSystemData.services.forEach(service => {
            if (service.serviceDependencies.includes(currentServiceName)) {
                const dependentName = service.serviceName;
                if (!nodeMap[dependentName]) {
                    nodes.push({ id: dependentName, type: 'service' });
                    nodeMap[dependentName] = true;
                }
                // Edge from current service to dependent
                links.push({
                    source: currentServiceName,
                    target: dependentName,
                    type: 'service-dependency',
                });
                if (!visited.has(dependentName)) {
                    visited.add(dependentName);
                    queue.push(dependentName);
                }
            }
        });
    }

    return { nodes, links };
}

//Create functions to build the data structure representing upstream and downstream dependencies.
function buildDependencyTree(serviceName) {
    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    // Recursive function to get upstream dependencies
    function getUpstream(service, visited = new Set()) {
        if (!service || visited.has(service.serviceName)) return null;
        visited.add(service.serviceName);

        let dependencies = [];
        service.serviceDependencies.forEach(depName => {
            const depService = serviceMap[depName];
            const upstreamNode = getUpstream(depService, visited);
            if (upstreamNode) {
                dependencies.push(upstreamNode);
            } else if (depService) {
                dependencies.push({ name: depService.serviceName, children: [] });
            }
        });

        return { name: service.serviceName, children: dependencies };
    }

    // Recursive function to get downstream dependencies
    function getDownstream(service, visited = new Set()) {
        if (!service || visited.has(service.serviceName)) return null;
        visited.add(service.serviceName);

        let dependents = [];
        currentSystemData.services.forEach(otherService => {
            if (otherService.serviceDependencies.includes(service.serviceName)) {
                const downstreamNode = getDownstream(otherService, visited);
                if (downstreamNode) {
                    dependents.push(downstreamNode);
                } else {
                    dependents.push({ name: otherService.serviceName, children: [] });
                }
            }
        });

        return { name: service.serviceName, children: dependents };
    }

    const rootService = serviceMap[serviceName];

    const upstreamTree = getUpstream(rootService);
    const downstreamTree = getDownstream(rootService);

    // Combine upstream and downstream trees
    const treeData = {
        name: rootService.serviceName,
        children: []
    };

    if (upstreamTree && upstreamTree.children.length > 0) {
        treeData.children.push({
            name: 'Upstream Dependencies',
            direction: 'upstream',
            children: upstreamTree.children
        });
    }

    if (downstreamTree && downstreamTree.children.length > 0) {
        treeData.children.push({
            name: 'Downstream Dependencies',
            direction: 'downstream',
            children: downstreamTree.children
        });
    }

    return treeData;
}

/**
 * REVISED (v3) - Generates the force-directed graph for service dependencies.
 * - Adds safeguard for SVG selection.
 * - Initializes link/node/label selections early to prevent ReferenceError in ticked.
 * - Draws legend INSIDE the main SVG element for cohesive layout.
 */
function generateDependencyForceVisualization(selectedServiceName) {
    console.log(`Generating Dependency Force Viz for: ${selectedServiceName}`); // Log entry

    const svg = d3.select('#dependencySvg');

    // --- SAFEGUARD ---
    if (!svg || svg.empty()) {
        console.error("generateDependencyForceVisualization: #dependencySvg element not found or is empty. Cannot generate visualization.");
        const containerDiv = document.getElementById('dependencyVisualization');
        if(containerDiv) {
            containerDiv.innerHTML = '<p style="color: red; text-align: center;">Error: Could not load dependency visualization.</p>';
        }
        return;
    }
    // --- END SAFEGUARD ---

    svg.selectAll('*').remove(); // Clear existing content

    // Get SVG dimensions
    const container = document.getElementById('dependencyVisualization');
    if (!container) {
        console.error("Container #dependencyVisualization not found for getting dimensions.");
        return;
    }
    const svgRect = container.getBoundingClientRect();
    const width = svgRect.width > 0 ? svgRect.width : 800;
    const height = parseInt(svg.style('height')) || 600;
    console.log(`generateDependencyForceVisualization calculated width: ${width}, height: ${height}`);

    // --- Initialize Selections Early ---
    const vizContainer = svg.append('g').attr('class', 'viz-container'); // Group for zoom/pan

    let link = vizContainer.append('g').attr('class', 'links').selectAll('line');
    let node = vizContainer.append('g').attr('class', 'nodes').selectAll('circle');
    let label = vizContainer.append('g').attr('class', 'labels').selectAll('text');
    // --- End Initialization ---

    const { nodes: graphNodes, links: graphLinks } = buildDependencyGraph(selectedServiceName);

    // Assign index to links
    graphLinks.forEach((link, index) => { link.index = index; });

    // Color scale
    const color = d3.scaleOrdinal()
        .domain(['service', 'platform'])
        .range(['#1f77b4', '#ff7f0e']);

    // --- Simulation Setup ---
    const simulation = d3.forceSimulation(graphNodes)
        .force('link', d3.forceLink(graphLinks).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-600))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collide', d3.forceCollide(45))
        .on('tick', ticked);
    // --- End Simulation Setup ---

     // Define arrowheads
     const defs = svg.append('defs');
     defs.selectAll('marker')
        .data(['service-dependency', 'platform-dependency'])
        .join('marker')
            .attr('id', d => `arrow-${d}`)
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 19)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
        .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#999');

    // --- Data Binding and Element Creation ---
    link = link
        .data(graphLinks, d => `${d.source.id}-${d.target.id}`)
        .join('line')
            .attr('stroke-width', 2)
            .attr('marker-end', d => `url(#arrow-${d.type})`)
            .attr('stroke', '#999')
            .attr('stroke-opacity', 0.6)
            .attr('stroke-dasharray', d => d.type === 'platform-dependency' ? '5,5' : '0');

    node = node
        .data(graphNodes, d => d.id)
        .join('circle')
            .attr('r', d => d.id === selectedServiceName ? 15 : 10)
            .attr('fill', d => d.id === selectedServiceName ? 'red' : color(d.type))
            .attr('stroke', '#fff')
            .attr('stroke-width', d => d.id === selectedServiceName ? 3 : 1.5)
            .call(drag(simulation))
            .on('mouseover', handleMouseOver)
            .on('mouseout', handleMouseOut);

    label = label
        .data(graphNodes, d => d.id)
        .join('text')
            .attr('dy', -15)
            .attr('text-anchor', 'middle')
            .text(d => d.id)
            .attr('font-size', '10px')
            .style('pointer-events', 'none') // Prevent labels interfering with node hover
            .attr('font-weight', d => d.id === selectedServiceName ? 'bold' : 'normal')
            .attr('fill', d => d.id === selectedServiceName ? 'red' : 'black');
    // --- End Data Binding ---

    // --- Zoom Setup ---
    const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on('zoom', (event) => {
            vizContainer.attr('transform', event.transform);
        });
    svg.call(zoom);
    // --- End Zoom Setup ---

    // Tooltip Element
    const tooltip = d3.select('body').selectAll('.tooltip').data([null]).join('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    // Highlight State
    let highlightedNodes = new Set();
    let highlightedLinks = new Set();

    // --- Event Handlers ---
    function handleMouseOver(event, d) {
        // Tooltip Logic (same as before)
        let info = '';
        if (d.type === 'service') {
            const service = currentSystemData.services.find(s => s.serviceName === d.id);
            if (service) {
                const upstreams = service.serviceDependencies || [];
                const downstreams = currentSystemData.services.filter(s => (s.serviceDependencies || []).includes(d.id)).map(s => s.serviceName);
                const platformDeps = service.platformDependencies || [];
                info = `<strong>Service:</strong> ${d.id}<br>`;
                info += `<strong>Upstream:</strong> ${upstreams.length > 0 ? upstreams.join(', ') : 'None'}<br>`;
                info += `<strong>Downstream:</strong> ${downstreams.length > 0 ? downstreams.join(', ') : 'None'}<br>`;
                info += `<strong>Platform Deps:</strong> ${platformDeps.length > 0 ? platformDeps.join(', ') : 'None'}`;
            }
        } else if (d.type === 'platform') {
            info = `<strong>Platform:</strong> ${d.id}`;
        }
        tooltip.transition().duration(200).style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');

        // Highlight Logic (same as before)
        highlightedNodes.clear();
        highlightedLinks.clear();
        highlightedNodes.add(d.id);
        graphLinks.forEach(link => {
            if (link.source.id === d.id) { highlightedNodes.add(link.target.id); highlightedLinks.add(link.index); }
            if (link.target.id === d.id) { highlightedNodes.add(link.source.id); highlightedLinks.add(link.index); }
        });
        node.style('opacity', n => highlightedNodes.has(n.id) ? 1 : 0.1);
        label.style('opacity', n => highlightedNodes.has(n.id) ? 1 : 0.1);
        link.style('opacity', l => highlightedLinks.has(l.index) ? 0.9 : 0.1).attr('stroke', l => highlightedLinks.has(l.index) ? '#555' : '#999'); // Make highlighted links darker
    }

    function handleMouseOut() {
        tooltip.transition().duration(500).style('opacity', 0);
        // Remove highlights
        node.style('opacity', 1);
        label.style('opacity', 1);
        link.style('opacity', 0.6).attr('stroke', '#999'); // Restore default opacity and color
        highlightedNodes.clear();
        highlightedLinks.clear();
    }
    // --- End Event Handlers ---

    // --- Ticked Function ---
    function ticked() {
         if (link.empty() || node.empty() || label.empty()) return; // Safeguard

        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
        node
            .attr('cx', d => d.x = Math.max(15, Math.min(width - 15, d.x))) // Adjust radius for boundary
            .attr('cy', d => d.y = Math.max(15, Math.min(height - 15, d.y)));
        label
            .attr('x', d => d.x)
            .attr('y', d => d.y - (d.id === selectedServiceName ? 20 : 15)); // Adjust label position slightly more for selected
    }
    // --- End Ticked Function ---

    // --- Drag Functions ---
    function drag(simulation) {
        function dragstarted(event, d) {
            if(event.sourceEvent) event.sourceEvent.stopPropagation(); // Prevent interference
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x; d.fy = d.y;
        }
        function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null; d.fy = null;
        }
        return d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended);
    }
    // --- End Drag Functions ---

    // --- Legend (REVISED: Append to SVG) ---
    // Remove the old selection of the external div:
    // const legendContainer = d3.select('#dependencyLegend'); // <-- REMOVE THIS LINE

    // Create the legend group INSIDE the main SVG
    const legend = svg.append('g')
        .attr('class', 'dependency-legend-svg') // Use a class specific to SVG legend if needed
        .attr('transform', `translate(20, 20)`); // Position the legend (e.g., top-left)

    const legendItemsData = [
        { label: 'Selected Service', color: 'red', shape: 'circle' },
        { label: 'Other Service', color: color('service'), shape: 'circle' },
        { label: 'Platform', color: color('platform'), shape: 'circle' },
        { label: 'Service Dependency', color: '#999', type: 'line', marker: 'arrow-service-dependency', dash: '0' },
        { label: 'Platform Dependency', color: '#999', type: 'line', marker: 'arrow-platform-dependency', dash: '5,5' }
    ];

    // Append legend items to the SVG group
    legendItemsData.forEach((item, index) => {
        const legendItem = legend.append('g')
            .attr('transform', `translate(0, ${index * 20})`); // Vertical spacing

        if (item.shape === 'circle') {
            legendItem.append('circle')
                .attr('r', 6)
                .attr('cx', 0) // Center the circle at the start of the item
                .attr('cy', 0)
                .attr('fill', item.color)
                .attr('stroke', item.label === 'Selected Service' ? '#fff' : '#ccc') // Outline
                .attr('stroke-width', item.label === 'Selected Service' ? 2 : 1);
            legendItem.append('text')
                .attr('x', 15) // Text starts after the circle
                .attr('y', 4) // Vertically align text
                .text(item.label)
                .style('font-size', '11px');
        } else if (item.type === 'line') {
            legendItem.append('line')
                .attr('x1', -5) // Start line slightly left
                .attr('y1', 0)
                .attr('x2', 15) // End line before text
                .attr('y2', 0)
                .attr('stroke', item.color)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', item.dash)
                .attr('marker-end', `url(#${item.marker})`); // Use marker from main defs
            legendItem.append('text')
                .attr('x', 25) // Text starts after the line
                .attr('y', 4) // Vertically align text
                .text(item.label)
                .style('font-size', '11px');
        }
    });
    // --- End Legend ---

    console.log("Finished generating dependency visualization.");
} // --- End generateDependencyForceVisualization ---

//Create a function to update the visualization when a new service is selected.
function updateDependencyVisualization() {
    const selectedServiceName = document.getElementById('dependencyServiceSelection').value;
    // Ensure the service selection is populated with the latest data
    populateDependencyServiceSelection();
    generateDependencyForceVisualization(selectedServiceName); //forced dependency works best
}


//Create a function to add the legend to the SVG.
//Legend Items: The legend displays the meanings of node colors, shapes, and edge styles.
//Arrowhead Definition: An arrowhead is defined for use in the legend.
function addDependencyLegend(svg) {
    const legendData = [
        { label: 'Selected Service', color: 'red', shape: 'rect' },
        { label: 'Service', color: '#1f77b4', shape: 'rect' },
        { label: 'Platform', color: '#ff7f0e', shape: 'rect' },
        { label: 'Service Dependency', style: 'stroke: #333; stroke-width: 2px;', arrowhead: true },
        { label: 'Platform Dependency', style: 'stroke: #333; stroke-width: 2px; stroke-dasharray: 5,5;', arrowhead: true },
    ];

    const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', 'translate(20, 20)');

    legendData.forEach((item, index) => {
        const legendItem = legend.append('g')
            .attr('transform', `translate(0, ${index * 25})`);

        if (item.shape === 'rect') {
            legendItem.append('rect')
                .attr('x', 0)
                .attr('y', -10)
                .attr('width', 20)
                .attr('height', 20)
                .attr('style', `fill: ${item.color}; stroke: #fff; stroke-width: 1.5px;`);
        } else {
            // Draw line
            const line = legendItem.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', 20)
                .attr('y2', 0)
                .attr('style', item.style);

            if (item.arrowhead) {
                line.attr('marker-end', 'url(#arrowhead)');
            }
        }

        legendItem.append('text')
            .attr('x', 30)
            .attr('y', 5)
            .text(item.label)
            .attr('text-anchor', 'start')
            .attr('font-size', '12px');
    });

    // Define arrowhead for legend lines
    svg.append('defs').append('marker')
        .attr('id', 'arrowhead')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 10)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#333');
}

function generateServiceDependenciesTable() {
    const tbody = document.querySelector('#serviceDependenciesTable tbody');
    tbody.innerHTML = ''; // Clear existing content

    currentSystemData.services.forEach(service => {
        const row = document.createElement('tr');

        // Service Name
        const nameCell = document.createElement('td');
        nameCell.textContent = service.serviceName;
        row.appendChild(nameCell);

        // Description
        const descCell = document.createElement('td');
        descCell.textContent = service.serviceDescription;
        row.appendChild(descCell);

        // Owning Team
        const team = currentSystemData.teams.find(t => t.teamId === service.owningTeamId);
        const teamCell = document.createElement('td');
        teamCell.textContent = team ? team.teamName : 'Unassigned';
        row.appendChild(teamCell);

        // Upstream Dependencies (Services Depended On)
        const upstreamServices = service.serviceDependencies;
        const upstreamCell = document.createElement('td');
        upstreamCell.textContent = upstreamServices.length > 0 ? upstreamServices.join(', ') : 'None';
        row.appendChild(upstreamCell);

        // Platform Dependencies
        const platformDependencies = service.platformDependencies || [];
        const platformCell = document.createElement('td');
        platformCell.textContent = platformDependencies.length > 0 ? platformDependencies.join(', ') : 'None';
        row.appendChild(platformCell);

        // Downstream Dependencies (Services That Depend On This Service)
        const downstreamServices = currentSystemData.services
            .filter(s => s.serviceDependencies.includes(service.serviceName))
            .map(s => s.serviceName);
        const downstreamCell = document.createElement('td');
        downstreamCell.textContent = downstreamServices.length > 0 ? downstreamServices.join(', ') : 'None';
        row.appendChild(downstreamCell);

        tbody.appendChild(row);
    });
}

/** NEW Validation function to check engineer assignments */
function validateEngineerAssignments() {
    if (!currentSystemData || !currentSystemData.teams) {
        console.error("Validation skipped: No team data loaded.");
        return true; // Allow saving if no data? Or return false? Safer to allow.
    }

    const engineerAssignments = new Map(); // Key: engineerName, Value: Set<teamId>
    let isValid = true;
    let errorMessages = [];

    currentSystemData.teams.forEach(team => {
        if (!team || !team.teamId) return; // Skip invalid team entries
        (team.engineers || []).forEach(engineer => {
            if (!engineer || !engineer.name) return; // Skip invalid engineer entries
            const name = engineer.name;
            if (!engineerAssignments.has(name)) {
                engineerAssignments.set(name, new Set());
            }
            engineerAssignments.get(name).add(team.teamId);
        });
    });

    // Check for overallocations
    engineerAssignments.forEach((assignedTeamIds, engineerName) => {
        if (assignedTeamIds.size > 1) {
            isValid = false;
            const teamNames = Array.from(assignedTeamIds).map(tId => {
                const team = currentSystemData.teams.find(t => t.teamId === tId);
                return team ? (team.teamName || team.teamIdentity) : tId;
            }).join(', ');
            errorMessages.push(`Engineer "${engineerName}" is assigned to multiple teams: ${teamNames}.`);
        }
    });

    if (!isValid) {
        alert("Validation Error: Cannot save changes.\n\n" + errorMessages.join("\n"));
    }

    return isValid;
}

/** Updated Save System Changes (used by Save All/Save Team) - Add Validation **/
function saveSystemChanges() {
    // Get updated system name and description (if called directly, maybe redundant)
    const systemNameInput = document.getElementById('systemNameInput');
    const systemDescriptionTextarea = document.getElementById('systemDescriptionInput');
    if (systemNameInput && systemDescriptionTextarea) { // Check if elements exist
         currentSystemData.systemName = systemNameInput.value.trim();
         currentSystemData.systemDescription = systemDescriptionTextarea.value.trim();
    } else if (currentMode === Modes.CREATING || currentMode === Modes.EDITING) {
         // If called during saveAll/saveTeam, these might not be the source of truth anymore
         console.warn("saveSystemChanges called without direct access to system name/desc inputs. Assuming currentSystemData properties are up-to-date.");
    }


    if (!currentSystemData.systemName && (currentMode === Modes.CREATING || currentMode === Modes.EDITING)) {
        alert('System name cannot be empty.');
        return;
    }

    // *** Add validation before saving to local storage ***
    if (!validateEngineerAssignments()) {
        return; // Stop saving if validation fails
    }
    // *********************************************************

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    systems[currentSystemData.systemName] = currentSystemData; // Use potentially updated name as key
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    console.log('System changes saved to local storage.'); // Changed alert to console log

    // Note: UI updates are typically handled by the calling function (like saveTeamChanges or exitEditMode)
}

// Generate a unique ID for new teams
function generateUniqueId() {
    return 'team-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
}

/** REVISED (v2) - Delete System - Prompts user to select a system from the list */
    function deleteSystem() {
        console.log("Initiating system deletion process...");
        // Retrieve the systems from local storage
        const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
        const systemNames = Object.keys(systems);

        // If no systems are saved, alert the user
        if (systemNames.length === 0) {
            alert('No saved systems found to delete.');
            return;
        }

        // --- Create a modal/div to list systems for deletion ---
        // Remove any existing list first
        const existingListDiv = document.getElementById('systemDeleteListDiv');
        if (existingListDiv) {
            document.body.removeChild(existingListDiv);
        }

        let systemListDiv = document.createElement('div');
        systemListDiv.id = 'systemDeleteListDiv'; // Use a distinct ID

        let systemListHtml = '<h2>Select a System to Delete</h2><ul>';
        systemNames.forEach(systemName => {
            // Use template literal for easier reading and onclick generation
            systemListHtml += `
                <li style="margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <span>${systemName}</span>
                    <button onclick="confirmAndDeleteSystem('${systemName}')" style="margin-left: 15px; padding: 3px 8px; font-size: 0.9em; color: red; border-color: red;">Delete</button>
                </li>`;
        });
        systemListHtml += '</ul>';
        systemListDiv.innerHTML = systemListHtml;

        // Add a close button
        let closeButton = document.createElement('button');
        closeButton.innerText = 'Cancel';
        closeButton.style.marginTop = '15px';
        closeButton.onclick = function() {
             if (systemListDiv.parentNode === document.body) { // Check if still attached before removing
                 document.body.removeChild(systemListDiv);
            }
        };
        systemListDiv.appendChild(closeButton);

        // Style the div (similar to showSavedSystems)
        systemListDiv.style.position = 'fixed';
        systemListDiv.style.top = '50%';
        systemListDiv.style.left = '50%';
        systemListDiv.style.transform = 'translate(-50%, -50%)';
        systemListDiv.style.backgroundColor = '#fff';
        systemListDiv.style.padding = '20px';
        systemListDiv.style.border = '1px solid #ccc';
        systemListDiv.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)'; // Add shadow
        systemListDiv.style.zIndex = '1001'; // Ensure it's above other elements
        systemListDiv.style.maxHeight = '80vh'; // Prevent excessive height
        systemListDiv.style.overflowY = 'auto'; // Add scroll if needed
        systemListDiv.style.minWidth = '300px'; // Ensure reasonable width


        // Append the div to the body
        document.body.appendChild(systemListDiv);
        console.log("Delete system prompt displayed.");
    }
    // Ensure it's globally accessible if called directly via onclick
    window.deleteSystem = deleteSystem;


    /** NEW Helper Function: Confirms and deletes the specified system */
    function confirmAndDeleteSystem(systemName) {
        console.log(`Attempting to delete system: ${systemName}`);
        if (!systemName) {
            console.error("confirmAndDeleteSystem called without systemName.");
            return;
        }

        if (confirm(`Are you sure you want to permanently delete the system "${systemName}"? This action cannot be undone.`)) {
            try {
                const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');

                if (systems[systemName]) {
                    delete systems[systemName]; // Remove the system entry
                    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems)); // Save updated data
                    console.log(`System "${systemName}" deleted successfully.`);
                    alert(`System "${systemName}" has been deleted.`);

                    // Close the delete prompt modal
                    const listDiv = document.getElementById('systemDeleteListDiv');
                    if (listDiv && listDiv.parentNode === document.body) {
                        document.body.removeChild(listDiv);
                    }

                    // If the deleted system *was* the currently loaded one (unlikely from home screen, but good practice)
                    if (currentSystemData && currentSystemData.systemName === systemName) {
                        console.log("Deleted system was the currently loaded one. Returning to home.");
                        returnToHome(); // Reset UI fully
                    }

                } else {
                    console.warn(`System "${systemName}" not found in local storage for deletion.`);
                    alert(`Error: System "${systemName}" could not be found for deletion.`);
                    // Optionally refresh the list here if it's still visible
                     const listDiv = document.getElementById('systemDeleteListDiv');
                     if (listDiv) {
                        document.body.removeChild(listDiv); // Remove the old list
                        deleteSystem(); // Re-show the updated list
                     }
                }
            } catch (error) {
                console.error("Error deleting system from local storage:", error);
                alert("An error occurred while deleting the system. Please check the console.");
            }
        } else {
            console.log(`Deletion cancelled for system: ${systemName}`);
        }
    }
    // Make helper globally accessible for onclick
    window.confirmAndDeleteSystem = confirmAndDeleteSystem;

/** REVISED Builds hierarchical data for Organogram - Adds Away-Team Info */
function buildHierarchyData() {
    console.log("Building hierarchy data with away-team info...");
    if (!currentSystemData) return null;

    // Create maps for efficient lookup
    const sdmMap = new Map((currentSystemData.sdms || []).map(sdm => [sdm.sdmId, { ...sdm, children: [], type: 'sdm' }])); // Add type
    const srMgrMap = new Map((currentSystemData.seniorManagers || []).map(sr => [sr.seniorManagerId, { ...sr, children: [], type: 'srMgr' }])); // Add type

    // Nest SDMs under Senior Managers
    sdmMap.forEach(sdm => {
        if (sdm.seniorManagerId && srMgrMap.has(sdm.seniorManagerId)) {
            srMgrMap.get(sdm.seniorManagerId).children.push(sdm);
        } else {
            // Handle SDMs without a valid Senior Manager
            const unassignedSrMgrKey = 'unassigned-sr-mgr';
            if (!srMgrMap.has(unassignedSrMgrKey)) {
                srMgrMap.set(unassignedSrMgrKey, { seniorManagerId: unassignedSrMgrKey, seniorManagerName: 'Unassigned Senior Manager', children: [], type: 'srMgr' });
            }
            if(sdm && sdm.sdmId) srMgrMap.get(unassignedSrMgrKey).children.push(sdm);
        }
    });

    // Nest Teams under SDMs
    (currentSystemData.teams || []).forEach(team => {
        const awayTeamCount = team.awayTeamMembers?.length ?? 0; // Calculate away team count
        const sourceSummary = getSourceSummary(team.awayTeamMembers); // Get source summary

        const teamNode = {
            name: team.teamIdentity || team.teamName || 'Unnamed Team',
            type: 'team',
            details: `BIS: ${team.engineers?.length ?? 0} / Funded: ${team.fundedHeadcount ?? 'N/A'}`, // Show Team BIS vs Funded here
            awayTeamCount: awayTeamCount, // Store away team count
            awaySourceSummary: sourceSummary, // Store source summary
            children: (team.engineers || []).map(eng => ({
                name: `${eng.name || 'Unnamed'} (L${eng.level ?? '?'})`,
                type: 'engineer'
            }))
        };

        if (team.sdmId && sdmMap.has(team.sdmId)) {
            sdmMap.get(team.sdmId).children.push(teamNode);
        } else {
            // Handle Teams without a valid SDM
            const unassignedSdmKey = 'unassigned-sdm';
            if (!sdmMap.has(unassignedSdmKey)) {
                sdmMap.set(unassignedSdmKey, { sdmId: unassignedSdmKey, sdmName: 'Unassigned SDM', children: [], type: 'sdm' });
                // Add this unassigned SDM group under the unassigned Sr Mgr group
                const unassignedSrMgrKey = 'unassigned-sr-mgr';
                if (!srMgrMap.has(unassignedSrMgrKey)) {
                     srMgrMap.set(unassignedSrMgrKey, { seniorManagerId: unassignedSrMgrKey, seniorManagerName: 'Unassigned Senior Manager', children: [], type: 'srMgr' });
                }
                srMgrMap.get(unassignedSrMgrKey).children.push(sdmMap.get(unassignedSdmKey));
            }
            if(team && team.teamId) sdmMap.get(unassignedSdmKey).children.push(teamNode);
        }
    });

    // Define the root node
    const root = {
        name: currentSystemData.systemName || 'Organization',
        type: 'root',
        children: Array.from(srMgrMap.values()) // Use Sr Mgrs as top-level children
    };

    console.log("Finished building hierarchy data.");
    return root;
}

/** REVISED Generates the Organogram using HTML structure - Displays Away-Team Annotation */
/** REVISED Generates the Organogram using HTML structure - Fixes ReferenceError */
function generateOrganogram() {
    console.log("Generating Organogram HTML...");
    const hierarchicalData = buildHierarchyData(); // Get data with away-team info
    const container = document.getElementById('organogramContent');
    if (!hierarchicalData || !container) {
        console.error("No data or container for organogram HTML.");
        if(container) container.innerHTML = '<p style="color: red;">Could not generate organogram data.</p>';
        return;
    }
    container.innerHTML = ''; // Clear previous content
    container.style.fontFamily = 'Arial, sans-serif'; // Ensure consistent font

    // Recursive function to build nested HTML
    function buildHtmlLevel(node, level) {
        if (!node) return '';

        // Indentation and Styling
        let html = `<div class="org-level-${level}" style="margin-left: ${level * 25}px; margin-bottom: 5px; padding: 3px 5px; border-left: 2px solid #eee; position: relative;">`;
        let nodeContent = '';
        let nodeStyle = '';
        let detailsStyle = 'font-size: 0.8em; color: #555; margin-left: 5px;';

        // Define content and style based on node type
        switch(node.type) {
            case 'root':
                nodeContent = `<strong>System: ${node.name || 'N/A'}</strong>`;
                nodeStyle = 'font-size: 1.2em; color: #333;';
                break;
            case 'srMgr':
                 nodeContent = `<strong title="${node.seniorManagerId || ''}">Sr. Manager: ${node.seniorManagerName || node.name || 'N/A'}</strong>`;
                 nodeStyle = 'font-size: 1.1em; color: #0056b3;';
                break;
            case 'sdm':
                 nodeContent = `<strong title="${node.sdmId || ''}">SDM: ${node.sdmName || node.name || 'N/A'}</strong>`;
                 nodeStyle = 'color: #007bff;';
                break;
            case 'team':
                // *** CORRECTED LINE: Removed title attribute using undefined 'team' variable ***
                nodeContent = `<span style="color: #17a2b8;">Team: ${node.name || 'N/A'}</span> <span style="${detailsStyle}">(${node.details || ''})</span>`;
                // *****************************************************************************
                // Add Away-Team Annotation
                if (node.awayTeamCount > 0) {
                    const awaySourceText = node.awaySourceSummary || 'Source Unknown';
                    // Add tooltip to the annotation itself
                    const annotation = ` <span style="color: #dc3545; font-style: italic; font-size: 0.9em;" title="Away-Team Sources: ${awaySourceText}">(+${node.awayTeamCount} Away)</span>`;
                    nodeContent += annotation;
                }
                break;
            case 'engineer':
                nodeContent = `<span style="font-size: 0.9em;">${node.name || 'N/A'}</span>`;
                break;
            default:
                nodeContent = `<strong>${node.name || 'Group'}</strong>`;
                nodeStyle = 'color: #6c757d;';
        }

        // Apply style to a wrapper span for the main content
        html += `<span style="${nodeStyle}">${nodeContent}</span>`;

        // Recursively add children (excluding engineers directly under teams)
        if (node.children && node.children.length > 0 && node.type !== 'team') {
            node.children.forEach(child => {
                if (!child.type) { /* ... infer type ... */
                    if (level === 0) child.type = 'srMgr'; else if (level === 1) child.type = 'sdm'; else if (level === 2) child.type = 'team'; else if (level === 3 && node.type === 'team') child.type = 'engineer';
                }
                if (child.type !== 'engineer') { html += buildHtmlLevel(child, level + 1); }
            });
        }
        // Optional: Explicitly list engineers under team (currently commented out)
        /* else if (node.type === 'team' && node.children && node.children.length > 0) { ... } */

        html += `</div>`;
        return html;
    } // --- End buildHtmlLevel ---

    // Start building from the root (level 0)
    container.innerHTML = buildHtmlLevel(hierarchicalData, 0);
    console.log("Finished generating Organogram HTML (v2 - Fix).");
}

// Global state for engineer table sorting
let engineerSortState = { key: 'name', ascending: true };

/** Generates the HTML table for engineers */
/** REVISED Generates the HTML table for engineers - Adds Row Counter & Away-Team Indicator */
function generateEngineerTable() {
    console.log("Generating Engineer Table with Counter & Away Indicator..."); // Log start

    // --- Get Table Elements ---
    const engineerTableView = document.getElementById('engineerTableView');
    const table = document.getElementById('engineerTable');
    const tableHead = table?.querySelector('thead'); // Get the thead
    const tableBody = table?.querySelector('tbody');
    const tableFoot = table?.querySelector('tfoot'); // Get tfoot (though not directly used here)
    const heading = document.getElementById('engineerTableHeading');

    // --- Basic Data & Element Checks ---
    if (!currentSystemData || !currentSystemData.teams) { /* ... no change ... */
        console.error("Cannot generate engineer table: No system or team data loaded.");
        if(heading) heading.innerText = 'Engineer Resource List (Error: No Data)';
        if(tableBody) tableBody.innerHTML = '';
        return;
     }
    if (!table || !tableHead || !tableBody || !heading) { /* ... no change ... */
         console.error("Cannot generate engineer table: Required HTML elements not found (table, thead, tbody, or heading).");
         if(engineerTableView) engineerTableView.style.display = 'none';
         return;
     }
    tableBody.innerHTML = ''; // Clear existing rows

    // --- 1. Update Column Headers (Add '#' column) ---
    const headerRow = tableHead.querySelector('tr');
    headerRow.innerHTML = ''; // Clear existing headers

    // Define headers including the new '#' column
    const headersConfig = [
        { text: '#', title: 'Row Number' }, // NEW Counter Column
        { text: 'Engineer Name', title: 'Name of the engineer. (Away) indicates an away-team resource.', key: 'name'},
        { text: 'Level', title: 'Skill level of the engineer (L1-L5).', key: 'level'},
        { text: 'Team Name', title: 'The team the engineer is currently assigned to.', key: 'teamName'},
        { text: 'SDM Name', title: 'Software Development Manager for the assigned team.', key: 'sdmName'},
        { text: 'Senior Manager Name', title: 'Senior Manager overseeing the SDM.', key: 'srMgrName'}
    ];

    headersConfig.forEach(config => {
        const th = document.createElement('th');
        th.textContent = config.text;
        th.title = config.title;
        th.style.border = '1px solid #ccc';
        th.style.padding = '8px';
        th.style.textAlign = 'left';
        th.style.backgroundColor = '#f2f2f2';
        th.style.position = 'sticky';
        th.style.top = '0';
        th.style.zIndex = '1';
        // Add sort key and cursor pointer if defined
        if (config.key) {
            th.setAttribute('data-sort-key', config.key);
            th.style.cursor = 'pointer';
        }
        headerRow.appendChild(th);
    });
     // --- End Header Update ---

    // --- 2. Calculate System-Wide Totals (No change from previous step) ---
    let totalFundedHC = 0;
    let totalTeamBIS = 0;
    let totalAwayTeamBIS = 0;
    let totalEffectiveBIS = 0;
    let engineerListData = [];

    const sdmsMap = new Map((currentSystemData.sdms || []).map(s => [s.sdmId, s]));
    const srMgrsMap = new Map((currentSystemData.seniorManagers || []).map(s => [s.seniorManagerId, s]));

    currentSystemData.teams.forEach(team => {
        const currentFunded = team.fundedHeadcount ?? 0;
        const currentTeamBIS = team.engineers?.length ?? 0;
        const currentAwayTeamBIS = team.awayTeamMembers?.length ?? 0;

        totalFundedHC += currentFunded;
        totalTeamBIS += currentTeamBIS;
        totalAwayTeamBIS += currentAwayTeamBIS;
        totalEffectiveBIS += (currentTeamBIS + currentAwayTeamBIS);

        // Add regular engineers to list
        (team.engineers || []).forEach(eng => { /* ... no change ... */
             if (!eng || !eng.name) return;
             const sdm = team.sdmId ? sdmsMap.get(team.sdmId) : null;
             const srMgr = sdm ? srMgrsMap.get(sdm.seniorManagerId) : null;
             engineerListData.push({
                 name: eng.name, level: eng.level ?? 'N/A',
                 teamName: team.teamName || team.teamIdentity || 'N/A',
                 sdmName: sdm ? sdm.sdmName : 'N/A', srMgrName: srMgr ? srMgr.seniorManagerName : 'N/A',
                 isAwayTeam: false // Explicitly false for regular members
             });
        });
        // Add away team members to list
        (team.awayTeamMembers || []).forEach(awayEng => { /* ... no change ... */
              if (!awayEng || !awayEng.name) return;
              const sdm = team.sdmId ? sdmsMap.get(team.sdmId) : null;
              const srMgr = sdm ? srMgrsMap.get(sdm.seniorManagerId) : null;
              engineerListData.push({
                  name: awayEng.name, level: awayEng.level ?? 'N/A',
                  teamName: team.teamName || team.teamIdentity || 'N/A', // Assigned team
                  sdmName: sdm ? sdm.sdmName : 'N/A', srMgrName: srMgr ? srMgr.seniorManagerName : 'N/A',
                  isAwayTeam: true, // Flag as away team
                  sourceTeam: awayEng.sourceTeam || 'Unknown Source' // Include source
              });
        });
    });

    const totalHiringGap = totalFundedHC - totalTeamBIS;
    // --- End Total Calculations ---

    // --- 3. Update Heading Text (No change from previous step) ---
    heading.innerText = `Engineer Resource List (Funded: ${totalFundedHC} | Team BIS: ${totalTeamBIS} | Away BIS: ${totalAwayTeamBIS} | Effective BIS: ${totalEffectiveBIS} | Hiring Gap: ${totalHiringGap})`;
    heading.style.color = totalHiringGap < 0 ? 'blue' : (totalHiringGap > 0 ? 'darkorange' : 'green');
    heading.title = `Finance Approved Funding: ${totalFundedHC}\nActual Team Members (BIS): ${totalTeamBIS}\nAway-Team Members: ${totalAwayTeamBIS}\nTotal Effective Capacity (Team + Away): ${totalEffectiveBIS}\nHiring Gap (Funded - Team BIS): ${totalHiringGap}`;
    // --- End Heading Update ---

    // --- 4. Sorting (No change from previous step) ---
    engineerListData.sort((a, b) => { /* ... no changes ... */
        const key = engineerSortState.key;
        const ascending = engineerSortState.ascending;
        let valA = a[key];
        let valB = b[key];
        if (key === 'level') {
           valA = (typeof valA === 'number') ? valA : -1;
           valB = (typeof valB === 'number') ? valB : -1;
           return ascending ? valA - valB : valB - valA;
        }
        valA = (valA || '').toString().toLowerCase();
        valB = (valB || '').toString().toLowerCase();
        if (valA < valB) return ascending ? -1 : 1;
        if (valA > valB) return ascending ? 1 : -1;
        return 0;
     });
    // --- End Sorting ---

    // --- 5. Populate Table Body (Add counter and away indicator) ---
    let rowCounter = 1; // Initialize counter
    engineerListData.forEach(engData => {
        let row = tableBody.insertRow();

        // NEW: Insert Counter Cell
        const counterCell = row.insertCell();
        counterCell.textContent = rowCounter++;
        counterCell.style.textAlign = 'center';
        counterCell.style.fontSize = '0.9em';
        counterCell.style.color = '#666';

        // Engineer Name Cell (with Away indicator)
        const nameCell = row.insertCell();
        let nameDisplay = engData.name;
        if (engData.isAwayTeam) {
            nameDisplay = `(Away) ${engData.name}`; // Add prefix
            nameCell.title = `Away-Team member from: ${engData.sourceTeam}`; // Add tooltip
            nameCell.style.fontStyle = 'italic'; // Style away team members
            nameCell.style.color = '#0056b3'; // Example different color
        }
        nameCell.textContent = nameDisplay;

        // Other Cells (no change in logic)
        row.insertCell().textContent = engData.level;
        row.insertCell().textContent = engData.teamName;
        row.insertCell().textContent = engData.sdmName;
        row.insertCell().textContent = engData.srMgrName;
    });
    // --- End Populate Table ---

    // --- 6. Add Sorting Click Handlers (Update sort indicators) ---
    document.querySelectorAll('#engineerTable th[data-sort-key]').forEach(th => {
        const handler = (event) => handleSortClick(event);
        th.removeEventListener('click', th.__sortHandler); // Use stored handler reference
        th.addEventListener('click', handler);
        th.__sortHandler = handler; // Store handler reference

        // Update sort indicator
        const key = th.getAttribute('data-sort-key');
        let indicator = ' \u2195'; // Default: Up/Down arrow
        // Clear any existing indicator before adding new one
        let currentText = th.textContent.replace(/ [\u2195\u25B2\u25BC]/g, '');
        if (key === engineerSortState.key) {
            indicator = engineerSortState.ascending ? ' \u25B2' : ' \u25BC'; // Up or Down arrow
        }
        th.textContent = currentText + indicator;
    });
    // --- End Sorting Handlers ---
    console.log("Finished generating Engineer Table with counter & away indicator."); // Log end
}

// Keep handleSortClick, showOrganogramView, showEngineerTableView functions as they were.
// Make sure buildHierarchyData also still exists.

/** Handles clicking on sortable table headers */
function handleSortClick(event) {
    const key = event.target.getAttribute('data-sort-key');
    if (!key) return;

    if (engineerSortState.key === key) {
        engineerSortState.ascending = !engineerSortState.ascending; // Toggle direction
    } else {
        engineerSortState.key = key; // Change sort key
        engineerSortState.ascending = true; // Default to ascending
    }
    generateEngineerTable(); // Re-generate table with new sort order
}


/** REVISED (v5) Shows the Organogram View using switchView */
function showOrganogramView() {
    console.log("Switching to Organization Chart View (Focus Mode) + Team Table...");
    if (!currentSystemData) { alert("Please load a system first."); return; }

    switchView('organogramView'); // Switch view, hides others, shows buttons

    // --- Generate Content ---
    // Generate and show organogram
    try {
        generateOrganogram(); // Call the generation function
    } catch (error) {
        console.error("Error generating Organogram:", error);
        const contentDiv = document.getElementById('organogramContent'); // Content div inside organogramView
        if(contentDiv) contentDiv.innerHTML = `<p style="color:red;">Error generating chart. Check console.</p>`;
    }

    // Generate Team Table within this view
    try {
        generateTeamTable(currentSystemData); // Pass current system data
    } catch (error) {
        console.error("Error generating Team Table within Organogram view:", error);
        const teamTableContainer = document.getElementById('teamBreakdown'); // Team table container inside organogramView
        if(teamTableContainer) teamTableContainer.innerHTML = `<p style="color:red;">Error generating team table. Check console.</p>`;
    }
    // --- End Content Generation ---
}
window.showOrganogramView = showOrganogramView;

/** REVISED (v3) Shows the Engineer Table View using switchView */
function showEngineerTableView() {
    console.log("Switching to Engineer Table View (Focus Mode)...");
     if (!currentSystemData) { alert("Please load a system first."); return; }

    switchView('engineerTableView'); // Switch view, hides others, shows buttons

    // Generate and show engineer table
    try {
         generateEngineerTable(); // Generate with default sort
    } catch (error) {
        console.error("Error generating Engineer Table:", error);
         const engineerTableContainer = document.getElementById('engineerTableView');
         if(engineerTableContainer) engineerTableContainer.innerHTML = `<p style="color:red;">Error generating engineer table. Check console.</p>`;
    }
}

// Make it globally accessible (if not already done)
window.showEngineerTableView = showEngineerTableView;

/*** Next sections is code for the Planning Feature **/

/** Handles changes to the 'Protected' checkbox in the planning table */
function handleProtectedChange(event) {
    const checkbox = event.target;
    const initiativeId = checkbox.getAttribute('data-initiative-id');
    const isChecked = checkbox.checked;

    if (!initiativeId) {
        console.error("Could not find initiative ID on checkbox:", checkbox);
        return;
    }

    // Find the initiative in the main data array
    const initiative = currentSystemData.yearlyInitiatives.find(init => init.initiativeId === initiativeId);

    if (initiative) {
        // Update the data model
        initiative.isProtected = isChecked;
        console.log(`Updated 'isProtected' for initiative ${initiativeId} to ${isChecked}`);

        // Re-generate the table to reflect the sort change
        generatePlanningTable();
    } else {
        console.error("Could not find initiative data for ID:", initiativeId);
    }
}

/** Stores the ID of the row being dragged */
let draggedInitiativeId = null;
let draggedRowElement = null; // Store the element itself for styling

/** REVISED Handles the start of a drag operation - Check Protection */
function handleDragStart(event) {
    const initiativeId = event.target.getAttribute('data-initiative-id');
    const initiative = currentSystemData.yearlyInitiatives.find(init => init.initiativeId === initiativeId);

    // Double-check: Do not allow dragging protected items
    if (!initiative || initiative.isProtected) {
        console.log(`Preventing drag start for protected or invalid item: ${initiativeId}`);
        event.preventDefault(); // Stop the drag operation before it starts
        return;
    }

    draggedInitiativeId = initiativeId; // Store the ID of the item being dragged
    draggedRowElement = event.target; // Store the element itself for styling
    event.dataTransfer.setData('text/plain', draggedInitiativeId);
    event.dataTransfer.effectAllowed = 'move';

    // Add visual feedback (defer slightly)
    setTimeout(() => {
        if(draggedRowElement) draggedRowElement.classList.add('dragging');
    }, 0);
    console.log(`Drag Start: ${draggedInitiativeId}`);
}

/** Handles dragging over a potential drop target */
function handleDragOver(event) {
    event.preventDefault(); // Necessary to allow dropping
    event.dataTransfer.dropEffect = 'move';

    const targetRow = event.target.closest('tr');
    if (!targetRow || targetRow === draggedRowElement) return; // Don't highlight self

    // Add a class to indicate drop zone (e.g., border)
    targetRow.classList.add('drag-over');
}

/** Handles leaving a potential drop target */
function handleDragLeave(event) {
    const targetRow = event.target.closest('tr');
     if (targetRow) {
        targetRow.classList.remove('drag-over');
    }
}

/** REVISED Handles the drop operation - Adds Robust Protection Checks */
function handleDrop(event) {
    event.preventDefault();
    const targetRow = event.target.closest('tr');
    if(targetRow) targetRow.classList.remove('drag-over'); // Clean up visual indicator

    if (!targetRow || !draggedInitiativeId || targetRow.getAttribute('data-initiative-id') === draggedInitiativeId) {
        console.log("Drop cancelled - invalid target or same item.");
        // No need to reset draggedInitiativeId here, handleDragEnd will do it
        return;
    }

    const targetInitiativeId = targetRow.getAttribute('data-initiative-id');
    console.log(`Drop: ${draggedInitiativeId} onto ${targetInitiativeId}`);

    // --- Find initiatives and indices ---
    const initiatives = currentSystemData.yearlyInitiatives;
    const draggedIndex = initiatives.findIndex(init => init.initiativeId === draggedInitiativeId);
    const targetIndex = initiatives.findIndex(init => init.initiativeId === targetInitiativeId);

    if (draggedIndex === -1 || targetIndex === -1) {
        console.error("Could not find dragged or target initiative in data array during drop.");
        // No need to reset draggedInitiativeId here, handleDragEnd will do it
        return;
    }

    const draggedInitiative = initiatives[draggedIndex];
    const targetInitiative = initiatives[targetIndex];

    // --- Apply Reordering Constraints ---
    // Constraint 0: Cannot drag anything if the dragged item wasn't found or was somehow protected
     if (!draggedInitiative || draggedInitiative.isProtected) {
         console.log("Drop invalid: Dragged item is protected or invalid.");
         alert("Cannot move a protected item.");
         // handleDragEnd will reset state
         return;
     }
    // Constraint 1: Cannot drop ONTO a protected row (target is protected)
    if (targetInitiative.isProtected) {
        console.log("Drop invalid: Cannot drop onto a protected item.");
        alert("Cannot drop an item onto a protected item.");
         // handleDragEnd will reset state
        return;
    }
    // Constraint 2: Check if dropping would place the non-protected item *above* any protected items.
    // This means the new index (targetIndex) must be less than the index of the *first* non-protected item.
    const firstNonProtectedIndex = initiatives.findIndex(init => !init.isProtected);
    if (targetIndex < firstNonProtectedIndex && firstNonProtectedIndex !== -1) {
         console.log("Drop invalid: Cannot move item above the protected block.");
         alert("Cannot move items above the block of protected initiatives.");
         // handleDragEnd will reset state
         return;
    }
    // --- End Constraints ---


    // --- Perform Reorder in the Data Array ---
    const [movedItem] = initiatives.splice(draggedIndex, 1);
    const newTargetIndex = initiatives.findIndex(init => init.initiativeId === targetInitiativeId); // Recalculate index after splice
    // Determine insert position based on drop position relative to target row middle
     const rect = targetRow.getBoundingClientRect();
     const dropY = event.clientY;
     const insertBefore = dropY < rect.top + rect.height / 2;

     if (insertBefore) {
         initiatives.splice(newTargetIndex, 0, movedItem); // Insert before target
     } else {
         initiatives.splice(newTargetIndex + 1, 0, movedItem); // Insert after target
     }

    console.log("Reordered initiatives array:", initiatives.map(i => i.initiativeId));
    // --- End Reorder ---


    // --- Refresh the Table ---
    // The draggedInitiativeId is reset in handleDragEnd
    generatePlanningTable();
    // --- End Refresh ---
}

/** Cleans up after drag operation ends (dropped or cancelled) */
function handleDragEnd(event) {
    // Remove the dragging class from the original element
     if (draggedRowElement) {
        draggedRowElement.classList.remove('dragging');
    }
    // Clean up any lingering drag-over styles just in case
    document.querySelectorAll('#planningTableBody tr.drag-over').forEach(row => {
        row.classList.remove('drag-over');
    });

    console.log("Drag End");
    draggedInitiativeId = null;
    draggedRowElement = null;
}

/** Handles changes to SDE Year estimate inputs in the planning table */
function handleEstimateChange(event) {
    const input = event.target;
    const initiativeId = input.getAttribute('data-initiative-id');
    const teamId = input.getAttribute('data-team-id');
    const newValue = parseFloat(input.value);

    if (!initiativeId || !teamId) {
        console.error("Missing initiative or team ID on estimate input:", input);
        return;
    }

    // Validate the input value
    const validatedValue = (!isNaN(newValue) && newValue > 0) ? newValue : 0;

    // Find the initiative
    const initiative = currentSystemData.yearlyInitiatives.find(init => init.initiativeId === initiativeId);
    if (!initiative) {
        console.error("Could not find initiative data for ID:", initiativeId);
        return;
    }

    // Ensure assignments array exists
    if (!initiative.assignments) {
        initiative.assignments = [];
    }

    // Find existing assignment for this team
    const assignmentIndex = initiative.assignments.findIndex(a => a.teamId === teamId);

    if (validatedValue > 0) {
        if (assignmentIndex > -1) {
            // Update existing assignment
            initiative.assignments[assignmentIndex].sdeYears = validatedValue;
            console.log(`Updated estimate for ${initiativeId}, team ${teamId} to ${validatedValue}`);
        } else {
            // Add new assignment
            initiative.assignments.push({ teamId: teamId, sdeYears: validatedValue });
            console.log(`Added estimate for ${initiativeId}, team ${teamId}: ${validatedValue}`);
        }
        // Optionally reformat the input value after successful update
        input.value = validatedValue.toFixed(2);
    } else {
        // Remove assignment if value is 0 or invalid
        if (assignmentIndex > -1) {
            initiative.assignments.splice(assignmentIndex, 1);
            console.log(`Removed assignment for ${initiativeId}, team ${teamId}`);
        }
        // Clear the input field if the value was invalid or zero
        input.value = '';
    }

    // --- Refresh the entire table to recalculate totals and statuses ---
    generatePlanningTable();
    // --- End Refresh ---

    // Optional: Maintain focus if needed, though redraw might make it tricky
    // input.focus(); // Might not work reliably after full redraw
}

/** Sets the capacity scenario for planning and redraws the table */
function setPlanningScenario(scenario) {
  console.log(`Setting planning scenario to: ${scenario}`);
  // Allow 'effective', 'funded', or 'team_bis'
  if (scenario === 'effective' || scenario === 'funded' || scenario === 'team_bis') {
    planningCapacityScenario = scenario;
    // Redraw the planning table to apply the change
    generatePlanningTable();
  } else {
    console.warn("Invalid planning scenario provided:", scenario);
  }
}
// Make it globally accessible if not already
window.setPlanningScenario = setPlanningScenario;

/**
 * REVISED (v7 - Apply Constraints Sync) - Generates the Team Load Summary table.
 * - Reads applyCapacityConstraintsToggle state.
 * - Uses calculatedCapacityMetrics when toggle is ON to determine:
 * - The overall ATL/BTL limit for filtering initiatives.
 * - The per-team Scenario Capacity Limit displayed.
 * - The Remaining Capacity calculation.
 * - Updates column headers dynamically based on Net/Gross usage.
 */
function generateTeamLoadSummaryTable() {
    console.log("Generating Team Load Summary Table (v7 - Apply Constraints Sync)...");

    // --- Get Containers ---
    const summaryContentDiv = document.getElementById('teamLoadSummaryContent');
    const summaryContainer = document.getElementById('teamLoadSummarySection');
    if (!summaryContentDiv || !summaryContainer) { console.error("Missing Team Load Summary elements (contentDiv or container)."); return; }
    const summaryTable = summaryContentDiv.querySelector('#teamLoadSummaryTable');
    const summaryTableBody = summaryTable?.querySelector('#teamLoadSummaryTableBody');
    const summaryTableFoot = summaryTable?.querySelector('#teamLoadSummaryTableFoot');
    if (!summaryTable || !summaryTableBody || !summaryTableFoot) { console.error("Missing Team Load Summary table/tbody/tfoot elements."); return; }
    summaryTableBody.innerHTML = ''; summaryTableFoot.innerHTML = ''; // Clear previous content

    // --- Data Checks ---
    if (!currentSystemData || !currentSystemData.yearlyInitiatives || !currentSystemData.teams) { /* ... error handling ... */ return; }

    // --- Get Pre-Calculated Capacity Metrics & Check Availability ---
    const calculatedMetrics = currentSystemData.calculatedCapacityMetrics;
    const metricsAvailable = !!calculatedMetrics;

    // --- Calculate Gross Capacity Totals (Overall & Per Team) ---
    let totalFundedHC = 0, totalTeamBIS = 0, totalAwayTeamBIS = 0;
    const teamCapacities = {}; // Stores GROSS { fundedHC, teamBIS, awayBIS, effectiveBIS } per teamId
    const teams = currentSystemData.teams || [];
    teams.forEach(team => {
        if (!team || !team.teamId) return;
        const funded = team.fundedHeadcount ?? 0;
        const teamBIS = team.engineers?.length ?? 0;
        const awayBIS = team.awayTeamMembers?.length ?? 0;
        const effectiveBIS = teamBIS + awayBIS;
        totalFundedHC += funded; totalTeamBIS += teamBIS; totalAwayTeamBIS += awayBIS;
        teamCapacities[team.teamId] = { fundedHC: funded, teamBIS: teamBIS, awayBIS: awayBIS, effectiveBIS: effectiveBIS };
    });
    const totalEffectiveBIS = totalTeamBIS + totalAwayTeamBIS;

    // --- *** Determine Overall ATL/BTL Limit FOR SUMMARY (Conditional on Toggle) *** ---
    let summaryAtlBtlLimit;
    let isNetCapacityUsed = false;
    let scenarioName = ''; // For display
    const scenarioKey = planningCapacityScenario === 'funded' ? 'FundedHC' : (planningCapacityScenario === 'team_bis' ? 'TeamBIS' : 'EffectiveBIS');

    if (applyCapacityConstraintsToggle && metricsAvailable && calculatedMetrics.totals?.[scenarioKey]) {
        // USE NET CAPACITY
        summaryAtlBtlLimit = calculatedMetrics.totals[scenarioKey].netYrs;
        isNetCapacityUsed = true;
        scenarioName = `Net ${scenarioKey}`;
        console.log(`Summary Table using NET capacity limit: ${summaryAtlBtlLimit.toFixed(2)}`);
    } else {
        // USE GROSS CAPACITY
        if (planningCapacityScenario === 'funded') { summaryAtlBtlLimit = totalFundedHC; scenarioName = 'Gross Funded HC'; }
        else if (planningCapacityScenario === 'team_bis') { summaryAtlBtlLimit = totalTeamBIS; scenarioName = 'Gross Team BIS'; }
        else { summaryAtlBtlLimit = totalEffectiveBIS; scenarioName = 'Gross Effective BIS';} // Default to effective
        console.log(`Summary Table using GROSS capacity limit: ${summaryAtlBtlLimit.toFixed(2)}`);
    }
    // --- End Limit Determination for Summary ---

    // Update collapsible header title
    const summaryTitleHeader = summaryContainer.querySelector('h4');
    if (summaryTitleHeader) {
        const toggleSpan = summaryTitleHeader.querySelector('span.toggle-indicator');
        summaryTitleHeader.textContent = ` Team Load Summary (for ATL Initiatives - Scenario: ${scenarioName})`;
        if (toggleSpan) { summaryTitleHeader.insertBefore(toggleSpan, summaryTitleHeader.firstChild); }
    }

    // --- *** Recalculate Assigned ATL SDEs per Team using summaryAtlBtlLimit *** ---
    const sortedInitiatives = [...currentSystemData.yearlyInitiatives].sort((a, b) => { if (a.isProtected && !b.isProtected) return -1; if (!a.isProtected && b.isProtected) return 1; return 0; });
    let overallCumulativeSde = 0;
    let teamAtlSdeAssigned = {}; // Stores { teamId: totalSDE }
    teams.forEach(team => { if(team && team.teamId) teamAtlSdeAssigned[team.teamId] = 0; }); // Initialize

    sortedInitiatives.forEach(initiative => {
        let initiativeTotalSde = 0;
        (initiative.assignments || []).forEach(a => { initiativeTotalSde += a.sdeYears; });
        const potentialCumulative = overallCumulativeSde + initiativeTotalSde;

        // Check if adding this initiative *keeps* it within the determined limit (Net or Gross)
        if (potentialCumulative <= summaryAtlBtlLimit) {
             overallCumulativeSde = potentialCumulative; // Update cumulative ONLY if ATL
            // Add assignments to team totals
            (initiative.assignments || []).forEach(assignment => {
                 if (teamAtlSdeAssigned.hasOwnProperty(assignment.teamId)) {
                     teamAtlSdeAssigned[assignment.teamId] += assignment.sdeYears;
                 }
            });
        } else {
             // Stop accumulating once BTL is hit according to the summary's limit
             // Do not process further initiatives for this summary table
             return; // Exit the forEach loop early (optimization)
        }
    });
    // --- End Assigned SDE Calculation ---

    // --- Populate Summary Table Body ---
    let totalAssignedAtlSdeOverall = 0;
    let totalScenarioCapacityOverall = 0;

    teams.sort((a,b) => (a?.teamName || a?.teamIdentity || '').localeCompare(b?.teamName || b?.teamIdentity || ''))
         .forEach(team => {
        if (!team || !team.teamId) return;
        const teamId = team.teamId;
        const grossCapacity = teamCapacities[teamId]; // Get GROSS capacities
        const assignedAtlSde = teamAtlSdeAssigned[teamId] || 0; // Get potentially NET-determined ATL SDEs
        if (!grossCapacity) { console.warn(`Gross capacity data not found for teamId: ${teamId}. Skipping summary row.`); return; }

        // *** Determine the Scenario Capacity Limit to DISPLAY (Net or Gross) ***
        let displayTeamScenarioLimit = 0;
        if (isNetCapacityUsed && metricsAvailable && calculatedMetrics[teamId]?.[scenarioKey]) {
            displayTeamScenarioLimit = calculatedMetrics[teamId][scenarioKey].netYrs;
        } else { // Use Gross
            if (planningCapacityScenario === 'funded') { displayTeamScenarioLimit = grossCapacity?.fundedHC ?? 0; }
            else if (planningCapacityScenario === 'team_bis') { displayTeamScenarioLimit = grossCapacity?.teamBIS ?? 0; }
            else { displayTeamScenarioLimit = grossCapacity?.effectiveBIS ?? 0; }
        }
        // --- End Display Limit Determination ---

        const remainingCapacity = displayTeamScenarioLimit - assignedAtlSde;
        totalAssignedAtlSdeOverall += assignedAtlSde;
        totalScenarioCapacityOverall += displayTeamScenarioLimit;

        let statusText = '✅ OK'; let statusColor = 'green';
        if (remainingCapacity < 0) { statusText = '🛑 Overloaded'; statusColor = 'red'; }
        else if (remainingCapacity < 0.5 && displayTeamScenarioLimit > 0) { statusText = '⚠️ Near Limit'; statusColor = 'darkorange'; }

        const row = summaryTableBody.insertRow();
        row.insertCell().textContent = team.teamIdentity || team.teamName || teamId;            // Col 0: Team Name
        row.insertCell().textContent = (grossCapacity?.fundedHC ?? 0).toFixed(2);               // Col 1: Funded HC (Gross)
        row.insertCell().textContent = (grossCapacity?.teamBIS ?? 0).toFixed(2);                // Col 2: Team BIS (Gross)
        row.insertCell().textContent = (grossCapacity?.awayBIS ?? 0).toFixed(2);                // Col 3: Away BIS (Gross)
        row.insertCell().textContent = (grossCapacity?.effectiveBIS ?? 0).toFixed(2);           // Col 4: Effective BIS (Gross)
        row.insertCell().textContent = assignedAtlSde.toFixed(2);                               // Col 5: Assigned ATL SDEs (potentially Net-based)
        row.insertCell().textContent = displayTeamScenarioLimit.toFixed(2);                     // Col 6: Scenario Limit (potentially Net)
        const remainingCell = row.insertCell();                                                 // Col 7: Remaining Capacity
            remainingCell.textContent = remainingCapacity.toFixed(2);
            remainingCell.style.color = remainingCapacity < 0 ? 'red' : 'green';
        const statusCell = row.insertCell();                                                    // Col 8: ATL Status
            statusCell.textContent = statusText;
            statusCell.style.color = statusColor;

        // Apply Styling
        const cells = Array.from(row.cells);
        cells.forEach((cell, index) => {
            cell.style.border = '1px solid #ccc';
            cell.style.padding = '4px 6px';
            if (index === 0) { cell.style.textAlign = 'left';}
            else if (index === cells.length - 1) { cell.style.textAlign = 'center'; }
            else { cell.style.textAlign = 'center'; }
        });
    }); // End teams.forEach

    // --- Populate Footer ---
    const footerRow = summaryTableFoot.insertRow();
    footerRow.insertCell().textContent = 'Totals';                                             // Col 0
    footerRow.insertCell().textContent = totalFundedHC.toFixed(2);                             // Col 1
    footerRow.insertCell().textContent = totalTeamBIS.toFixed(2);                              // Col 2
    footerRow.insertCell().textContent = totalAwayTeamBIS.toFixed(2);                          // Col 3
    footerRow.insertCell().textContent = totalEffectiveBIS.toFixed(2);                         // Col 4
    footerRow.insertCell().textContent = totalAssignedAtlSdeOverall.toFixed(2);                // Col 5
    footerRow.insertCell().textContent = totalScenarioCapacityOverall.toFixed(2);              // Col 6
    const totalRemainingCell = footerRow.insertCell();                                         // Col 7
        totalRemainingCell.textContent = (totalScenarioCapacityOverall - totalAssignedAtlSdeOverall).toFixed(2);
        totalRemainingCell.style.color = (totalScenarioCapacityOverall - totalAssignedAtlSdeOverall) < 0 ? 'red' : 'green';
    footerRow.insertCell().textContent = '';                                                   // Col 8 (Status)

    // Apply Footer Styling
    const footerCells = Array.from(footerRow.cells);
    footerCells.forEach((cell, index) => {
        cell.style.border = '1px solid #ccc';
        cell.style.padding = '4px 6px';
        cell.style.backgroundColor = '#f8f9fa';
        if (index === 0) { cell.style.textAlign = 'left'; }
        else if (index === footerCells.length - 1) { cell.style.textAlign = 'center';}
        else { cell.style.textAlign = 'center'; }
    });

    console.log("Finished generating Team Load Summary Table (v7 - Apply Constraints Sync).");
}
window.generateTeamLoadSummaryTable = generateTeamLoadSummaryTable; // Make global if needed

/** NEW Helper: Toggles the capacity constraint application and redraws the planning table */
function toggleCapacityConstraints(isChecked) {
    console.log(`Toggling capacity constraints: ${isChecked}`);
    applyCapacityConstraintsToggle = isChecked; // Update the global state variable
    generatePlanningTable(); // Redraw the table to apply the change
}
// Make it globally accessible for the checkbox's onchange
window.toggleCapacityConstraints = toggleCapacityConstraints;

/** REVISED (v6) - Generates planning table - Persistent Green/Red Team Cells & Scoped Row Styles */
function generatePlanningTable() {
    console.log("Generating planning table (v6 - Persistent Team Colors)...");
    const planningViewDiv = document.getElementById('planningView');
    const capacitySummaryDiv = document.getElementById('planningCapacitySummary');
    const scenarioControlDiv = document.getElementById('planningScenarioControl');
    const tableContainer = document.getElementById('planningTableContainer');

    // --- Clear previous content ONLY from relevant areas ---
    if (capacitySummaryDiv) capacitySummaryDiv.innerHTML = ''; else console.error("Missing #planningCapacitySummary div");
    if (scenarioControlDiv) scenarioControlDiv.innerHTML = ''; else console.error("Missing #planningScenarioControl div");
    if (tableContainer) tableContainer.innerHTML = ''; else console.error("Missing #planningTableContainer div");

    if (!currentSystemData || !currentSystemData.yearlyInitiatives || !currentSystemData.teams) {
        if (tableContainer) tableContainer.innerHTML = '<p style="color: orange;">No planning data loaded or no initiatives/teams found. Use "Edit System" to load or define data.</p>';
        if (capacitySummaryDiv) capacitySummaryDiv.innerHTML = 'Load a system to see capacity.';
        return;
    }

    // --- 1. Calculate Detailed Capacity (Overall & Per Team) --- (No change)
    let totalFundedHC = 0, totalTeamBIS = 0, totalAwayTeamBIS = 0;
    const teamCapacities = {}; // Store { fundedHC, teamBIS, effectiveBIS } per teamId
    const teams = currentSystemData.teams || [];
    teams.forEach(team => {
        const funded = team.fundedHeadcount ?? 0;
        const teamBIS = team.engineers?.length ?? 0;
        const awayBIS = team.awayTeamMembers?.length ?? 0;
        const effectiveBIS = teamBIS + awayBIS;
        totalFundedHC += funded;
        totalTeamBIS += teamBIS;
        totalAwayTeamBIS += awayBIS;
        teamCapacities[team.teamId] = { fundedHC: funded, teamBIS: teamBIS, effectiveBIS: effectiveBIS };
    });
    const totalEffectiveBIS = totalTeamBIS + totalAwayTeamBIS;

    // --- 2. Update Capacity Summary Display --- (No change)
    if (capacitySummaryDiv) { /* ... same as v5 ... */
        capacitySummaryDiv.innerHTML = `
            <span title="Finance Approved Headcount" style="margin-right: 15px;">Funded HC: <strong style="color: #28a745;">${totalFundedHC.toFixed(2)}</strong></span> |
            <span title="Actual Team Members" style="margin-right: 15px;">Team BIS: <strong style="color: #17a2b8;">${totalTeamBIS.toFixed(2)}</strong></span> |
            <span title="Borrowed / Away-Team Members" style="margin-right: 15px;">Away BIS: <strong style="color: #ffc107;">${totalAwayTeamBIS.toFixed(2)}</strong></span> |
            <span title="Total Effective Capacity (Team + Away)">Effective BIS: <strong style="color: #007bff;">${totalEffectiveBIS.toFixed(2)}</strong></span>
        `;
    }

    const scenarioKey = planningCapacityScenario === 'funded' ? 'FundedHC' : (planningCapacityScenario === 'team_bis' ? 'TeamBIS' : 'EffectiveBIS');
    const calculatedMetrics = currentSystemData.calculatedCapacityMetrics; // Get stored metrics
    const metricsAvailable = !!calculatedMetrics; // Check if metrics exist
    if (!metricsAvailable) {
        console.warn("Calculated capacity metrics not found in currentSystemData. Capacity constraints cannot be applied.");
        // Optionally reset the toggle state if metrics are missing after load?
        // applyCapacityConstraintsToggle = false;
    }

    // --- 3. Add/Update Scenario Toggle UI --- (No change)
    if (scenarioControlDiv) { /* ... same as v5 ... */
        const baseButtonStyle = 'padding: 5px 10px; margin-left: 10px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 0.9em;';
        const activeButtonStyle = baseButtonStyle + ' background-color: #007bff; color: white; border-color: #0056b3; font-weight: bold;';
        const inactiveButtonStyle = baseButtonStyle + ' background-color: #e9ecef; color: #495057;';
        const effectiveButtonStyle = (planningCapacityScenario === 'effective') ? activeButtonStyle : inactiveButtonStyle;
        const fundedButtonStyle = (planningCapacityScenario === 'funded') ? activeButtonStyle : inactiveButtonStyle;
        const teamBisButtonStyle = (planningCapacityScenario === 'team_bis') ? activeButtonStyle : inactiveButtonStyle;
        scenarioControlDiv.innerHTML = `
            <strong style="margin-right: 10px;">Calculate ATL/BTL using:</strong>
            <button type="button" id="btnEffectiveBIS" style="${effectiveButtonStyle}" title="Use Effective BIS (${totalEffectiveBIS.toFixed(2)}) = Team + Away" onclick="setPlanningScenario('effective')">Effective BIS</button>
            <button type="button" id="btnTeamBIS" style="${teamBisButtonStyle}" title="Use Team BIS (${totalTeamBIS.toFixed(2)}) = Only Team Members" onclick="setPlanningScenario('team_bis')">Team BIS</button>
            <button type="button" id="btnFundedHC" style="${fundedButtonStyle}" title="Use Funded HC (${totalFundedHC.toFixed(2)}) = Budgeted Headcount" onclick="setPlanningScenario('funded')">Funded HC</button>
            <label style="margin-left: 20px; font-size: 0.9em; cursor: ${metricsAvailable ? 'pointer' : 'not-allowed'}; vertical-align: middle;" title="${metricsAvailable ? 'Apply calculated capacity constraints (leave, overhead, etc.) to ATL/BTL calculation (Might be less than before!). Look at Tune Capacity Constraints page to understand more!' : 'Capacity constraints not calculated or saved. Go to \'Tune Capacity Constraints\'.'}">
                <input type="checkbox" id="applyConstraintsToggle" style="vertical-align: middle;" onchange="toggleCapacityConstraints(this.checked)" ${applyCapacityConstraintsToggle ? 'checked' : ''} ${metricsAvailable ? '' : 'disabled'}>
                Apply Capacity Constraints?
            </label>
            <button type="button" id="savePlanButton"
                    style="${baseButtonStyle} background-color: #dc3545; color: white; border-color: #dc3545; margin-left: 25px;"
                    title="Save the current order and estimates for all initiatives in this plan.">
                Save Current Plan Order & Estimates
            </button>
        `;

        // --- Re-attach listener AFTER button is added to DOM ---
        // We need to find the button *after* innerHTML is set
        setTimeout(() => { // Use timeout to ensure DOM update
            const savePlanButton = document.getElementById('savePlanButton');
            if (savePlanButton) {
                 // Remove old listener if it exists from previous renders (safer)
                 savePlanButton.removeEventListener('click', handleSavePlan);
                 // Add the listener
                 savePlanButton.addEventListener('click', handleSavePlan);
                 console.log("Attached click listener to moved Save button.");
            } else {
                 console.error("Could not find moved Save button to attach listener.");
            }
       }, 0);
       // --- End of setTimeout block ---    
    
    } // End of the if (scenarioControlDiv) block
    
    // Determine Overall ATL/BTL Limit based on scenario
    // --- 5. Determine Overall ATL/BTL Limit (Conditional on Toggle) ---
    let atlBtlCapacityLimit;
    let isNetCapacityUsed = false;
    // Determine the key needed to look up metrics based on the button state

    if (applyCapacityConstraintsToggle && metricsAvailable) {
        // USE NET CAPACITY
        atlBtlCapacityLimit = calculatedMetrics.totals?.[scenarioKey]?.netYrs ?? 0; // Use Net SDE Years from stored metrics
        isNetCapacityUsed = true;
        console.log(`Using NET capacity limit for ATL/BTL: ${atlBtlCapacityLimit.toFixed(2)} (Scenario: ${scenarioKey})`);
        // Disable toggle in UI if metrics are still missing (shouldn't happen if check passed, but safe)
        const toggleInput = document.getElementById('applyConstraintsToggle');
        if(toggleInput && !calculatedMetrics.totals?.[scenarioKey]) {
             console.warn(`Metrics for scenario ${scenarioKey} missing, disabling toggle.`);
             toggleInput.checked = false;
             toggleInput.disabled = true;
             applyCapacityConstraintsToggle = false; // Reset state variable too
             isNetCapacityUsed = false; // Fallback to gross
             // Recalculate limit using Gross
             if (planningCapacityScenario === 'funded') { atlBtlCapacityLimit = totalFundedHC; }
             else if (planningCapacityScenario === 'team_bis') { atlBtlCapacityLimit = totalTeamBIS; }
             else { atlBtlCapacityLimit = totalEffectiveBIS; }
             console.log(`FALLBACK to GROSS capacity limit: ${atlBtlCapacityLimit.toFixed(2)}`);
        }

    } else {
        // USE GROSS CAPACITY (Original behavior)
        if (planningCapacityScenario === 'funded') { atlBtlCapacityLimit = totalFundedHC; }
        else if (planningCapacityScenario === 'team_bis') { atlBtlCapacityLimit = totalTeamBIS; }
        else { atlBtlCapacityLimit = totalEffectiveBIS; } // Default to effective
        console.log(`Using GROSS capacity limit for ATL/BTL: ${atlBtlCapacityLimit.toFixed(2)} (Scenario: ${scenarioKey})`);
        // Ensure toggle is unchecked if metrics were unavailable when it was initially rendered
        if(!metricsAvailable) {
            applyCapacityConstraintsToggle = false;
            const toggleInput = document.getElementById('applyConstraintsToggle');
             if(toggleInput) {
                toggleInput.checked = false;
                toggleInput.disabled = true;
             }
        }
    }
    // --- End Limit Determination ---

    generateTeamLoadSummaryTable();

    // --- 4. Prepare Table Structure ---
    const tableWrapper = document.createElement('div'); tableWrapper.id = 'planningTableWrapper';
    const table = document.createElement('table'); table.style.width = '100%'; table.style.borderCollapse = 'collapse'; table.id = 'planningTable';
    const thead = document.createElement('thead'); const headerRow = document.createElement('tr');
    const fixedHeaders = ['Protected', 'Title', 'ID', 'Description', 'Total SDE Years', 'Cumulative SDE Years', 'Capacity Status', 'ATL/BTL'];
    fixedHeaders.forEach(text => { const th = document.createElement('th'); th.textContent = text; th.style.border = '1px solid #ccc'; th.style.padding = '8px'; th.style.textAlign = 'left'; th.style.whiteSpace = 'nowrap'; headerRow.appendChild(th); });
    const teamHeaderMap = new Map();
    teams.forEach((team, index) => { 
      const th = document.createElement('th'); 
      const teamDisplayIdentity = team.teamIdentity || team.teamId || 'Unknown'; // Use ID if identity missing
      const teamFullName = team.teamName || teamDisplayIdentity; // Use full name or identity/ID for title
      th.textContent = teamDisplayIdentity; // Display the identity
      th.title = `Team: ${teamFullName}\nIdentity: ${teamDisplayIdentity}\n(Funded: ${teamCapacities[team.teamId]?.fundedHC.toFixed(2)}, Team BIS: ${teamCapacities[team.teamId]?.teamBIS.toFixed(2)}, Eff. BIS: ${teamCapacities[team.teamId]?.effectiveBIS.toFixed(2)})`; // Update title
      th.setAttribute('data-team-id', team.teamId); th.style.border = '1px solid #ccc'; 
      th.style.padding = '8px'; 
      th.style.textAlign = 'center'; 
      th.style.writingMode = 'vertical-lr'; 
      th.style.textOrientation = 'mixed'; 
      th.style.whiteSpace = 'nowrap'; 
      th.style.minWidth = '35px'; 
      th.style.maxWidth = '35px'; 
      headerRow.appendChild(th); 
      teamHeaderMap.set(fixedHeaders.length + index, team.teamId); 
    });
    thead.appendChild(headerRow); table.appendChild(thead);
    const tbody = document.createElement('tbody'); tbody.id = 'planningTableBody';


    // --- 5. Sort Initiatives & Populate Body ---
    const sortedInitiatives = [...currentSystemData.yearlyInitiatives].sort((a, b) => { /* ... same sort ... */ if (a.isProtected && !b.isProtected) return -1; if (!a.isProtected && b.isProtected) return 1; return 0; });
    let cumulativeSdeTotal = 0; // Overall cumulative
    let teamCumulativeSde = {}; // { teamId: cumulativeValue }
    teams.forEach(team => { teamCumulativeSde[team.teamId] = 0; }); // Initialize

    sortedInitiatives.forEach((initiative, rowIndex) => {
        if (!initiative || !initiative.initiativeId) { console.warn("Skipping invalid initiative data at index:", rowIndex); return; }
        const row = tbody.insertRow(); row.setAttribute('data-initiative-id', initiative.initiativeId); row.style.borderBottom = '1px solid #eee'; row.style.padding = '2px 0';
        // Drag and drop setup (No change)
        row.setAttribute('draggable', !initiative.isProtected); row.addEventListener('dragover', handleDragOver); row.addEventListener('dragleave', handleDragLeave); row.addEventListener('drop', handleDrop); row.addEventListener('dragend', handleDragEnd); if (!initiative.isProtected) { row.addEventListener('dragstart', handleDragStart); row.style.cursor = 'move'; } else { row.style.cursor = 'default'; }

        // Fixed Cells (Protected, Title, ID, Desc) - No changes
        const protectedCell = row.insertCell(); const protectedCheckbox = document.createElement('input'); protectedCheckbox.type = 'checkbox'; protectedCheckbox.checked = initiative.isProtected; protectedCheckbox.setAttribute('data-initiative-id', initiative.initiativeId); protectedCheckbox.style.cursor = 'pointer'; protectedCheckbox.onchange = handleProtectedChange; protectedCell.appendChild(protectedCheckbox); protectedCell.style.textAlign = 'center';
        const titleCell = row.insertCell(); titleCell.textContent = initiative.title || 'No Title'; titleCell.style.fontWeight = initiative.isProtected ? 'bold' : 'normal';
        const idCell = row.insertCell(); idCell.textContent = initiative.initiativeId; idCell.style.fontSize = '0.8em'; idCell.style.color = '#555';
        const descCell = row.insertCell(); const descText = initiative.description || ''; descCell.textContent = descText.length > 50 ? descText.substring(0, 47) + '...' : descText; descCell.title = descText;

        // Placeholder cells for overall totals/status
        const totalSdeCell = row.insertCell(); totalSdeCell.style.textAlign = 'right';
        const cumSdeCell = row.insertCell(); cumSdeCell.style.textAlign = 'right';
        const statusCell = row.insertCell(); statusCell.style.textAlign = 'center';
        const atlBtlCell = row.insertCell(); atlBtlCell.style.fontWeight = 'bold'; atlBtlCell.style.textAlign = 'center';

        let initiativeTotalSde = 0;
        const assignmentsMap = new Map((initiative.assignments || []).map(a => [a.teamId, a.sdeYears]));

        // *** REVISED: Per-Team Cell Coloring Logic ***
        teamHeaderMap.forEach((teamId, colIndex) => {
            const teamCell = row.insertCell();
            const currentEstimate = assignmentsMap.get(teamId) || 0;
            teamCumulativeSde[teamId] += currentEstimate; // Increment this team's cumulative

            // Estimate Input (still needed)
            const estimateInput = document.createElement('input');
            estimateInput.type = 'number'; estimateInput.min = '0'; estimateInput.step = '0.25'; estimateInput.value = currentEstimate > 0 ? currentEstimate.toFixed(2) : '';
            estimateInput.setAttribute('data-initiative-id', initiative.initiativeId); estimateInput.setAttribute('data-team-id', teamId);
            estimateInput.style.width = '60px'; estimateInput.style.textAlign = 'right';
            estimateInput.style.border = 'none';
            estimateInput.style.backgroundColor = 'transparent'; // Make input see-through
            estimateInput.addEventListener('change', handleEstimateChange);
            teamCell.appendChild(estimateInput);
            teamCell.style.textAlign = 'center';

            // Determine team's scenario limit
            // --- Determine team's limit and apply color based on toggle state ---
            let teamLimit = 0;
            let teamLimitType = '';
            let teamLimitValueStr = 'N/A';
            const currentTeamCumulative = teamCumulativeSde[teamId]; // Cumulative remains the same calculation

            if (isNetCapacityUsed && metricsAvailable && calculatedMetrics[teamId]?.[scenarioKey]) {
                // USE NET CAPACITY FOR COLORING
                teamLimit = calculatedMetrics[teamId]?.[scenarioKey]?.netYrs ?? 0;
                teamLimitType = `Net ${scenarioKey}`;
                teamLimitValueStr = teamLimit.toFixed(2);
                if (currentTeamCumulative <= teamLimit) {
                    teamCell.style.backgroundColor = '#d4edda'; // Green
                    teamCell.title = `Cumulative: ${currentTeamCumulative.toFixed(2)} / Limit (${teamLimitType}: ${teamLimitValueStr}) - OK`;
                } else {
                    teamCell.style.backgroundColor = '#f8d7da'; // Red
                    teamCell.title = `Cumulative: ${currentTeamCumulative.toFixed(2)} / Limit (${teamLimitType}: ${teamLimitValueStr}) - Overloaded`;
                }
            } else {
                // USE GROSS CAPACITY FOR COLORING (Original behavior)
                const teamGrossCapacityData = teamCapacities[teamId];
                if (planningCapacityScenario === 'funded') { teamLimit = teamGrossCapacityData?.fundedHC ?? 0; teamLimitType = `Gross Funded HC`; }
                else if (planningCapacityScenario === 'team_bis') { teamLimit = teamGrossCapacityData?.teamBIS ?? 0; teamLimitType = `Gross Team BIS`; }
                else { teamLimit = teamGrossCapacityData?.effectiveBIS ?? 0; teamLimitType = `Gross Effective BIS`; }
                teamLimitValueStr = teamLimit.toFixed(2);

                if (currentTeamCumulative <= teamLimit) {
                    teamCell.style.backgroundColor = '#d4edda'; // Green
                    teamCell.title = `Cumulative: ${currentTeamCumulative.toFixed(2)} / Limit (${teamLimitType}: ${teamLimitValueStr}) - OK`;
                } else {
                    teamCell.style.backgroundColor = '#f8d7da'; // Red
                    teamCell.title = `Cumulative: ${currentTeamCumulative.toFixed(2)} / Limit (${teamLimitType}: ${teamLimitValueStr}) - Overloaded`;
                }
            }
             // --- End Conditional Coloring ---

            initiativeTotalSde += currentEstimate;
        }); // End teamHeaderMap.forEach

        // Calculate and display OVERALL row totals and status
        totalSdeCell.textContent = initiativeTotalSde.toFixed(2);
        cumulativeSdeTotal += initiativeTotalSde;
        cumSdeCell.textContent = cumulativeSdeTotal.toFixed(2);

        // Overall Capacity Status (vs Team BIS and Funded HC) - No change
         if (cumulativeSdeTotal <= totalTeamBIS) { statusCell.textContent = '✅'; statusCell.title = `Within Team BIS (${totalTeamBIS.toFixed(2)})`; statusCell.style.backgroundColor = '#d4edda';} else if (cumulativeSdeTotal <= totalFundedHC) { statusCell.textContent = '⚠️'; statusCell.title = `Exceeds Team BIS (${totalTeamBIS.toFixed(2)}), Within Funded HC (${totalFundedHC.toFixed(2)}). Requires hiring or away-team.`; statusCell.style.backgroundColor = '#fff3cd'; } else { statusCell.textContent = '🛑'; statusCell.title = `Exceeds Funded HC (${totalFundedHC.toFixed(2)})`; statusCell.style.backgroundColor = '#f8d7da'; }

        // Overall ATL/BTL Status (vs Scenario Limit) - No change in text/color logic
        const isBTL = cumulativeSdeTotal > atlBtlCapacityLimit;
        if (!isBTL) {
            atlBtlCell.textContent = 'ATL'; atlBtlCell.style.color = 'green';
            // Add nuance tooltips (No change)
            /* ... tooltips comparing scenario limit vs other limits ... */
             if (planningCapacityScenario === 'effective' && cumulativeSdeTotal > totalFundedHC) { row.style.opacity = '0.8'; row.title = 'ATL (vs Effective BIS), but BTL vs Funded HC.'; } else if (planningCapacityScenario === 'team_bis' && cumulativeSdeTotal > totalEffectiveBIS) { row.style.opacity = '0.8'; row.title = 'ATL (vs Team BIS), but BTL vs Effective BIS.'; } else if (planningCapacityScenario === 'team_bis' && cumulativeSdeTotal > totalFundedHC) { row.style.opacity = '0.8'; row.title = 'ATL (vs Team BIS), but BTL vs Funded HC.'; } else if (planningCapacityScenario === 'funded' && cumulativeSdeTotal > totalEffectiveBIS) { row.style.opacity = '0.8'; row.title = 'ATL (vs Funded HC), but BTL vs Effective BIS.'; } else { row.style.opacity = '1'; row.title = ''; }
        } else {
            atlBtlCell.textContent = 'BTL'; atlBtlCell.style.color = 'red';
        }

        // *** REVISED: Apply Row Styling ONLY to Fixed Columns ***
        row.querySelectorAll('td').forEach((cell, idx) => {
            if (idx < fixedHeaders.length) { // Apply only to fixed columns
                if (initiative.isProtected) {
                    cell.style.backgroundColor = '#f8f9fa'; // Gray for protected fixed cells
                } else if (isBTL) {
                    cell.style.backgroundColor = '#ffeeee'; // Light red for BTL fixed cells
                } else {
                    // Set default for non-protected, non-BTL fixed cells (except status cell)
                    if (idx !== fixedHeaders.indexOf('Capacity Status')) {
                       cell.style.backgroundColor = '#fff'; // Default white
                    }
                }
            }
            // Ensure Capacity Status cell retains its independent color
            if (idx === fixedHeaders.indexOf('Capacity Status')) {
                 if (cumulativeSdeTotal <= totalTeamBIS) { cell.style.backgroundColor = '#d4edda';} else if (cumulativeSdeTotal <= totalFundedHC) { cell.style.backgroundColor = '#fff3cd'; } else { cell.style.backgroundColor = '#f8d7da'; }
                 // Also override if protected/BTL applies to fixed columns
                 if (initiative.isProtected) cell.style.backgroundColor = '#f8f9fa';
                 else if (isBTL) cell.style.backgroundColor = '#ffeeee';
            }
        });

    }); // End sortedInitiatives.forEach

    // --- Assemble the table structure ---
    table.appendChild(tbody);
    tableWrapper.appendChild(table);
    if (tableContainer) { tableContainer.appendChild(tableWrapper); }
    // --- End Assemble Table Structure ---

    adjustPlanningTableHeight();
    console.log("Finished generating planning table (v6 - Persistent Team Colors).");
} // --- End generatePlanningTable ---

/** Dynamically adjusts the max-height of the planning table scroll wrapper */
function adjustPlanningTableHeight() {
    const planningViewDiv = document.getElementById('planningView');
    const tableWrapper = document.getElementById('planningTableWrapper');
    const controlsAboveTable = document.getElementById('planningScenarioControl'); // Use scenario controls as a reference point above the table

    if (!planningViewDiv || !tableWrapper || !controlsAboveTable || planningViewDiv.style.display === 'none') {
        // Don't adjust if the view isn't visible or elements are missing
        return;
    }

    // Calculate available height
    const viewportHeight = window.innerHeight;
    const controlsRect = controlsAboveTable.getBoundingClientRect(); // Get position of controls above the table
    const controlsBottom = controlsRect.bottom; // Bottom edge of the controls
    const tableWrapperTop = tableWrapper.getBoundingClientRect().top; // Top edge of the table wrapper itself

    // Determine space available below the controls. Use whichever top position is lower (should be tableWrapperTop).
    const availableSpace = viewportHeight - tableWrapperTop;

    // Set a reasonable bottom margin/padding
    const bottomMargin = 60; // Adjust as needed (accounts for "Add Initiative" section, footer, etc.)

    let calculatedMaxHeight = availableSpace - bottomMargin;

    // Set a minimum height to prevent it becoming too small
    const minHeight = 200; // Minimum pixels for the table area
    calculatedMaxHeight = Math.max(minHeight, calculatedMaxHeight);

    console.log(`Adjusting planning table max-height to: ${calculatedMaxHeight}px`);
    tableWrapper.style.maxHeight = `${calculatedMaxHeight}px`;
}

/**
 * REVISED - Toggles the visibility of a collapsible section and updates its indicator.
 * Added logging to verify arguments.
 * Also triggers recalculation of the main planning table height.
 * @param {string} contentId - The ID of the div containing the content to toggle.
 * @param {string} indicatorId - The ID of the span element showing (+) or (-).
 */
function toggleCollapsibleSection(contentId, indicatorId) {
    // *** ADDED LOGGING HERE ***
    console.log(`toggleCollapsibleSection called with contentId: '${contentId}', indicatorId: '${indicatorId}'`);

    const contentDiv = document.getElementById(contentId);
    const indicatorSpan = document.getElementById(indicatorId);

    if (!contentDiv || !indicatorSpan) {
        console.error(`Cannot toggle section: Missing content or indicator element. ID searched for content: '${contentId}', ID searched for indicator: '${indicatorId}'`);
        return;
    }

    const isHidden = contentDiv.style.display === 'none' || contentDiv.style.display === '';
    contentDiv.style.display = isHidden ? 'block' : 'none'; // Use 'block' for general divs
    indicatorSpan.textContent = isHidden ? '(-)' : '(+)';

    // Crucially, recalculate table height AFTER changing display
    adjustPlanningTableHeight();
    console.log(`Toggled section ${contentId} to ${isHidden ? 'visible' : 'hidden'}`);
}

/** REVISED (v4) function to show the main system overview using switchView */
function showSystemOverview() {
    console.log("Navigating back to system overview...");
    if (!currentSystemData) {
        console.warn("showSystemOverview called but no system is loaded. Returning home instead.");
        returnToHome(); // Go home if no system is loaded
        return;
    }

    // Use switchView to handle showing carousel/table and managing buttons/title
    // Show BOTH the carousel and the table below it for the overview
    switchView('visualizationCarousel'); // Shows carousel, hides others, sets mode to BROWSE
    const serviceDepsTableDiv = document.getElementById('serviceDependenciesTable');
    if (serviceDepsTableDiv) serviceDepsTableDiv.style.display = 'block'; // Explicitly show table too

     // Regenerate content within the (now visible) containers
    try {
        buildGlobalPlatformDependencies();
        generateVisualization(currentSystemData);
        generateTeamVisualization(currentSystemData);
        generateServiceDependenciesTable();
        // Service/Dependency visualizations are triggered by showVisualization(0) below

         // Show the FIRST item in the carousel
         showVisualization(0);

        console.log("Displayed overview containers and regenerated content.");
    } catch (error) {
         console.error("Error regenerating system overview content:", error);
         const carouselDiv = document.getElementById('visualizationCarousel');
         if(carouselDiv) carouselDiv.innerHTML = '<p style="color:red">Error loading visualizations.</p>';
         if(serviceDepsTableDiv) serviceDepsTableDiv.innerHTML = '<p style="color:red">Error loading dependencies table.</p>';
     }
}
window.showSystemOverview = showSystemOverview;

/** REVISED (v9) Shows the Yearly Planning View using switchView */
function showPlanningView() {
    console.log("Switching to Yearly Planning View (Focus Mode)...");
    if (!currentSystemData) { alert("Please load a system first."); return; }

    switchView('planningView', Modes.PLANNING); // Switch view and set mode

     try {
         // Generate the table content
        generatePlanningTable(); // This also generates the summary table now

        // --- Populate Team Select & Attach Listeners ---
        populateTeamSelect();
        // Add listeners only once (using data attribute check)
        const addAssignButton = document.getElementById('addTeamAssignmentButton');
        if (addAssignButton && !addAssignButton.hasAttribute('data-listener-attached')) {
            addAssignButton.addEventListener('click', handleAddTeamAssignment);
            addAssignButton.setAttribute('data-listener-attached', 'true');
        }
        const addInitButton = document.getElementById('addInitiativeButton');
        if (addInitButton && !addInitButton.hasAttribute('data-listener-attached')) {
            addInitButton.addEventListener('click', handleAddInitiative);
            addInitButton.setAttribute('data-listener-attached', 'true');
        }
        // Listener for savePlanButton is now attached within generatePlanningTable

        // Adjust table height AFTER view is visible and content generated
        adjustPlanningTableHeight();

     } catch (error) {
         console.error("Error generating Planning View content:", error);
         const planningViewDiv = document.getElementById('planningView');
         if(planningViewDiv) planningViewDiv.innerHTML = `<p style="color:red;">Error generating planning view. Check console.</p>`;
     }
}
window.showPlanningView = showPlanningView; // Ensure global access

// --- Add New Initiative Logic ---

// Store temporary assignments before adding the initiative
let tempAssignments = [];

/** Populates the team selection dropdown in the 'Add Initiative' section */
function populateTeamSelect() {
    const select = document.getElementById('newInitiativeTeamSelect');
    if (!select) return;

    // Clear existing options except the placeholder
    select.length = 1; // Keep only the "-- Select Team --" option

    (currentSystemData.teams || []).forEach(team => {
        const option = document.createElement('option');
        option.value = team.teamId;
        option.textContent = team.teamIdentity || team.teamName || team.teamId;
        select.appendChild(option);
    });
}

/** Updates the display area showing temporary team assignments */
function displayTempAssignments() {
    const displayDiv = document.getElementById('newInitiativeAssignmentsDisplay');
    if (!displayDiv) return;
    displayDiv.innerHTML = ''; // Clear current display

    tempAssignments.forEach((assignment, index) => {
        const team = (currentSystemData.teams || []).find(t => t.teamId === assignment.teamId);
        const teamName = team ? (team.teamIdentity || team.teamName) : assignment.teamId;
        const assignmentDiv = document.createElement('div');
        assignmentDiv.style.marginBottom = '3px';
        assignmentDiv.textContent = `${teamName}: ${assignment.sdeYears.toFixed(2)} SDE Years `;

        const removeButton = document.createElement('button');
        removeButton.textContent = 'Remove';
        removeButton.style.marginLeft = '10px';
        removeButton.style.fontSize = '0.8em';
        removeButton.onclick = () => {
            tempAssignments.splice(index, 1); // Remove from array
            displayTempAssignments(); // Refresh display
        };
        assignmentDiv.appendChild(removeButton);
        displayDiv.appendChild(assignmentDiv);
    });
}

/** Handles clicking the 'Add Assignment' button */
function handleAddTeamAssignment() {
    const teamSelect = document.getElementById('newInitiativeTeamSelect');
    const sdeYearsInput = document.getElementById('newInitiativeSdeYears');
    const teamId = teamSelect.value;
    const sdeYears = parseFloat(sdeYearsInput.value);

    // Validation
    if (!teamId) {
        alert('Please select a team.');
        return;
    }
    if (isNaN(sdeYears) || sdeYears <= 0) {
        alert('Please enter a valid positive number for SDE Years.');
        return;
    }

    // Check if team already assigned in temp list
    const existingIndex = tempAssignments.findIndex(a => a.teamId === teamId);
    if (existingIndex > -1) {
        // Update existing assignment
        tempAssignments[existingIndex].sdeYears = sdeYears;
        console.log(`Updated assignment for team ${teamId} to ${sdeYears}`);
    } else {
        // Add new assignment
        tempAssignments.push({ teamId: teamId, sdeYears: sdeYears });
        console.log(`Added assignment for team ${teamId}: ${sdeYears}`);
    }

    // Refresh display and clear inputs
    displayTempAssignments();
    teamSelect.selectedIndex = 0; // Reset dropdown
    sdeYearsInput.value = '';
}

/** Handles clicking the 'Add Initiative to Plan' button */
function handleAddInitiative() {
    const titleInput = document.getElementById('newInitiativeTitle');
    const descriptionInput = document.getElementById('newInitiativeDescription');
    const goalIdInput = document.getElementById('newInitiativeGoalId');

    const title = titleInput.value.trim();
    const description = descriptionInput.value.trim();
    const goalId = goalIdInput.value.trim() || null; // Use null if empty

    // Validation
    if (!title) {
        alert('Initiative Title cannot be empty.');
        return;
    }
    if (tempAssignments.length === 0) {
        alert('Please add at least one team assignment.');
        return;
    }

    // Create new initiative object
    const newInitiative = {
        initiativeId: 'init-' + Date.now() + '-' + Math.floor(Math.random() * 1000), // Simple unique ID
        title: title,
        description: description,
        relatedBusinessGoalId: goalId,
        isProtected: false, // New initiatives are not protected by default
        assignments: [...tempAssignments] // Copy the temporary assignments
    };

    // Add to main data structure
    if (!currentSystemData.yearlyInitiatives) {
        currentSystemData.yearlyInitiatives = [];
    }
    currentSystemData.yearlyInitiatives.push(newInitiative);
    console.log("Added new initiative:", newInitiative);

    // Clear form and temporary data
    titleInput.value = '';
    descriptionInput.value = '';
    goalIdInput.value = '';
    tempAssignments = [];
    displayTempAssignments(); // Clear display area

    // Refresh the main planning table
    generatePlanningTable();
}

/** Handles clicking the 'Save Current Plan' button */
function handleSavePlan() {
    console.log("Attempting to save plan from planning view...");

    if (!currentSystemData || !currentSystemData.systemName) {
        alert("Cannot save plan: No system data loaded or system name is missing.");
        return;
    }

    // --- Perform Pre-Save Actions ---
    // Ensure global platform dependencies reflect assignments before saving
    buildGlobalPlatformDependencies();
    // Validate engineer assignments (important if edits happened elsewhere)
    if (!validateEngineerAssignments()) {
        // Validation function already shows an alert
        return;
    }
    // Add any other planning-specific validations here if needed later
    // --- End Pre-Save Actions ---


    // --- Save the ENTIRE currentSystemData object to Local Storage ---
    // The yearlyInitiatives array within currentSystemData should reflect the current order and estimates.
    try {
        const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
        const systemNameKey = currentSystemData.systemName; // Use the name stored in the data

        // Save the current data under its name
        systems[systemNameKey] = currentSystemData;
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

        alert(`Plan for system "${systemNameKey}" saved successfully.`);
        console.log('System changes saved to local storage via Save Plan button.');

    } catch (error) {
        console.error("Error saving system to local storage:", error);
        alert("An error occurred while trying to save the plan. Please check the console for details.");
    }
    // ---------------------------------------------------------------
}


// Attach functions to the global window object
window.showSavedSystems = showSavedSystems;
window.createNewSystem = createNewSystem;
window.resetToDefaults = resetToDefaults;
window.returnToHome = returnToHome;
window.showPlanningView = showPlanningView;

// --- Window Resize Listener for Planning Table Height ---
let resizeTimeout;
window.addEventListener('resize', () => {
    // Debounce resize events to avoid excessive calculations
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        // Only adjust if the planning view is currently visible
        const planningViewDiv = document.getElementById('planningView');
        if (planningViewDiv && planningViewDiv.style.display !== 'none') {
            adjustPlanningTableHeight();
        }
    }, 150); // Adjust timeout (milliseconds) as needed
});
// -----------------------------------------------------

</script>

</body>
</html>
