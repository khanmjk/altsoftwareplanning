<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Architecture Visualization Tool</title>
    <!-- Include D3.js for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Basic styling */
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { text-align: center; }
        .menu, .edit-menu { text-align: center; margin-bottom: 20px; }
        .menu button, .edit-menu button { margin: 5px; padding: 10px 20px; font-size: 16px; }
        #visualization, #teamVisualization { max-width: 800px; margin: 20px auto; }
        svg { width: 100%; height: 600px; border: 1px solid #ccc; }
        #teamTable { width: 100%; border-collapse: collapse; margin-top: 20px; }
        #teamTable th, #teamTable td { border: 1px solid #ccc; padding: 8px; text-align: left; vertical-align: top; }
        .node text { pointer-events: none; font-size: 12px; }
        .tooltip { position: absolute; text-align: left; width: auto; max-width: 300px; padding: 5px; font: 12px sans-serif; background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; pointer-events: none; }
        .legend { font-size: 12px; display: flex; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; margin-right: 15px; margin-bottom: 5px; }
        .team-edit {margin-bottom: 15px;padding: 10px;border: 1px solid #ccc;}
    
          #returnHomeButton {
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 10px 15px;
          font-size: 14px;
          z-index: 1000;
          }
          .team-edit {
              margin-bottom: 15px;
              border: 1px solid #ccc;
          }
          
          .team-edit h4 {
              margin: 0;
              padding: 10px;
              background-color: #f2f2f2;
          }
          
          .team-details {
              padding: 10px;
              display: none;
          }
          .service-edit {
              margin-bottom: 15px;
              border: 1px solid #ccc;
          }
          
          .service-edit h4 {
              margin: 0;
              padding: 10px;
              background-color: #e6f7ff;
              cursor: pointer;
          }
          
          .service-details {
              padding: 10px;
              display: none;
          }
          
          .api-edit {
              margin-left: 20px;
              margin-bottom: 10px;
              border: 1px solid #ddd;
              padding: 10px;
          }    
          /* Adjust SVG size for service visualization */
          #serviceSvg {
              width: 100%;
              height: 600px;
              border: 1px solid #ccc;
          }
          
          /* Adjust tooltip styling if necessary */
          .tooltip {
              position: absolute;
              text-align: left;
              width: auto;
              max-width: 300px;
              padding: 5px;
              font: 12px sans-serif;
              background: rgba(255, 255, 255, 0.9);
              border: 1px solid #ccc;
              pointer-events: none;
              z-index: 1000;
          }
          /* Dependency visualization styles */
          .node circle {
              fill: #fff;
              stroke: steelblue;
              stroke-width: 2px;
          }
          
          .node text {
              font: 12px sans-serif;
          }
          
          .link {
              fill: none;
              stroke: #ccc;
              stroke-width: 2px;
          }
          
          .tooltip {
              position: absolute;
              text-align: left;
              width: auto;
              max-width: 300px;
              padding: 10px;
              font: 12px sans-serif;
              background: rgba(255, 255, 255, 0.9);
              border: 1px solid #ccc;
              border-radius: 5px;
              pointer-events: none;
              z-index: 1000;
          }
          #serviceDependenciesTable {
              margin-top: 20px;
          }
          
          #serviceDependenciesTable table {
              width: 100%;
              border-collapse: collapse;
          }
          
          #serviceDependenciesTable th, #serviceDependenciesTable td {
              border: 1px solid #ccc;
              padding: 8px;
              text-align: left;
          }
          
          #serviceDependenciesTable th {
              background-color: #f2f2f2;
          }
          
          #serviceDependenciesTable tr:nth-child(even) {
              background-color: #f9f9f9;
          }
          
          #serviceDependenciesTable tr:hover {
              background-color: #e9e9e9;
          }          
          .platform-deps-container {
              display: flex;
              align-items: center;
          }
          .current-deps, .other-deps {
              flex: 1;
              margin: 0 10px;
          }
          .platform-deps-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          .platform-deps-buttons button {
              margin: 5px 0;
          }
          .platform-deps-container select {
              width: 100%;
              min-height: 100px;
          }          
          .service-deps-container {
              display: flex;
              align-items: center;
              margin-bottom: 10px;
          }
          
          .current-service-deps, .other-services {
              flex: 1;
              margin: 0 10px;
          }
          
          .service-deps-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          
          .service-deps-buttons button {
              margin: 5px 0;
          }
          
          .service-deps-container select {
              width: 100%;
              min-height: 100px;
          }
          /* Styles for Dependent APIs */
          .dependent-apis-container {
              display: flex;
              align-items: center;
              margin-bottom: 10px;
          }
          
          .current-dependent-apis, .other-apis {
              flex: 1;
              margin: 0 10px;
          }
          
          .dependent-apis-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          
          .dependent-apis-buttons button {
              margin: 5px 0;
          }
          
          .dependent-apis-container select {
              width: 100%;
              min-height: 100px;
          }          
          /* Add styles for new views */
          #organogramView, #engineerTableView {
              max-width: 90%; /* Allow wider view */
              margin: 20px auto;
          }
          
          #organogramSvg {
              width: 100%;
              height: 700px; /* Adjust as needed */
              border: 1px solid #ccc;
              background-color: #f9f9f9; /* Light background */
          }
          
          /* Styles for Organogram Nodes/Links (Example) */
          .organogram-link {
            fill: none;
            stroke: #555;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
          }
          
          .organogram-node circle { /* Example using circles */
            stroke: steelblue;
            stroke-width: 1.5px;
          }
           .organogram-node rect { /* Example using rectangles */
            stroke: steelblue;
            stroke-width: 1.5px;
            fill: #fff;
          }
          
          .organogram-node text {
            font: 10px sans-serif;
            /* Adjust text anchor and position based on layout */
          }
          
           /* Styles for Engineer Table */
           #engineerTable th, #engineerTable td {
               border: 1px solid #ccc;
               padding: 8px;
               text-align: left;
           }
           #engineerTable th {
               background-color: #f2f2f2;
           }
            #engineerTable th[data-sort-key]:hover { /* Indicate sortable */
               background-color: #e0e0e0;
               text-decoration: underline;
            }
          #engineerTable tr:nth-child(even) {
              background-color: #f9f9f9;
          }          
          /* Also add some basic CSS for visual feedback (place within the <style> tag) */
          /* Add styles for drag-and-drop feedback */
          #planningTableBody tr.dragging {
              opacity: 0.5;
              border: 2px dashed #ccc;
          }
          #planningTableBody tr.drag-over {
              border-top: 2px solid blue; /* Highlight where it will drop */
          }          
      /* --- Styles for Planning Table Enhancements (Revised for Alignment Fix) --- */
          #planningTableWrapper {
              overflow: auto; /* Enable BOTH horizontal and vertical scrolling */
              /* max-height: 550px; */ /* Set max height before vertical scroll appears (Adjust as needed) */
              max-width: 100%;   /* Ensure it doesn't overflow its parent */
              margin-bottom: 15px; /* Add some space below */
              border: 1px solid #ccc; /* Optional: add a border to see the scroll container */
          }
      
          /* Make headers stick within the scrollable container */
          #planningTable thead th {
            position: sticky;
            top: 0;
            z-index: 2;
            background-color: #f2f2f2;
            border: 1px solid #ccc;
            text-align: left;
            white-space: nowrap;
            /* --- ADDED specific, reduced padding and font-size --- */
            padding: 3px 5px;  /* Reduced vertical and horizontal padding */
            font-size: 0.85em; /* Reduced font size */
            /* ----------------------------------------------------- */
          }
           /* Ensure the background of the dynamic team headers is also solid */
       #planningTable th[data-team-id] {
            background-color: #e6f7ff;
            writing-mode: vertical-lr;
            text-orientation: mixed;
            text-align: center;
            /* --- Apply reduced padding/font AND adjust min/max width --- */
            padding: 5px 2px;  /* Adjusted padding for vertical (more top/bottom, less left/right) */
            font-size: 0.8em;  /* Further reduced font for vertical names */
            min-width: 25px;   /* Reduced width */
            max-width: 25px;   /* Reduced width */
        
          }
      
      
          /* Center-align specific numerical columns in the planning table */
          #planningTable th:nth-child(5), /* Total SDE Years Header */
          #planningTable td:nth-child(5), /* Total SDE Years Cell */
          #planningTable th:nth-child(6), /* Cumulative SDE Years Header */
          #planningTable td:nth-child(6) { /* Cumulative SDE Years Cell */
              text-align: center !important; /* Use important if needed */
          }

/* --- REVISED: Reduce font size and padding for BOTH planning table rows AND summary table rows --- */
        #planningTable tbody td,
        #teamLoadSummaryTable tbody td { /* Added summary table selector */
            padding: 2px 3px;   /* Reduced vertical padding */
            font-size: 0.80em; /* Smaller row font */
            border: 1px solid #eee;
            vertical-align: middle; /* Align content vertically */
        }
        /* Also target inputs in the main planning table */
        #planningTable tbody td input[type="number"] {
             vertical-align: middle;
            font-size: 0.85em; /* Smaller row font */             
        }
        /* Style summary table footer cells similarly */
        #teamLoadSummaryTable tfoot td {
            padding: 2px 3px;
            font-size: 0.80em; /* Apply same font size */
            border: 1px solid #ccc; /* Keep slightly stronger border for footer */
            background-color: #f8f9fa; /* Keep footer background */
            text-align: center; /* Keep footer text centered */
            vertical-align: middle;
        }
        /* Adjust the first footer cell (label) alignment */
         #teamLoadSummaryTable tfoot td:first-child {
            text-align: left;
         }
 
        /* --- REVISED: Control column widths for Team Load Summary Table (Attempt 2) --- */
        #teamLoadSummaryTable thead th {
             /* Base style if needed */
        }
        #teamLoadSummaryTable thead th:nth-child(1) { text-align: left; width: 10%; max-width: 30px} /* Team Name */
        #teamLoadSummaryTable thead th:nth-child(2), /* Funded HC */
        #teamLoadSummaryTable thead th:nth-child(3), /* Team BIS */
        #teamLoadSummaryTable thead th:nth-child(4), /* Away BIS */
        #teamLoadSummaryTable thead th:nth-child(5) { width: 8%; } /* Effective BIS */
        #teamLoadSummaryTable thead th:nth-child(6) { width: 12%; max-width: 40px; } /* Assigned ATL SDEs */
        #teamLoadSummaryTable thead th:nth-child(7) { width: 12%; max-width: 40px; } /* Scenario Capacity Limit */
        #teamLoadSummaryTable thead th:nth-child(8) { width: 12%; max-width: 40px; } /* Remaining Capacity (ATL) */
        #teamLoadSummaryTable thead th:nth-child(9) { width: 10%; } /* ATL Status */
        /* -------------------------------------------------------------------------- */

          /* REVISED Style for clickable headers */
          #planningView h3[onclick],
          #planningView h4[onclick] { /* Keep targeting both in case h4 is used later */
              cursor: pointer;
              /* Removed position: relative and padding-left */
          }
          /* REVISED Style for toggle indicator */
          #planningView h3[onclick] span.toggle-indicator,
          #planningView h4[onclick] span.toggle-indicator {
               /* Removed absolute positioning properties */
               display: inline-block; /* Keep this */
               font-weight: bold;    /* Keep this */
               margin-right: 5px;    /* Add some space after the indicator */
               /* Optional: Adjust color if desired */
               /* color: #007bff; */
          }
            
          /* Add any additional styles as needed */          
    </style>
</head>
<body>

<!-- Updated Heading with ID -->
<h1 id="pageTitle">Architecture Visualization Tool</h1>
<p id="systemDescription">Load a previously saved system or create a new system</p>

<!-- Menu for loading systems 
<div class="menu">
    <button onclick="showSavedSystems()">Load Saved System</button>
</div>
-->

<!-- Edit System Button -->
<div class="edit-menu" style="display: none;">
    <button id="editSystemButton" onclick="enterEditMode()">Edit System</button>
    <button id="viewOrgChartButton" onclick="showOrganogramView()">View Org Chart</button>
    <button id="viewEngineerListButton" onclick="showEngineerTableView()">View Engineer List</button>
    <button id="manageYearPlanButton" onclick="showPlanningView()">Manage Year Plan</button>
    <button id="deleteSystemButton" onclick="deleteSystem()">Delete System</button>
</div>

<!-- Visualization Section -->
<div id="visualization" style="display:none;">
    <h2>System Visualization</h2>
    <svg id="systemSvg" style="width: 800px; height: 800px;"></svg>
    <!-- Legend -->
    <div id="legend"></div>
</div>

<!-- Team Relationships Visualization -->
<div id="teamVisualization" style="display:none;">
    <h2>Team Relationships Visualization</h2>
    <svg id="teamSvg" style="width: 800px; height: 800px;"></svg>
    <!-- Legend -->
    <div id="teamLegend"></div>
</div>

<!-- Service Relationships Visualization -->
<div id="serviceRelationshipsVisualization" style="display:none;">
    <h2>Service Relationships Visualization</h2>
    <select id="serviceSelection" onchange="updateServiceVisualization()">
        <!-- Options will be populated dynamically -->
    </select>
    <svg id="serviceSvg"></svg>
    <!-- Legend -->
    <div id="serviceLegend"></div>
</div>

<!-- Upstream/Downstream Visualization -->
<div id="dependencyVisualization" style="display:none;">
    <h2>Service Dependency Visualization</h2>
    <select id="dependencyServiceSelection" onchange="updateDependencyVisualization()">
        <!-- Options will be populated dynamically -->
    </select>
    <svg id="dependencySvg" style="width: 800px; height: 600px;"></svg>
    <!-- Legend -->
    <div id="dependencyLegend"></div>
</div>

<!-- Team Breakdown Table -->
<div id="teamBreakdown" style="display:none;">
    <h2>Team Breakdown</h2>
    <p id="levelKey" style="font-size: 0.9em; color: #555; margin-bottom: 10px;"></p> <table id="teamTable">
        <thead> <tr>
                <th>Senior Manager</th> <th>SDM</th>
                <th>Team Identity</th>
                <th>Team Name</th>
                <th>PMT</th>
                <th>Funded HC</th>
                <th>BIS</th>
                <th>Gap to Goal</th> <th>Engineers (Level)</th>
                <th>Services Owned</th>
            </tr>
        </thead>
        <tbody>
            </tbody>
        <tfoot> <tr>
                <th colspan="5" style="text-align: right; font-weight: bold;">Totals:</th> <td id="totalFundedHC" style="font-weight: bold;"></td>
                <td id="totalBIS" style="font-weight: bold;"></td>
                <td id="totalGap" style="font-weight: bold;"></td>
                <td colspan="2"></td> </tr>
             <tr> <td colspan="10" id="gapNote" style="text-align: right; font-style: italic; font-size: 0.9em; padding-top: 5px;"></td>
            </tr>
        </tfoot>
    </table>
</div>

<div id="serviceDependenciesTable" style="display:none;">
    <h2>Service Dependencies Table</h2>
    <table>
        <thead>
        <tr>
            <th>Service Name</th>
            <th>Description</th>
            <th>Owning Team</th>
            <th>Upstream Dependencies (Services Depended On)</th>
            <th>Platform Dependencies</th>
            <th>Downstream Dependencies (Services That Depend On This Service)</th>
        </tr>
        </thead>
        <tbody>
            <!-- Rows will be populated dynamically -->
        </tbody>
    </table>
</div>


<!-- System Edit Form -->
<div id="systemEditForm" style="display:none;">
    <h2>Edit System</h2>
    <form id="editSystemForm">
        <label>System Name:</label><br>
        <input type="text" id="systemNameInput"><br><br>
        <label>System Description:</label><br>
        <textarea id="systemDescriptionInput" rows="3" cols="50"></textarea><br><br>
        <button type="button" onclick="saveSystemDetails()">Save System Details</button>
    </form>

    <!-- Services Management Section -->
    <h3>Services</h3>
    <div id="editServicesManagement">
        <!-- Services will be listed here -->
    </div>
    <button type="button" onclick="addNewService()">Add New Service</button><br><br>
    
    <!-- Teams Management Section -->
    <h3>Teams</h3>
    <div id="teamsManagement">
        <!-- Teams will be listed here -->
    </div>
    <button id="addNewTeamButton" type="button" onclick="addNewTeam()">Add New Team</button><br><br>

    <!-- Buttons to Save or Cancel -->
    <button type="button" onclick="saveAllChanges()">Save All Changes</button>
    <button type="button" onclick="exitEditMode()">Cancel</button>
</div>

<!-- 09/28 Added code for Create New system workflow -->
<!-- Menu for loading systems and creating new systems -->
<div class="menu">
    <button onclick="showSavedSystems()">Load Saved System</button>
    <button onclick="createNewSystem()">Create New Software System</button>
    <!-- Add the Reset to Defaults button -->
    <button onclick="resetToDefaults()">Reset to Defaults</button>    
</div>

<!-- Return to Home Button -->
<button id="backToSystemViewButton" onclick="showSystemOverview()" style="display: none; margin-right: 10px;">Back to System Overview</button>
<button id="returnHomeButton" onclick="returnToHome()" style="display: none;">Return to Home</button>

<!-- added some new views 8th april 25 -->
<div id="organogramView" style="display:none; margin-top: 20px;">
    <h2>Organization Chart</h2>
    <div id="organogramToolbar" style="margin-bottom: 10px;">
        </div>
    <div id="organogramContent" style="border: 1px solid #ccc; padding: 15px;">
        </div>
    </div>

<div id="engineerTableView" style="display:none; margin-top: 20px;">
    <h2 id="engineerTableHeading">Engineer Resource List</h2> <p style="font-size: 0.9em; color: #555;">Click column headers to sort.</p>
    <table id="engineerTable" style="width: 100%; border-collapse: collapse; margin-top: 10px;">
        <thead>
            <tr>
                <th data-sort-key="name" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Engineer Name &#x2195;</th>
                <th data-sort-key="level" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Level &#x2195;</th>
                <th data-sort-key="teamName" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Team Name &#x2195;</th>
                <th data-sort-key="sdmName" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">SDM Name &#x2195;</th>
                <th data-sort-key="srMgrName" style="cursor: pointer; border: 1px solid #ccc; padding: 8px; text-align: left;">Senior Manager Name &#x2195;</th>
            </tr>
        </thead>
        <tbody>
            </tbody>
    </table>
</div>

<div id="planningView" style="display:none; margin-top: 20px;">
    <h2 id="planningViewTitle">Yearly Planning View</h2>

    <div id="planningCapacitySummary" style="margin-bottom: 15px; font-weight: bold;">
        </div>

    <div id="planningScenarioControl" style="margin-bottom: 15px; padding: 8px; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px;">
        </div>

    <div id="teamLoadSummarySection" style="margin-bottom: 20px; border: 1px solid #ccc; border-radius: 4px;">
        <h4 onclick="toggleCollapsibleSection('teamLoadSummaryContent', 'teamLoadSummaryToggle')"
            style="cursor: pointer; margin: 0; padding: 10px; background-color: #e9ecef; border-bottom: 1px solid #ccc;"
            title="Click to expand/collapse team load summary">
            <span id="teamLoadSummaryToggle" class="toggle-indicator">(+) </span> Team Load Summary (for ATL Initiatives)
        </h4>
        <div id="teamLoadSummaryContent" style="display: none; padding: 10px;">
             <p style="font-size: 0.9em; color: #555;">Shows team load based *only* on initiatives currently Above The Line (ATL) according to the selected scenario below.</p>
             <table id="teamLoadSummaryTable" style="margin: 0 auto; border-collapse: collapse; font-size: 0.9em;">
                 <thead>
                     <tr style="background-color: #f2f2f2;">
                         <th style="border: 1px solid #ccc; padding: 5px;">Team Name</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Finance Approved Budget">Funded HC</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Actual Team Members">Team BIS</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Borrowed/Away Members">Away BIS</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Team BIS + Away BIS">Effective BIS</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="SDEs assigned to this team from ATL initiatives only">Assigned ATL SDEs</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Team's capacity based on selected scenario button below">Scenario Capacity Limit</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Scenario Capacity Limit - Assigned ATL SDEs">Remaining Capacity (ATL)</th>
                         <th style="border: 1px solid #ccc; padding: 5px;" title="Load status for ATL work based on Scenario Capacity Limit">ATL Status</th>
                     </tr>
                 </thead>
                 <tbody id="teamLoadSummaryTableBody">
                     </tbody>
                 <tfoot id="teamLoadSummaryTableFoot" style="font-weight: bold;">
                      </tfoot>
             </table>
        </div>
    </div>

    <div id="planningTableContainer">
        </div>
    <div id="addInitiativeSection" style="margin-top: 20px; padding: 15px; border: 1px solid #ccc;">
         <h3 onclick="toggleCollapsibleSection('addInitiativeContent', 'addInitiativeToggle')" title="Click to expand/collapse">
             <span id="addInitiativeToggle" class="toggle-indicator">(+) </span> Add New Initiative
        </h3>
        
        <div id="addInitiativeContent" style="display: none;"> 
          <div style="margin-bottom: 10px;">
              <label for="newInitiativeTitle" style="display: block;">Title:</label>
              <input type="text" id="newInitiativeTitle" placeholder="Initiative Title" style="width: 90%;">
          </div>
          <div style="margin-bottom: 10px;">
              <label for="newInitiativeDescription" style="display: block;">Description:</label>
              <textarea id="newInitiativeDescription" placeholder="Description" rows="2" style="width: 90%;"></textarea>
          </div>
          <div style="margin-bottom: 10px;">
              <label for="newInitiativeGoalId" style="display: block;">Related Business Goal ID (Optional):</label>
              <input type="text" id="newInitiativeGoalId" placeholder="Optional: Business Goal ID" style="width: 90%;">
          </div>
  
          <hr>
          <h4>Team Assignments:</h4>
          <div id="newInitiativeAssignmentsDisplay" style="margin-bottom: 10px; min-height: 30px; background-color: #f8f9fa; padding: 5px; border: 1px solid #eee;">
          </div>
          <div style="display: flex; align-items: center; margin-bottom: 10px;">
               <label for="newInitiativeTeamSelect" style="margin-right: 5px;">Team:</label>
               <select id="newInitiativeTeamSelect" style="margin-right: 10px;">
                   <option value="">-- Select Team --</option>
               </select>
               <label for="newInitiativeSdeYears" style="margin-right: 5px;">SDE Years:</label>
               <input type="number" id="newInitiativeSdeYears" step="0.25" min="0" placeholder="e.g., 1.5" style="width: 80px; margin-right: 10px;">
               <button type="button" id="addTeamAssignmentButton">Add Assignment</button>
          </div>
  
          <hr>
          <button type="button" id="addInitiativeButton" style="padding: 10px 15px; font-size: 16px; background-color: #28a745; color: white; border: none; cursor: pointer;">Add Initiative to Plan</button>
        </div>
    </div>
</div>

<script>
/* JavaScript Code */
/* global variables */
/** Define a unique key for local storage **/
const LOCAL_STORAGE_KEY = 'architectureVisualization_systems';
let currentSystemData = null;
let newServiceData = {};
let uniqueEngineers = [];
const Modes = {
    NAVIGATION: 'navigation',
    BROWSING: 'browsing',
    EDITING: 'editing',
    CREATING: 'creating',
    PLANNING: 'planning' 
};
let currentMode = Modes.NAVIGATION;
let planningCapacityScenario = 'effective'; // Default to 'effective'

/** Sample Data for StreamView **/

/** Define Senior Managers for StreamView **/
const sampleSeniorManagersDataStreamView = [
    { seniorManagerId: 'srMgr1', seniorManagerName: 'Director Dave' },
    { seniorManagerId: 'srMgr2', seniorManagerName: 'VP Victoria' }
];

/** Updated SDMs Data for StreamView (with seniorManagerId) **/
const sampleSDMsDataStreamView = [
    { sdmId: 'sdm1', sdmName: 'Alice Johnson', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm2', sdmName: 'Emily Clark', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm3', sdmName: 'Carol Davis', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm4', sdmName: 'Grace Lee', seniorManagerId: 'srMgr2' },
    { sdmId: 'sdm5', sdmName: 'Ian Turner', seniorManagerId: 'srMgr2' },
    { sdmId: 'sdm6', sdmName: 'Karen Adams', seniorManagerId: 'srMgr2' },
    { sdmId: 'sdm7', sdmName: 'Natalie Green', seniorManagerId: 'srMgr1' },
    { sdmId: 'sdm8', sdmName: 'Zoe King', seniorManagerId: 'srMgr2' }
];

/** Updated Teams Data for StreamView (with fundedHeadcount, buildersInSeats, engineers array) **/
const sampleTeamsDataStreamView = [
    {
        teamId: 'team1',
        teamName: 'User Experience Team',
        teamIdentity: 'Avengers',
        fundedHeadcount: 7,
        buildersInSeats: 5,
        engineers: [
            { name: 'Alice Johnson', level: 4 },
            { name: 'Mark Evans', level: 3 },
            { name: 'Sophia Lee', level: 3 },
            { name: 'John Doe', level: 2 },
            { name: 'Emma Davis', level: 1 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm1',
        pmtId: 'pmt1'
    },
    {
        teamId: 'team2',
        teamName: 'Streaming Team',
        teamIdentity: 'Spartans',
        fundedHeadcount: 5,
        buildersInSeats: 4,
        engineers: [
            { name: 'Emily Clark', level: 5 },
            { name: 'Daniel Thompson', level: 3 },
            { name: 'Olivia Brown', level: 2 },
            { name: 'Liam Wilson', level: 2 }
        ],
        awayTeamMembers: [
            { name: 'Borrowed Betty', level: 3, sourceTeam: 'External Partner X' }
        ], // Example away team member
        sdmId: 'sdm2',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team3',
        teamName: 'Content Team',
        teamIdentity: 'Crusaders',
        fundedHeadcount: 4,
        buildersInSeats: 3,
        engineers: [
            { name: 'Carol Davis', level: 4 },
            { name: 'Kevin Moore', level: 2 },
            { name: 'Isabella Martinez', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm3',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team4',
        teamName: 'Recommendation Team',
        teamIdentity: 'Olympus',
        fundedHeadcount: 6,
        buildersInSeats: 4,
        engineers: [
            { name: 'Grace Lee', level: 4 },
            { name: 'Ethan Harris', level: 3 },
            { name: 'Mia Turner', level: 2 },
            { name: 'Noah Walker', level: 1 }
        ],
        awayTeamMembers: [
            { name: 'Loaned Larry', level: 4, sourceTeam: 'Core Platform BU' },
            { name: 'Visiting Vinny', level: 2, sourceTeam: 'Data Science Org' }
        ], // Example away team members
        sdmId: 'sdm4',
        pmtId: 'pmt3'
    },
    {
        teamId: 'team5',
        teamName: 'Finance Team',
        teamIdentity: 'Falcons',
        fundedHeadcount: 4,
        buildersInSeats: 3,
        engineers: [
            { name: 'Ian Turner', level: 5 },
            { name: 'Charlotte Adams', level: 3 },
            { name: 'Benjamin Scott', level: 3 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm5',
        pmtId: 'pmt3'
    },
    {
        teamId: 'team6',
        teamName: 'Communication Team',
        teamIdentity: 'Ninjas',
        fundedHeadcount: 3,
        buildersInSeats: 2,
        engineers: [
            { name: 'Karen Adams', level: 3 },
            { name: 'Lucas Wright', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm6',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team7',
        teamName: 'Analytics Team',
        teamIdentity: 'Dragons',
        fundedHeadcount: 5,
        buildersInSeats: 3,
        engineers: [
            { name: 'Natalie Green', level: 4 },
            { name: 'Andrew Hall', level: 3 },
            { name: 'Ella Young', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm7',
        pmtId: 'pmt4'
    },
    {
        teamId: 'team8',
        teamName: 'Search Team',
        teamIdentity: 'Search',
        fundedHeadcount: 3,
        buildersInSeats: 2,
        engineers: [
            { name: 'Zoe King', level: 3 },
            { name: 'Michael Baker', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm8',
        pmtId: 'pmt1'
    }
];

const samplePMTsDataStreamView = [
    { pmtId: 'pmt1', pmtName: 'Bob Smith' },
    { pmtId: 'pmt2', pmtName: 'Frank Thompson' },
    { pmtId: 'pmt3', pmtName: 'Jane Parker' },
    { pmtId: 'pmt4', pmtName: 'Owen Clark' }
];

//Service Name
//Upstreams: List of services the current service depends on.
//Downstreams: List of services that depend on the current service.
//Platform Dependencies: List of platforms the current service depends on.
//Upstreams: For a given service, upstreams are the services listed in its serviceDependencies.
//Downstreams: For a given service, downstreams are the services that include its name in their serviceDependencies.	

const sampleServicesDataStreamView = [
    {
      serviceName: 'User Management Service',
      serviceDescription: 'Handles user registration, authentication, profiles, and account settings.',
      owningTeamId: 'team1',
      apis: [
          {
              apiName: 'Register API',
              apiDescription: 'Allows new users to sign up.',
              dependentApis: []
          },
          {
              apiName: 'Login API',
              apiDescription: 'Authenticates users and starts a session.',
              dependentApis: []
          },
          {
              apiName: 'Profile API',
              apiDescription: 'Manages user profiles and account settings.',
              dependentApis: []
          },
          {
              apiName: 'Logout API',
              apiDescription: 'Ends the user session.',
              dependentApis: []
          }
      ],
      serviceDependencies: [],
      platformDependencies: ['Auth0', 'AWS DynamoDB']
  },
  {
      serviceName: 'Content Delivery Service',
      serviceDescription: 'Manages content streaming and delivery to users.',
      owningTeamId: 'team2',
      apis: [
          {
              apiName: 'Stream Content API',
              apiDescription: 'Streams selected content to the user.',
              dependentApis: ['Subscription API', 'Profile API']
          },
          {
              apiName: 'Adaptive Bitrate API',
              apiDescription: 'Adjusts streaming quality based on network conditions.',
              dependentApis: []
          },
          {
              apiName: 'Content Caching API',
              apiDescription: 'Manages caching of frequently accessed content.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['Content Management Service', 'User Management Service', 'Billing and Subscription Service'],
      platformDependencies: ['AWS CloudFront', 'AWS S3']
  },
  {
      serviceName: 'Content Management Service',
      serviceDescription: 'Handles content ingestion, metadata, and catalog management.',
      owningTeamId: 'team3',
      apis: [
          {
              apiName: 'Content Ingestion API',
              apiDescription: 'Ingests new content into the platform.',
              dependentApis: []
          },
          {
              apiName: 'Metadata API',
              apiDescription: 'Manages content metadata like titles, descriptions, genres.',
              dependentApis: []
          },
          {
              apiName: 'Catalog API',
              apiDescription: 'Provides the catalog of available content.',
              dependentApis: []
          }
      ],
      serviceDependencies: [],
      platformDependencies: ['AWS S3', 'AWS Lambda']
  },
  {
      serviceName: 'Recommendation Engine Service',
      serviceDescription: 'Provides personalized content recommendations to users based on viewing history and preferences.',
      owningTeamId: 'team4',
      apis: [
          {
              apiName: 'Recommendations API',
              apiDescription: 'Retrieves recommended content for a user.',
              dependentApis: ['User Behavior Tracking API', 'Metadata API']
          },
          {
              apiName: 'User Behavior Tracking API',
              apiDescription: 'Tracks user interactions and viewing history.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Content Management Service', 'Analytics Service'],
      platformDependencies: ['AWS Machine Learning', 'Apache Spark']
  },
  {
      serviceName: 'Billing and Subscription Service',
      serviceDescription: 'Manages user subscriptions, billing, and payment processing.',
      owningTeamId: 'team5',
      apis: [
          {
              apiName: 'Subscription API',
              apiDescription: 'Manages user subscription plans.',
              dependentApis: []
          },
          {
              apiName: 'Payment Processing API',
              apiDescription: 'Processes payments securely.',
              dependentApis: ['Email Notification API']
          },
          {
              apiName: 'Invoice API',
              apiDescription: 'Generates invoices and billing statements.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Notification Service'],
      platformDependencies: ['Stripe API', 'AWS RDS']
  },
  {
      serviceName: 'Notification Service',
      serviceDescription: 'Sends notifications, emails, and in-app messages to users.',
      owningTeamId: 'team6',
      apis: [
          {
              apiName: 'Email Notification API',
              apiDescription: 'Sends email notifications to users.',
              dependentApis: []
          },
          {
              apiName: 'Push Notification API',
              apiDescription: 'Sends push notifications to user devices.',
              dependentApis: ['Profile API']
          },
          {
              apiName: 'In-App Messaging API',
              apiDescription: 'Displays messages within the app.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Billing and Subscription Service'],
      platformDependencies: ['AWS SNS', 'Firebase Cloud Messaging']
  },
  {
      serviceName: 'Analytics Service',
      serviceDescription: 'Collects and analyzes data on user engagement, content performance, and platform metrics.',
      owningTeamId: 'team7',
      apis: [
          {
              apiName: 'Data Collection API',
              apiDescription: 'Collects data from various services.',
              dependentApis: []
          },
          {
              apiName: 'Reporting API',
              apiDescription: 'Provides analytical reports and dashboards.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Content Delivery Service', 'Recommendation Engine Service'],
      platformDependencies: ['AWS Redshift', 'Tableau']
  },
  {
      serviceName: 'Search Service',
      serviceDescription: 'Enables users to search for content across the platform.',
      owningTeamId: 'team8',
      apis: [
          {
              apiName: 'Search API',
              apiDescription: 'Allows users to search for content by title, genre, etc.',
              dependentApis: []
          },
          {
              apiName: 'Autocomplete API',
              apiDescription: 'Provides search suggestions as users type.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['Content Management Service', 'User Management Service'],
      platformDependencies: ['Elasticsearch']
  }
];

/** Updated System Data for StreamView (including seniorManagers and yearlyInitiatives) **/
const sampleSystemDataStreamView = {
    systemName: 'StreamView',
    systemDescription: 'StreamView is a video streaming platform that provides personalized content to users worldwide.',
    seniorManagers: sampleSeniorManagersDataStreamView,
    teams: sampleTeamsDataStreamView,
    sdms: sampleSDMsDataStreamView,
    pmts: samplePMTsDataStreamView,
    services: sampleServicesDataStreamView,
    platformDependencies: [], // Will be built dynamically on load
    yearlyInitiatives: [
        // --- Protected Initiatives ---
        {
            initiativeId: 'init-sv-ktlo', title: 'KTLO / Operational Excellence', description: 'Ongoing bug fixes, refactoring, library updates, minor enhancements.', relatedBusinessGoalId: 'eng-excellence', isProtected: true,
            assignments: [ // Assign estimate to all teams
                { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.75 }, { teamId: 'team4', sdeYears: 1.25 },
                { teamId: 'team5', sdeYears: 0.75 }, { teamId: 'team6', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }
            ]
        },
        {
            initiativeId: 'init-sv-oncall', title: 'On-Call / Production Support', description: 'Dedicated capacity for handling live site issues and production incidents.', relatedBusinessGoalId: 'ops-stability', isProtected: true,
            assignments: [ // Assign 1 SDE Year to all teams
                 { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 1.0 }, { teamId: 'team4', sdeYears: 1.0 },
                 { teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 1.0 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 1.0 }
            ]
        },
        {
            initiativeId: 'init-sv-security', title: 'Mandatory Security Hardening (Compliance)', description: 'Address critical security vulnerabilities and ensure compliance (e.g., SOC2, GDPR).', relatedBusinessGoalId: 'compliance', isProtected: true,
            assignments: [
                { teamId: 'team1', sdeYears: 0.5 }, // User Management
                { teamId: 'team5', sdeYears: 0.75 }, // Billing/Finance
                // Add infra/platform team if one existed, assume team2 handles some platform aspects
                { teamId: 'team2', sdeYears: 0.5 } // Content Delivery/Platform
            ]
        },
        // --- Feature/Product Initiatives (Examples) ---
        { initiativeId: 'init-sv-001', title: 'AV1 Codec Support', description: 'Implement AV1 codec for improved streaming efficiency.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 2.5 }, { teamId: 'team3', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-002', title: 'Tiered Subscription Model', description: 'Launch new subscription tiers (Basic, Premium, Family).', relatedBusinessGoalId: 'revenue-growth', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 3.0 }, { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-003', title: 'Recommendation Algorithm V3', description: 'Develop and deploy next-gen recommendation engine.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 4.0 }, { teamId: 'team7', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-004', title: 'Expand CDN to South America', description: 'Set up CDN infrastructure in SA region.', relatedBusinessGoalId: 'global-expansion', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-005', title: 'User Profile Enhancements', description: 'Add customizable avatars and viewing preferences.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-006', title: 'Content Search Facets', description: 'Improve search with filters for genre, rating, year.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-007', title: 'Offline Viewing Improvements', description: 'Enhance download stability and management.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-008', title: 'A/B Testing Framework', description: 'Build internal framework for feature A/B testing.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 2.0 }] },
        { initiativeId: 'init-sv-009', title: 'Parental Controls V2', description: 'Granular controls per profile and content rating.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-010', title: 'Interactive Content POC', description: 'Proof-of-concept for choose-your-own-adventure style content.', relatedBusinessGoalId: 'innovation', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 0.75 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-011', title: 'Payment Gateway Integration (New Region)', description: 'Add local payment options for APAC.', relatedBusinessGoalId: 'global-expansion', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-012', title: 'Real-time Analytics Dashboard', description: 'Internal dashboard for viewing concurrency and errors.', relatedBusinessGoalId: 'ops-stability', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-013', title: 'Watch Party Feature', description: 'Allow users to watch content synchronously with friends.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.5 }, { teamId: 'team6', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-014', title: 'Metadata Enrichment AI', description: 'Use AI to auto-tag content metadata.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team3', sdeYears: 1.5 }, { teamId: 'team4', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-015', title: 'GDPR Data Deletion Automation', description: 'Automate user data deletion requests for GDPR.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.75 }, { teamId: 'team7', sdeYears: 0.25 }] },
        { initiativeId: 'init-sv-016', title: 'Improved Subtitle Customization', description: 'Allow users to change subtitle font, size, color.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.5 }] },
        { initiativeId: 'init-sv-017', title: 'Search Performance Optimization', description: 'Reduce search latency by 50%.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-018', title: 'Gift Subscriptions', description: 'Allow users to purchase subscriptions for others.', relatedBusinessGoalId: 'revenue-growth', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 0.25 }] },
        { initiativeId: 'init-sv-019', title: 'Video Player Accessibility Audit & Fixes', description: 'Ensure player meets WCAG AA standards.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.75 }] },
        { initiativeId: 'init-sv-020', title: 'Reduce Streaming Startup Time', description: 'Optimize playback start time for users.', relatedBusinessGoalId: 'user-experience', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }] },
        { initiativeId: 'init-sv-021', title: 'Content Partner Reporting Portal', description: 'Allow content partners to view performance data.', relatedBusinessGoalId: 'partnerships', isProtected: false, assignments: [{ teamId: 'team3', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-sv-022', title: 'Personalized Push Notifications', description: 'Send targeted notifications based on viewing habits.', relatedBusinessGoalId: 'engagement', isProtected: false, assignments: [{ teamId: 'team6', sdeYears: 1.0 }, { teamId: 'team4', sdeYears: 0.5 }] }
    ]
};

/** Sample Data for ConnectPro **/

/** Define Senior Managers for ConnectPro **/
const sampleSeniorManagersDataContactCenter = [
    { seniorManagerId: 'srMgrCC1', seniorManagerName: 'Senior Sam' }
    // Only one senior manager for this example
];

/** Updated SDMs Data for ConnectPro (with seniorManagerId) **/
const contactCenterSDMsData = [
    { sdmId: 'sdm1', sdmName: 'Alex Johnson', seniorManagerId: 'srMgrCC1' },
    { sdmId: 'sdm2', sdmName: 'Matthew Jackson', seniorManagerId: 'srMgrCC1' },
    { sdmId: 'sdm3', sdmName: 'Ryan King', seniorManagerId: 'srMgrCC1' },
    { sdmId: 'sdm4', sdmName: 'Laura Turner', seniorManagerId: 'srMgrCC1' }
];

const contactCenterPMTsData = [
    { pmtId: 'pmt1', pmtName: 'Karen Davis' },          // Shared between team1 and team8
    { pmtId: 'pmt2', pmtName: 'Patricia Thompson' },    // Shared among team2, team3, team6
    { pmtId: 'pmt3', pmtName: 'Angela Green' },         // Shared between team4 and team5
    { pmtId: 'pmt4', pmtName: 'Stephanie Roberts' }     // PMT for team7
];

/** Updated Teams Data for ConnectPro (with fundedHeadcount, buildersInSeats, engineers array) **/
const contactCenterTeamsData = [
    {
        teamId: 'team1',
        teamName: 'Customer Experience Team',
        teamIdentity: 'CX Warriors',
        fundedHeadcount: 6,
        buildersInSeats: 5,
        engineers: [
            { name: 'Alex Johnson', level: 4 }, // Assuming SDM might be L4+
            { name: 'Emily Smith', level: 3 },
            { name: 'David Lee', level: 3 },
            { name: 'Sarah Brown', level: 2 },
            { name: 'Michael Wilson', level: 1 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm1',
        pmtId: 'pmt1'
    },
    {
        teamId: 'team2',
        teamName: 'Case Management Team',
        teamIdentity: 'Case Titans',
        fundedHeadcount: 5,
        buildersInSeats: 4,
        engineers: [
            { name: 'Jessica Taylor', level: 4 },
            { name: 'Daniel Moore', level: 3 },
            { name: 'Amy Anderson', level: 2 },
            { name: 'James Thomas', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm1',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team3',
        teamName: 'Routing and Agent Tools Team', // Note: Original had 7 names, split into team3/4
        teamIdentity: 'Routing Rangers',
        fundedHeadcount: 5, // Adjusted
        buildersInSeats: 4, // Adjusted
        engineers: [
            { name: 'Matthew Jackson', level: 5 }, // Assuming SDM L5
            { name: 'Ashley White', level: 3 },
            { name: 'Joshua Harris', level: 2 },
            { name: 'Andrew Garcia', level: 2 } // Moved Andrew here
        ],
        awayTeamMembers: [
            { name: 'Helping Hannah', level: 2, sourceTeam: 'AI Research Division' }
        ], // Example away team member
        sdmId: 'sdm2',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team4',
        teamName: 'Agent Tools Team', // Note: Original had 7 names, split into team3/4
        teamIdentity: 'Agent Aces',
        fundedHeadcount: 4, // Adjusted
        buildersInSeats: 3, // Adjusted
        engineers: [
             // Andrew Garcia moved to team3
            { name: 'Megan Clark', level: 3 },
            { name: 'Steven Lewis', level: 2 },
            { name: 'Nicole Young', level: 1 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm2', // Still under Matthew Jackson
        pmtId: 'pmt3'
    },
    {
        teamId: 'team5',
        teamName: 'Communication Channels Team',
        teamIdentity: 'Comm Mandalorians',
        fundedHeadcount: 6,
        buildersInSeats: 5,
        engineers: [
            { name: 'Ryan King', level: 4 }, // Assuming SDM L4
            { name: 'Samantha Wright', level: 3 },
            { name: 'Brandon Lopez', level: 3 },
            { name: 'Rachel Hill', level: 2 },
            { name: 'Justin Scott', level: 2 }
        ],
        awayTeamMembers: [
            { name: 'Support Sam', level: 3, sourceTeam: 'Sister Company Ops' }
        ], // Example away team member
        sdmId: 'sdm3',
        pmtId: 'pmt3'
    },
    {
        teamId: 'team6',
        teamName: 'Skills Management Team',
        teamIdentity: 'Skill Masters',
        fundedHeadcount: 3,
        buildersInSeats: 2,
        engineers: [
            { name: 'Kimberly Adams', level: 3 },
            { name: 'Jonathan Baker', level: 2 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm3',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team7',
        teamName: 'Analytics and Configuration Team', // Note: Original had 5 names, split into team7/8
        teamIdentity: 'Data Wizards',
        fundedHeadcount: 4, // Adjusted
        buildersInSeats: 3, // Adjusted
        engineers: [
            { name: 'Jason Carter', level: 4 },
            { name: 'Melissa Mitchell', level: 3 },
            { name: 'Kevin Perez', level: 2 }
            // Laura Turner and Eric Phillips moved to team8
        ],
        awayTeamMembers: [],
        sdmId: 'sdm4',
        pmtId: 'pmt4'
    },
    {
        teamId: 'team8',
        teamName: 'Configuration Team', // Note: Original had 5 names, split into team7/8
        teamIdentity: 'Config Ninjas',
        fundedHeadcount: 3, // Adjusted
        buildersInSeats: 2, // Adjusted
        engineers: [
            { name: 'Laura Turner', level: 4 }, // Assuming SDM L4
            { name: 'Eric Phillips', level: 3 }
        ],
        awayTeamMembers: [],
        sdmId: 'sdm4', // Still under Laura Turner
        pmtId: 'pmt1'
    }
];


const sampleServicesDataConnectPro = [
    {
        serviceName: 'Customer Portal Service',
        serviceDescription: 'Allows customers to raise support tickets and track their status.',
        owningTeamId: 'team1',
        apis: [
            {
                apiName: 'Ticket Submission API',
                apiDescription: 'Enables customers to submit support tickets.',
                dependentApis: []
            },
            {
                apiName: 'Ticket Tracking API',
                apiDescription: 'Allows customers to check the status of their tickets.',
                dependentApis: []
            }
        ],
        serviceDependencies: [],
        platformDependencies: ['AWS Cognito', 'AWS S3']
    },
    {
        serviceName: 'Case Management Service',
        serviceDescription: 'Manages the lifecycle of support tickets within the system.',
        owningTeamId: 'team2',
        apis: [
            {
                apiName: 'Case Creation API',
                apiDescription: 'Creates a new case in the system.',
                dependentApis: []
            },
            {
                apiName: 'Case Update API',
                apiDescription: 'Updates case details and status.',
                dependentApis: []
            },
            {
                apiName: 'Case Assignment API',
                apiDescription: 'Assigns cases to agents based on skills and availability.',
                dependentApis: ['Skills Assignment API']
            }
        ],
        serviceDependencies: ['Customer Portal Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS DynamoDB']
    },
    {
        serviceName: 'Routing Service',
        serviceDescription: 'Routes incoming interactions to appropriate agents.',
        owningTeamId: 'team3', // Owned by team3
        apis: [
            {
                apiName: 'Interaction Routing API',
                apiDescription: 'Routes voice, email, and chat interactions.',
                dependentApis: ['Skill Matching API', 'Agent Login API']
            },
            {
                apiName: 'Skill Matching API',
                apiDescription: 'Matches interactions to agents based on skills.',
                dependentApis: ['Skills Evaluation API']
            }
        ],
        serviceDependencies: ['Communication Channels Service', 'Skills Management Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS Lambda']
    },
    {
        serviceName: 'Agent Desktop Service',
        serviceDescription: 'Provides agents with tools to handle customer interactions.',
        owningTeamId: 'team4', 
        apis: [
            {
                apiName: 'Agent Login API',
                apiDescription: 'Authenticates agents and starts their session.',
                dependentApis: []
            },
            {
                apiName: 'Interaction Handling API',
                apiDescription: 'Manages ongoing interactions with customers.',
                dependentApis: ['Case Retrieval API']
            },
            {
                apiName: 'Case Retrieval API',
                apiDescription: 'Retrieves case details for agents.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service'],
        platformDependencies: ['AWS AppSync']
    },
    {
        serviceName: 'Communication Channels Service',
        serviceDescription: 'Handles voice calls, emails, and chat messages.',
        owningTeamId: 'team5',
        apis: [
            {
                apiName: 'Voice Call API',
                apiDescription: 'Manages voice call connections.',
                dependentApis: []
            },
            {
                apiName: 'Email Processing API',
                apiDescription: 'Processes incoming and outgoing emails.',
                dependentApis: []
            },
            {
                apiName: 'Chat Messaging API',
                apiDescription: 'Manages live chat sessions.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Routing Service', 'Agent Desktop Service'],
        platformDependencies: ['Amazon Connect', 'AWS SES', 'Amazon Lex']
    },
    {
        serviceName: 'Skills Management Service',
        serviceDescription: 'Manages agent skills and competencies.',
        owningTeamId: 'team6',
        apis: [
            {
                apiName: 'Skills Assignment API',
                apiDescription: 'Assigns skills to agents.',
                dependentApis: []
            },
            {
                apiName: 'Skills Evaluation API',
                apiDescription: 'Evaluates agent performance in skills.',
                dependentApis: []
            }
        ],
        serviceDependencies: [],
        platformDependencies: ['AWS Machine Learning']
    },
    {
        serviceName: 'Reporting and Analytics Service',
        serviceDescription: 'Provides reports on contact center performance.',
        owningTeamId: 'team7',
        apis: [
            {
                apiName: 'Performance Metrics API',
                apiDescription: 'Retrieves metrics on agent and center performance.',
                dependentApis: []
            },
            {
                apiName: 'Historical Data API',
                apiDescription: 'Accesses historical interaction data.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS Redshift', 'Amazon QuickSight']
    },
    {
        serviceName: 'Business Configuration Service',
        serviceDescription: 'Allows administrators to configure business rules and settings.',
        owningTeamId: 'team8', 
        apis: [
            {
                apiName: 'Settings API',
                apiDescription: 'Manages system-wide settings.',
                dependentApis: []
            },
            {
                apiName: 'Rules Engine API',
                apiDescription: 'Defines routing and assignment rules.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service', 'Agent Desktop Service', 'Communication Channels Service', 'Skills Management Service'],
        platformDependencies: ['AWS CloudFormation']
    }
];

/** Updated System Data for ConnectPro (including seniorManagers and yearlyInitiatives) **/
const sampleSystemDataContactCenter = {
    systemName: 'ConnectPro',
    systemDescription: 'ConnectPro is a cloud-based contact center solution that streamlines customer interactions across multiple channels.',
    seniorManagers: sampleSeniorManagersDataContactCenter,
    teams: contactCenterTeamsData,
    sdms: contactCenterSDMsData,
    pmts: contactCenterPMTsData,
    services: sampleServicesDataConnectPro,
    platformDependencies: [], // Will be built dynamically on load
    yearlyInitiatives: [
        // --- Protected Initiatives ---
        {
            initiativeId: 'init-cc-ktlo', title: 'KTLO / Operational Excellence', description: 'Ongoing bug fixes, refactoring, library updates, minor enhancements.', relatedBusinessGoalId: 'eng-excellence', isProtected: true,
            assignments: [ // Assign estimate to all teams
                { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.75 }, { teamId: 'team4', sdeYears: 0.75 },
                { teamId: 'team5', sdeYears: 1.25 }, { teamId: 'team6', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }
            ]
        },
        {
            initiativeId: 'init-cc-oncall', title: 'On-Call / Production Support', description: 'Dedicated capacity for handling live site issues and production incidents.', relatedBusinessGoalId: 'ops-stability', isProtected: true,
            assignments: [ // Assign 1 SDE Year to all teams
                 { teamId: 'team1', sdeYears: 1.0 }, { teamId: 'team2', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 1.0 }, { teamId: 'team4', sdeYears: 1.0 },
                 { teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team6', sdeYears: 1.0 }, { teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 1.0 }
            ]
        },
        {
            initiativeId: 'init-cc-security', title: 'Mandatory Security Audit & Remediation', description: 'Address findings from annual security audit and maintain compliance.', relatedBusinessGoalId: 'compliance', isProtected: true,
            assignments: [
                { teamId: 'team1', sdeYears: 0.5 }, // Customer Portal
                { teamId: 'team4', sdeYears: 0.75 }, // Agent Desktop
                { teamId: 'team5', sdeYears: 0.5 }, // Comm Channels (sensitive data)
                { teamId: 'team8', sdeYears: 0.5 }  // Config / Infra
            ]
        },
        // --- Feature/Product Initiatives (Examples) ---
        { initiativeId: 'init-cc-001', title: 'Omnichannel Support (Chat)', description: 'Integrate live chat channel support.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 2.0 }, { teamId: 'team4', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-002', title: 'AI-Powered Agent Assist (KB Suggestions)', description: 'Suggest relevant knowledge base articles to agents in real-time.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 2.5 }, { teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-cc-003', title: 'Upgrade Reporting Engine', description: 'Migrate reporting to new platform for better performance.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 3.0 }] },
        { initiativeId: 'init-cc-004', title: 'Salesforce CRM Integration V1', description: 'Basic integration to sync contact data and case creation.', relatedBusinessGoalId: 'integration', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }, { teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-005', title: 'Customer Portal Self-Service KB', description: 'Allow customers to search knowledge base via portal.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 1.5 }] },
        { initiativeId: 'init-cc-006', title: 'Advanced Routing Rules (Time-based)', description: 'Allow configuration of time-of-day routing.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team3', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-007', title: 'Agent Performance Dashboard', description: 'New dashboard in agent desktop showing key metrics.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 1.0 }, { teamId: 'team7', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-008', title: 'Skills-Based Routing Enhancements', description: 'Add proficiency levels to skill matching.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team6', sdeYears: 1.5 }, { teamId: 'team3', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-009', title: 'Email Channel Integration', description: 'Add support for email as an interaction channel.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.5 }, { teamId: 'team4', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-010', title: 'Voice Call Recording & Playback', description: 'Implement secure call recording and retrieval.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 2.0 }, { teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-011', title: 'Case Prioritization Engine', description: 'Automatically prioritize cases based on SLA or sentiment.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 1.5 }, { teamId: 'team7', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-012', title: 'Configuration Change History', description: 'Track who changed what configuration when.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 1.0 }] },
        { initiativeId: 'init-cc-013', title: 'CTI Screen Pop Improvements', description: 'Customize screen pop data based on call context.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team4', sdeYears: 1.0 }, { teamId: 'team5', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-014', title: 'Sentiment Analysis POC', description: 'Proof-of-concept for analyzing sentiment in chat/email.', relatedBusinessGoalId: 'innovation', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 1.0 }] },
        { initiativeId: 'init-cc-015', title: 'Supervisor Barge-In/Listen-In', description: 'Allow supervisors to monitor or join live calls.', relatedBusinessGoalId: 'quality-assurance', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.5 }, { teamId: 'team4', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-016', title: 'Customer Satisfaction Survey (CSAT)', description: 'Implement post-interaction CSAT surveys.', relatedBusinessGoalId: 'customer-sat', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.5 }, { teamId: 'team7', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-017', title: 'Agent Skill Self-Assessment', description: 'Allow agents to update their skill profiles.', relatedBusinessGoalId: 'agent-efficiency', isProtected: false, assignments: [{ teamId: 'team6', sdeYears: 0.75 }, { teamId: 'team4', sdeYears: 0.25 }] },
        { initiativeId: 'init-cc-018', title: 'Knowledge Base Article Versioning', description: 'Track changes and history for KB articles.', relatedBusinessGoalId: 'eng-excellence', isProtected: false, assignments: [{ teamId: 'team1', sdeYears: 0.5 }] }, // Assuming portal team owns KB UI
        { initiativeId: 'init-cc-019', title: 'Real-time Queue Dashboard', description: 'Dashboard showing queue lengths, wait times.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team7', sdeYears: 1.0 }, { teamId: 'team3', sdeYears: 0.25 }] },
        { initiativeId: 'init-cc-020', title: 'Automated Case Closure Rules', description: 'Configure rules to auto-close inactive cases.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team2', sdeYears: 0.75 }, { teamId: 'team8', sdeYears: 0.25 }] },
        { initiativeId: 'init-cc-021', title: 'Bulk User Import/Update', description: 'Allow admins to manage agents in bulk.', relatedBusinessGoalId: 'ops-efficiency', isProtected: false, assignments: [{ teamId: 'team8', sdeYears: 0.5 }] },
        { initiativeId: 'init-cc-022', title: 'PCI Compliance for Call Recordings', description: 'Ensure call recording storage meets PCI standards.', relatedBusinessGoalId: 'compliance', isProtected: false, assignments: [{ teamId: 'team5', sdeYears: 1.0 }, { teamId: 'team8', sdeYears: 0.5 }] }
    ]
};

window.onload = function() {
    console.log("!!! Window on load !!!!");
    
    currentMode = Modes.NAVIGATION;
    // Initialize UI accordingly
};

/** Save Sample Systems to Local Storage **/

function saveSampleSystemsToLocalStorage() {
    if (!localStorage.getItem(LOCAL_STORAGE_KEY)) {
        const systems = {
            'StreamView': sampleSystemDataStreamView,
            'ConnectPro': sampleSystemDataContactCenter
        };
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));
    }
}


// Call the function to save sample systems on page load
saveSampleSystemsToLocalStorage();

/** Show Saved Systems **/

function showSavedSystems() {
    // Retrieve the systems from local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    const systemNames = Object.keys(systems);

    // If no systems are saved, alert the user
    if (systemNames.length === 0) {
        alert('No saved systems found.');
        return;
    }

    // Create a list of systems for the user to select from
    let systemListHtml = '<h2>Select a System to Load</h2><ul>';
    systemNames.forEach(systemName => {
        systemListHtml += `<li><a href="#" onclick="loadSavedSystem('${systemName}')">${systemName}</a></li>`;
    });
    systemListHtml += '</ul>';

    // Display the list in a modal or in a div
    let systemListDiv = document.createElement('div');
    systemListDiv.id = 'systemListDiv';
    systemListDiv.innerHTML = systemListHtml;

    // Add a close button
    let closeButton = document.createElement('button');
    closeButton.innerText = 'Close';
    closeButton.onclick = function() {
        document.body.removeChild(systemListDiv);
    };
    systemListDiv.appendChild(closeButton);

    // Style the div
    systemListDiv.style.position = 'fixed';
    systemListDiv.style.top = '50%';
    systemListDiv.style.left = '50%';
    systemListDiv.style.transform = 'translate(-50%, -50%)';
    systemListDiv.style.backgroundColor = '#fff';
    systemListDiv.style.padding = '20px';
    systemListDiv.style.border = '1px solid #ccc';
    systemListDiv.style.zIndex = '1000';

    // Append the div to the body
    document.body.appendChild(systemListDiv);
}

function buildGlobalPlatformDependencies() {
    const platformDepsSet = new Set();

    // Iterate over services to collect platform dependencies
    currentSystemData.services.forEach(service => {
        if (service.platformDependencies) {
            service.platformDependencies.forEach(dep => {
                platformDepsSet.add(dep);
            });
        }
    });

    // Convert the set to an array and assign to currentSystemData
    currentSystemData.platformDependencies = Array.from(platformDepsSet);
}

/** Load Saved System **/

function loadSavedSystem(systemName) {
    currentMode = Modes.BROWSING;
    
    // Retrieve the systems from local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    const systemData = systems[systemName];

    // **Add console log to see what's in local storage**
    console.log('Loaded systems from local storage:', systems);
    
    if (!systemData) {
        alert('System not found.');
        return;
    }

    // **Add console log to verify currentSystemData**
    console.log('Loaded currentSystemData:', currentSystemData);
    
    // Remove the system list div
    const systemListDiv = document.getElementById('systemListDiv');
    if (systemListDiv) {
        document.body.removeChild(systemListDiv);
    }

    // Clear previous content
    d3.selectAll('.tooltip').remove(); // Remove any existing tooltips
    //document.getElementById('teamTable').innerHTML = `
    //    <tr>
     //       <th>SDM</th>
     //       <th>Team Identity</th>
     //       <th>Team Name</th>
    //       <th>PMT</th>
     //       <th>Size of Team</th>
     //       <th>Engineer Names</th>
     //       <th>Services Owned</th>
     //   </tr>
    //`;
    document.getElementById('legend').innerHTML = '';
    document.getElementById('teamLegend').innerHTML = '';
    
    document.getElementById('organogramView').style.display = 'none';
    document.getElementById('engineerTableView').style.display = 'none';

    currentSystemData = systemData; // Store the current system data

    // **Add console log to verify currentSystemData**
    console.log('Selected system to load:', currentSystemData);
    
    // Re-initialize uniqueEngineers based on currentSystemData
    uniqueEngineers = [];
    currentSystemData.teams.forEach(team => {
        const engineers = team.engineerNames ? team.engineerNames.split(',').map(name => name.trim()) : [];
        engineers.forEach(engineerName => {
            uniqueEngineers.push({ engineerName, teamId: team.teamId });
        });
    });


   // Ensure platformDependencies is initialized
   if (!currentSystemData.platformDependencies) {
       currentSystemData.platformDependencies = [];
   }
    // Build global platform dependencies list
    buildGlobalPlatformDependencies();
    
    // Update the page title and description
    document.getElementById('pageTitle').innerText = currentSystemData.systemName;
    document.getElementById('systemDescription').innerText = currentSystemData.systemDescription || '';
    
    
    
    // Hide the menu
    document.querySelector('.menu').style.display = 'none';

    // Show the "Edit System" button
    document.querySelector('.edit-menu').style.display = 'block';

    // Display visualization and team breakdown sections
    document.getElementById('visualization').style.display = 'block';
    document.getElementById('teamVisualization').style.display = 'block';
    document.getElementById('teamBreakdown').style.display = 'block';

    // ** Show the new service relationships visualization **
    document.getElementById('serviceRelationshipsVisualization').style.display = 'block';

    // Show the new dependency visualization section
    document.getElementById('dependencyVisualization').style.display = 'block';    

    // Populate the service selection drop-down
    populateServiceSelection();
    
    // Generate the network graph
    generateVisualization(systemData);
    // Generate the team relationships visualization
    generateTeamVisualization(systemData);
    // Generate the team breakdown table
    generateTeamTable(systemData);

    // Generate the initial service relationships visualization (All Services View)
    updateServiceVisualization();

    // Populate the service selection for the dependency visualization
    populateDependencyServiceSelection();

    // Generate the initial dependency visualization
    updateDependencyVisualization();    
    
    //show the services dependency table
    generateServiceDependenciesTable();
    // Show the Service Dependencies Table
    document.getElementById('serviceDependenciesTable').style.display = 'block';    
    
    // Debugging: Log currentSystemData after loading
    console.log('Loaded currentSystemData:', currentSystemData);
    
}


/** Generate System Visualization **/

function generateVisualization(systemData) {
    let svg = d3.select('#systemSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // Set SVG dimensions
    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    // Append a group element that will contain all the graph elements
    let graphGroup = svg.append('g');

    // Define the zoom behavior
    let zoom = d3.zoom()
        .scaleExtent([0.5, 5])
        .on('zoom', zoomed);

    // Apply the zoom behavior to the SVG
    svg.call(zoom);

    // Define the zoomed function
    function zoomed(event) {
        graphGroup.attr('transform', event.transform);
    }

    // Define node radius
    const radius = 10;

    // Prepare nodes and links data
    let nodes = [];
    let links = [];
    let nodeMap = {};

    // Create a color scale based on teams
    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = systemData.teams.map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Create nodes for services and APIs
    systemData.services.forEach(service => {
        let teamId = service.owningTeamId || 'unassigned';
        let nodeColor = teamColorScale(teamId);

        nodes.push({ id: service.serviceName, type: 'service', teamId: teamId, color: nodeColor });
        nodeMap[service.serviceName] = { id: service.serviceName, type: 'service' };

        service.apis.forEach(api => {
            nodes.push({ id: api.apiName, type: 'api', teamId: teamId, color: nodeColor });
            nodeMap[api.apiName] = { id: api.apiName, type: 'api' };
            // Link API to its service
            links.push({
                source: api.apiName,
                target: service.serviceName,
                type: 'api-service'
            });
        });
    });

    // Add platform dependencies as nodes
    systemData.services.forEach(service => {
        service.platformDependencies.forEach(platform => {
            if (!nodeMap[platform]) {
                nodes.push({ id: platform, type: 'platform', color: '#a04040' }); // Platforms have their own color
                nodeMap[platform] = { id: platform, type: 'platform' };
            }
            // Link service to platform
            links.push({
                source: service.serviceName,
                target: platform,
                type: 'platform-dependency'
            });
        });
    });

    // Create links based on service dependencies
    systemData.services.forEach(service => {
        // Service dependencies
        service.serviceDependencies.forEach(dependency => {
            if (nodeMap[dependency]) {
                links.push({
                    source: service.serviceName,
                    target: dependency,
                    type: 'service-dependency'
                });
            }
        });
        // API dependencies
        service.apis.forEach(api => {
            api.dependentApis.forEach(depApi => {
                if (nodeMap[depApi]) {
                    links.push({
                        source: api.apiName,
                        target: depApi,
                        type: 'api-dependency'
                    });
                }
            });
        });
    });

    // Calculate the number of nodes
    const nodeCount = nodes.length;

    // Adjust force strengths based on node count
    let chargeStrength = -300;
    let linkDistance = 100;

    if (nodeCount > 100) {
        chargeStrength = -100;
        linkDistance = 30;
    } else if (nodeCount > 50) {
        chargeStrength = -200;
        linkDistance = 50;
    }

    // Set up the simulation
    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(linkDistance))
        .force('charge', d3.forceManyBody().strength(chargeStrength))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 20));

    // Add links to the graphGroup
    let link = graphGroup.append('g')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-dasharray', d => {
            if (d.type === 'api-service') return '2,2';
            else if (d.type === 'service-dependency') return '5,5';
            else if (d.type === 'platform-dependency') return '10,5';
            else if (d.type === 'api-dependency') return '3,3';
            else return '1,0';
        })
        .attr('stroke-width', 1.5);

    // Add nodes to the graphGroup
    let node = graphGroup.append('g')
        .attr('stroke', '#fff')
        .attr('stroke-width', 1.5)
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', radius)
        .attr('fill', d => d.color)
        .call(drag(simulation));

    // Add labels to the graphGroup
    let labels = graphGroup.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 12)
        .attr('dy', 4)
        .text(d => d.id);

    // Tooltip
    let tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let info = '';
        if (d.type === 'service') {
            let service = systemData.services.find(s => s.serviceName === d.id);
            let team = systemData.teams.find(t => t.teamId === service.owningTeamId);
            info = `<strong>Service Name:</strong> ${service.serviceName}<br>
                    <strong>Description:</strong> ${service.serviceDescription}<br>
                    <strong>Team:</strong> ${team ? `${team.teamName} (${team.teamIdentity})` : 'Unassigned'}`;
        } else if (d.type === 'api') {
            let api;
            let serviceName;
            systemData.services.forEach(service => {
                service.apis.forEach(a => {
                    if (a.apiName === d.id) {
                        api = a;
                        serviceName = service.serviceName;
                    }
                });
            });
            info = `<strong>API Name:</strong> ${api.apiName}<br>
                    <strong>Description:</strong> ${api.apiDescription}<br>
                    <strong>Service:</strong> ${serviceName}`;
        } else if (d.type === 'platform') {
            info = `<strong>Platform Dependency:</strong> ${d.id}`;
        }
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5);
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    // Add legend for teams
    let legendData = systemData.teams.map(team => ({
        teamIdentity: team.teamIdentity,
        color: teamColorScale(team.teamId)
    }));

    let legend = d3.select('#legend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item');

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
}
/** Generate Team Relationships Visualization **/

function generateTeamVisualization(systemData) {
    let svg = d3.select('#teamSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // Set SVG dimensions
    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    // Define node radius
    const radius = 20;
    
    // Prepare nodes and links data
    let nodes = [];
    let links = [];
    let nodeMap = {};

    // Create a color scale for teams
    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = systemData.teams.map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Map teamId to services
    let teamServicesMap = {};
    systemData.services.forEach(service => {
        let teamId = service.owningTeamId;
        if (teamId) { // Ensure teamId is valid
            if (!teamServicesMap[teamId]) {
                teamServicesMap[teamId] = [];
            }
            teamServicesMap[teamId].push(service.serviceName);
        }
    });

    // Create nodes for teams
    systemData.teams.forEach(team => {
        if (team.teamId) { // Ensure teamId is valid
            nodes.push({
                id: team.teamId,
                name: team.teamIdentity,
                type: 'team',
                color: teamColorScale(team.teamId),
                services: teamServicesMap[team.teamId] || []
            });
            nodeMap[team.teamId] = { id: team.teamId };
        }
    });

    // Create links based on service dependencies
    let teamDependencies = {};

    systemData.services.forEach(service => {
        let owningTeamId = service.owningTeamId;
        if (owningTeamId && systemData.teams.some(t => t.teamId === owningTeamId)) { // Ensure owningTeamId is valid
            if (service.serviceDependencies.length > 0) {
                service.serviceDependencies.forEach(dependentServiceName => {
                    let dependentService = systemData.services.find(s => s.serviceName === dependentServiceName);
                    if (dependentService) {
                        let dependentTeamId = dependentService.owningTeamId;
                        if (dependentTeamId && owningTeamId !== dependentTeamId && systemData.teams.some(t => t.teamId === dependentTeamId)) {
                            let linkKey = owningTeamId + '-' + dependentTeamId;
                            if (!teamDependencies[linkKey]) {
                                teamDependencies[linkKey] = true;
                                links.push({
                                    source: owningTeamId,
                                    target: dependentTeamId,
                                    type: 'team-dependency'
                                });
                            }
                        }
                    }
                });
            }
        }
    });

    // Set up the simulation
    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 30));

    // Add links to the SVG
    let link = svg.append('g')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-width', 2);

    // Add nodes to the SVG
    let node = svg.append('g')
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', 20)
        .attr('fill', d => d.color)
        .call(drag(simulation));

    // Add labels to nodes
    let labels = svg.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 0)
        .attr('dy', 4)
        .attr('text-anchor', 'middle')
        .text(d => d.name);

    // Tooltip
    let tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let team = systemData.teams.find(t => t.teamId === d.id);
        let sdm = systemData.sdms.find(s => s.sdmId === team.sdmId);
        let pmt = systemData.pmts.find(p => p.pmtId === team.pmtId);
        let services = d.services.join(', ') || 'None';
        let info = `<strong>Team Identity:</strong> ${team.teamIdentity}<br>
                    <strong>Team Name:</strong> ${team.teamName}<br>
                    <strong>SDM:</strong> ${sdm ? sdm.sdmName : 'N/A'}<br>
                    <strong>PMT:</strong> ${pmt ? pmt.pmtName : 'N/A'}<br>
                    <strong>Size of Team:</strong> ${team.sizeOfTeam}<br>
                    <strong>Engineer Names:</strong> ${team.engineerNames}<br>
                    <strong>Services Owned:</strong> ${services}`;
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5);
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    // Add legend for teams
    let legendData = systemData.teams.map(team => ({
        teamIdentity: team.teamIdentity,
        color: teamColorScale(team.teamId)
    }));

    let legend = d3.select('#teamLegend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item');

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
}

//** Generate Team Breakdown Table **/
/** REVISED Generate Team Breakdown Table - Incorporates Away-Team, New Columns & Calculations */
function generateTeamTable(systemData) {
    console.log("Generating Team Table - Enhanced Version..."); // Log function start

    let teamTable = document.getElementById('teamTable');
    let tableBody = teamTable.querySelector('tbody');
    let tableHead = teamTable.querySelector('thead'); // Get the thead element
    let tableFoot = teamTable.querySelector('tfoot'); // Get the tfoot element

    if (!tableBody || !tableHead || !tableFoot) {
        console.error("generateTeamTable: Could not find required table elements (thead, tbody, tfoot).");
        // Basic error display if table structure is broken
        if (document.getElementById('teamTable')) {
             document.getElementById('teamTable').innerHTML = '<tr><td colspan="12" style="color:red;">Error: Table structure incomplete.</td></tr>';
        }
        return;
    }
    tableBody.innerHTML = ''; // Clear existing content from tbody only

    // --- 1. Update Column Headers ---
    const headerRow = tableHead.querySelector('tr');
    headerRow.innerHTML = ''; // Clear existing headers to rebuild in order

    // Define headers with new names, order, and tooltips
    const headersConfig = [
        { text: 'Senior Manager', title: 'Senior Manager overseeing the SDM(s).' },
        { text: 'SDM', title: 'Software Development Manager for the team(s).' },
        { text: 'Team Identity', title: 'Unique identifier or codename for the team.' },
        { text: 'Team Name', title: 'Official name of the team.' },
        { text: 'PMT', title: 'Product Management counterpart for the team.' },
        { text: 'Team BIS', title: 'Builders In Seats: Count of actual engineers assigned to this team.' }, // NEW
        { text: 'Finance Approved Funding', title: 'Official budgeted headcount allocated by finance.' }, // RENAMED
        { text: 'Effective BIS to deliver initiatives', title: 'Total building capacity including team members and away-team resources (Team BIS + Away-Team BIS).' }, // RENAMED
        { text: 'BIS Hiring Gap', title: 'Gap between Finance Approved Funding and actual Team BIS (Funded - Team BIS). Shows hiring need.' }, // RENAMED & RECALCULATED
        { text: 'Engineers (Level)', title: 'List of engineers assigned to this team and their level.' },
        { text: 'Away-Team Members', title: 'List of engineers borrowed from other teams/orgs, their level, and source.' }, // NEW
        { text: 'Services Owned', title: 'List of services this team owns.' }
    ];

    headersConfig.forEach(config => {
        const th = document.createElement('th');
        th.textContent = config.text;
        th.title = config.title; // Add tooltip
        th.style.border = '1px solid #ccc';
        th.style.padding = '8px';
        th.style.textAlign = 'left';
        th.style.backgroundColor = '#f2f2f2';
        th.style.position = 'sticky'; // Keep headers sticky
        th.style.top = '0';
        th.style.zIndex = '1'; // Ensure headers stay above scrolling content
        headerRow.appendChild(th);
    });
    // --- End Header Update ---


    // --- 2. Defensive checks for core data ---
    if (!systemData || !systemData.teams || !Array.isArray(systemData.teams)) {
        console.error("generateTeamTable: Invalid or missing systemData.teams");
        let errRow = tableBody.insertRow();
        let cell = errRow.insertCell();
        cell.colSpan = headersConfig.length; // Use dynamic colspan
        cell.textContent = "Error: Team data is missing or invalid.";
        cell.style.color = 'red';
        // Clear footer totals if error occurs
        tableFoot.querySelectorAll('td').forEach(td => td.innerText = 'ERR'); // Clear all footer cells
        document.getElementById('gapNote').innerText = 'Error loading team data.';
        return;
    }
    const services = systemData.services || [];
    const sdms = systemData.sdms || [];
    const pmts = systemData.pmts || [];
    const seniorManagers = systemData.seniorManagers || [];
    // --- End Defensive Checks ---

    // --- 3. Totals Initialization ---
    let totalFundedHC = 0;
    let totalTeamBIS = 0; // NEW: Track total actual team members
    let totalEffectiveBIS = 0; // Track total effective capacity
    // --- End Totals Init ---

    // --- 4. Helper Functions (Keep as before) ---
    const getSeniorManagerName = (srMgrId) => { /* ... no changes ... */
        if (!srMgrId) return 'No Senior Manager';
        const srMgr = seniorManagers.find(s => s.seniorManagerId === srMgrId);
        return srMgr ? srMgr.seniorManagerName : `Unknown (${srMgrId})`;
     };
    const getSdmName = (sdmId) => { /* ... no changes ... */
        if (!sdmId) return 'No SDM';
        const sdm = sdms.find(s => s.sdmId === sdmId);
        return sdm ? sdm.sdmName : `Unknown (${sdmId})`;
    };
    const getPmtName = (pmtId) => { /* ... no changes ... */
        if (!pmtId) return 'N/A';
        const pmt = pmts.find(p => p.pmtId === pmtId);
        return pmt ? pmt.pmtName : `Unknown (${pmtId})`;
    };
    // --- End Helpers ---

    // --- 5. Map teamId to services (Keep as before) ---
    let teamServicesMap = {}; /* ... no changes ... */
    services.forEach(service => {
        let teamId = service.owningTeamId;
        if (teamId) {
            if (!teamServicesMap[teamId]) teamServicesMap[teamId] = [];
            teamServicesMap[teamId].push(service.serviceName);
        }
    });
    // --- End Service Map ---

    // --- 6. Group teams by Senior Manager -> SDM (Keep as before) ---
    let groupedData = {}; /* ... no changes ... */
    systemData.teams.forEach(team => {
        if (!team) return;
        const sdm = sdms.find(s => s.sdmId === team.sdmId);
        const srMgrId = sdm ? (sdm.seniorManagerId || 'no-sr-mgr') : 'no-sdm';
        const sdmId = team.sdmId || 'no-sdm';
        if (!groupedData[srMgrId]) groupedData[srMgrId] = {};
        if (!groupedData[srMgrId][sdmId]) groupedData[srMgrId][sdmId] = [];
        groupedData[srMgrId][sdmId].push(team);
    });
    // --- End Grouping ---

    // --- 7. Populate Table Body (Major Changes Here) ---
    for (const srMgrId in groupedData) {
        const srMgrData = groupedData[srMgrId];
        const srMgrNameDisplay = (srMgrId === 'no-sr-mgr' || srMgrId === 'no-sdm') ? 'No Assigned Senior Manager' : getSeniorManagerName(srMgrId);
        let isFirstRowForSrMgr = true;
        let srMgrRowspan = 0;
        for (const sdmId in srMgrData) { srMgrRowspan += srMgrData[sdmId].length; }

        for (const sdmId in srMgrData) {
            const teams = srMgrData[sdmId];
            const sdmNameDisplay = (sdmId === 'no-sdm') ? 'No Assigned SDM' : getSdmName(sdmId);
            let isFirstRowForSdm = true;

            teams.forEach((team) => {
                if (!team) return;
                let row = tableBody.insertRow();

                // --- Standard Grouping Cells ---
                if (isFirstRowForSrMgr) {
                    let srMgrCell = row.insertCell(); srMgrCell.innerText = srMgrNameDisplay; srMgrCell.rowSpan = srMgrRowspan; srMgrCell.style.verticalAlign = 'top'; isFirstRowForSrMgr = false;
                }
                if (isFirstRowForSdm) {
                    let sdmCell = row.insertCell(); sdmCell.innerText = sdmNameDisplay; sdmCell.rowSpan = teams.length; sdmCell.style.verticalAlign = 'top'; isFirstRowForSdm = false;
                }
                row.insertCell().innerText = team.teamIdentity || 'N/A';
                row.insertCell().innerText = team.teamName || 'N/A';
                row.insertCell().innerText = getPmtName(team.pmtId);
                // --- End Standard Grouping ---

                // *** NEW/REVISED Capacity Calculations & Cells ***
                const fundedHC = team.fundedHeadcount ?? 0;
                const teamBIS = team.engineers?.length ?? 0; // Actual team members
                const awayTeamBIS = team.awayTeamMembers?.length ?? 0; // Borrowed members
                const effectiveBIS = teamBIS + awayTeamBIS; // Total capacity
                const hiringGap = fundedHC - teamBIS; // Gap based on ACTUAL team members vs funding

                // NEW: Team BIS Cell
                const teamBISCell = row.insertCell();
                teamBISCell.innerText = teamBIS;
                teamBISCell.style.textAlign = 'center';

                // RENAMED: Finance Approved Funding Cell
                row.insertCell().innerText = fundedHC;

                // RENAMED: Effective BIS Cell
                const effectiveBISCell = row.insertCell();
                effectiveBISCell.innerText = effectiveBIS;
                effectiveBISCell.title = `Team BIS: ${teamBIS}, Away-Team BIS: ${awayTeamBIS}`; // Tooltip explaining breakdown
                effectiveBISCell.style.textAlign = 'center'; // Center align numerical columns
                if (awayTeamBIS > 0) effectiveBISCell.style.fontWeight = 'bold'; // Highlight if away team contributes

                // RENAMED & RECALCULATED: BIS Hiring Gap Cell
                let hiringGapCell = row.insertCell();
                hiringGapCell.innerText = hiringGap;
                hiringGapCell.style.color = hiringGap < 0 ? 'blue' : (hiringGap > 0 ? 'orange' : 'green'); // Blue if overstaffed, Orange if hiring needed
                hiringGapCell.style.textAlign = 'center';
                 if (hiringGap < 0) {
                    hiringGapCell.title = `Team BIS (${teamBIS}) exceeds Funded HC (${fundedHC}) by ${Math.abs(hiringGap)}`;
                    hiringGapCell.style.fontWeight = 'bold';
                 } else if (hiringGap > 0) {
                    hiringGapCell.title = `Need to hire ${hiringGap} to reach Funded HC (${fundedHC})`;
                 } else {
                     hiringGapCell.title = `Team BIS matches Funded HC`;
                 }

                // Accumulate Totals
                totalFundedHC += fundedHC;
                totalTeamBIS += teamBIS; // Accumulate actual team BIS
                totalEffectiveBIS += effectiveBIS; // Accumulate effective BIS
                // *** END NEW/REVISED Capacity Cells ***

                // Engineers (Level) Cell
                let engineersCell = row.insertCell(); /* ... no changes in content generation ... */
                if (team.engineers && Array.isArray(team.engineers) && team.engineers.length > 0) {
                     engineersCell.innerHTML = team.engineers
                        .map(eng => {
                             if (typeof eng !== 'object' || eng === null) return 'Invalid Eng Data';
                             const name = eng.name || 'Unnamed';
                             const level = eng.level ?? '?';
                             return name + ' (L' + level + ')';
                        })
                        .join('<br>');
                 } else {
                    engineersCell.innerText = 'None';
                 }
                engineersCell.style.whiteSpace = 'pre-line';

                // NEW: Away-Team Members Cell
                let awayTeamCell = row.insertCell();
                if (team.awayTeamMembers && Array.isArray(team.awayTeamMembers) && team.awayTeamMembers.length > 0) {
                    awayTeamCell.innerHTML = team.awayTeamMembers
                        .map(awayEng => {
                            if (typeof awayEng !== 'object' || awayEng === null) return 'Invalid Away Data';
                            const name = awayEng.name || 'Unnamed';
                            const level = awayEng.level ?? '?';
                            const source = awayEng.sourceTeam || 'Unknown Source';
                            // Format: Name (Level) - SourceTeam
                            return `${name} (L${level}) - ${source}`;
                        })
                        .join('<br>');
                } else {
                    awayTeamCell.innerText = 'None';
                }
                awayTeamCell.style.whiteSpace = 'pre-line';
                awayTeamCell.style.fontSize = '0.9em'; // Slightly smaller text
                awayTeamCell.style.color = '#333';

                // Services Owned Cell
                let servicesOwnedCell = row.insertCell(); /* ... no changes ... */
                servicesOwnedCell.innerText = team.teamId && teamServicesMap[team.teamId] ? teamServicesMap[team.teamId].join(', ') : 'None';

            }); // End teams.forEach
        } // End sdmId loop
    } // End srMgrId loop
    // --- End Populate Body ---

    // --- 8. Populate Footer Totals ---
    const totalHiringGap = totalFundedHC - totalTeamBIS; // Calculate total hiring gap

    // Ensure the tfoot row exists and has the correct number of cells
    let footerRow = tableFoot.querySelector('tr:first-of-type'); // Get the main totals row
    let footerCells = footerRow.querySelectorAll('td, th');

    // Adjust colspan for the initial text cell + add placeholders for new total cells
    const expectedFooterCells = headersConfig.length; // Number of columns
    const labelColspan = 5; // SrMgr, SDM, Identity, Name, PMT
    if (footerCells.length > 0) {
        footerCells[0].colSpan = labelColspan; // First cell spans the label columns
        // Ensure enough cells exist, add if needed
        while(footerCells.length < expectedFooterCells - labelColspan + 1) { // +1 because first cell replaces multiple
            footerRow.insertCell();
            footerCells = footerRow.querySelectorAll('td, th'); // Refresh node list
        }
    } else {
         // Handle case where footer row might be missing (though unlikely with current HTML)
         console.error("Footer row not found or empty!");
         return;
    }

    // Update footer cells by expected position (adjust indices carefully)
    // Indices are relative to the start of the TD elements in the footer row
    const footerDataCells = Array.from(footerCells).slice(1); // Skip the initial colspan cell

    if (footerDataCells.length >= 7) { // Check we have enough cells for all totals
        footerDataCells[0].id = 'totalTeamBIS'; // NEW: Cell for Total Team BIS
        footerDataCells[0].textContent = totalTeamBIS;
        footerDataCells[0].style.fontWeight = 'bold';
        footerDataCells[0].style.textAlign = 'center';


        footerDataCells[1].id = 'totalFundedHC'; // Cell for Total Funded HC
        footerDataCells[1].textContent = totalFundedHC;
        footerDataCells[1].style.fontWeight = 'bold';

        footerDataCells[2].id = 'totalEffectiveBIS'; // Cell for Total Effective BIS
        footerDataCells[2].textContent = totalEffectiveBIS;
        footerDataCells[2].style.fontWeight = 'bold';
        footerDataCells[2].style.textAlign = 'center';


        footerDataCells[3].id = 'totalHiringGap'; // Cell for Total Hiring Gap
        footerDataCells[3].textContent = totalHiringGap;
        footerDataCells[3].style.fontWeight = 'bold';
        footerDataCells[3].style.textAlign = 'center';
        footerDataCells[3].style.color = totalHiringGap < 0 ? 'blue' : (totalHiringGap > 0 ? 'orange' : 'green');

        // Add empty cells for the engineer/away-team/service columns in the footer
         footerDataCells[4].textContent = ''; // Engineers
         footerDataCells[5].textContent = ''; // Away-Team
         footerDataCells[6].textContent = ''; // Services
    } else {
        console.error("Footer row does not have enough cells for totals!");
    }


    // Update Gap Note
    let gapNoteText = `Overall BIS Hiring Gap: ${totalHiringGap} (Finance Approved Funding vs Team BIS). `;
    if (totalHiringGap > 0) {
        gapNoteText += `Need to hire ${totalHiringGap}.`;
    } else if (totalHiringGap < 0) {
        gapNoteText += `Over hiring target by ${Math.abs(totalHiringGap)}.`;
    } else {
        gapNoteText += `At hiring target.`;
    }
     // Add note about effective capacity if away teams exist
     if (totalEffectiveBIS > totalTeamBIS) {
        gapNoteText += ` Effective capacity boosted to ${totalEffectiveBIS} by away-teams.`
     }

    document.getElementById('gapNote').innerText = gapNoteText;
    // --- End Footer ---

    // --- 9. Populate Level Key (Keep as before) ---
    const levelKeyElement = document.getElementById('levelKey');
    if (levelKeyElement) {
        levelKeyElement.innerHTML = `Level Key: L1=SDE 1 (Junior), L2=SDE 2 (Intermediate), L3=SDE 3 (Senior), L4=Principal SDE, L5=Senior Principal SDE`;
    }
    // --- End Level Key ---
    console.log("Finished generating Enhanced Team Table."); // Log function end
}

/** Enter Edit Mode **/

function enterEditMode(creatingNewSystem) {
     if (creatingNewSystem === true) {
          currentMode = Modes.CREATING;
     }
      else {
        currentMode = Modes.EDITNG;
     }
     
    // Show the system edit form
    showSystemEditForm(currentSystemData);
}

/** Show System Edit Form **/

function showSystemEditForm(systemData) {
    // Show the form
    document.getElementById('systemEditForm').style.display = 'block';
    // Hide other sections
    document.getElementById('visualization').style.display = 'none';
    document.getElementById('teamVisualization').style.display = 'none';
    document.getElementById('teamBreakdown').style.display = 'none';
    document.querySelector('.edit-menu').style.display = 'none';
    document.querySelector('.menu').style.display = 'none'; 
    document.getElementById('serviceRelationshipsVisualization').style.display = 'none';
    document.getElementById('dependencyVisualization').style.display = 'none';    
    document.getElementById('serviceDependenciesTable').style.display = 'none';    
    document.getElementById('organogramView').style.display = 'none';
    document.getElementById('engineerTableView').style.display = 'none';

    // Populate system name and description
    document.getElementById('systemNameInput').value = systemData.systemName || '';
    console.log("*** 0 document.getElementById('systemNameInput').value",document.getElementById('systemNameInput').value);
    
    document.getElementById('systemDescriptionInput').value = systemData.systemDescription || '';

    // Populate services
    displayServicesForEditing(systemData.services || [], 'editServicesManagement');

    // Populate teams
    displayTeamsForEditing(systemData.teams || []);
    
}

/** Helper to create Label + Input pairs (Revised for BIS display update) */
function createInputLabelPair(id, labelText, value, type = 'text', index, field, isReadOnly = false, tooltip = null) {
    let div = document.createElement('div');
    div.style.marginBottom = '10px';
    let label = document.createElement('label');
    label.htmlFor = id;
    label.innerText = labelText;
    label.style.display = 'block';
    if (tooltip) {
        label.title = tooltip; // Add tooltip to label if provided
    }

    let inputElement; // Could be input, textarea, or span

    if (isReadOnly) {
        inputElement = document.createElement('span');
        inputElement.id = id;
        inputElement.textContent = value;
        inputElement.style.fontWeight = 'bold'; // Make read-only values stand out
        if (tooltip) {
            inputElement.title = tooltip; // Add tooltip to value span as well
        }
    } else if (type === 'textarea') {
        inputElement = document.createElement('textarea');
        inputElement.rows = 2;
        inputElement.style.width = '90%';
        inputElement.id = id;
        inputElement.value = value;
        inputElement.setAttribute('data-team-index', index);
        inputElement.setAttribute('data-field', field);
        inputElement.addEventListener('change', handleTeamInputChange); // Use generic handler
    } else { // Default to input
        inputElement = document.createElement('input');
        inputElement.type = type;
        if (type === 'number') {
            inputElement.min = 0;
             // Add step=1 for integer headcount fields if needed
             if (field === 'fundedHeadcount') inputElement.step = 1;
        }
        inputElement.style.width = '90%';
        inputElement.id = id;
        inputElement.value = value;
        inputElement.setAttribute('data-team-index', index);
        inputElement.setAttribute('data-field', field);
        inputElement.addEventListener('change', handleTeamInputChange); // Use generic handler
    }

    div.appendChild(label);
    div.appendChild(inputElement);
    return div;
}

// Add a generic handler for team input changes (if not already present)
// This replaces the specific listeners previously inside createInputLabelPair
function handleTeamInputChange(event) {
    const input = event.target;
    const teamIndex = parseInt(input.getAttribute('data-team-index'));
    const fieldName = input.getAttribute('data-field');
    let value = input.value;

    if (input.type === 'number') {
        value = parseInt(value);
        if (isNaN(value)) value = 0;
    }

    if (currentSystemData && currentSystemData.teams && teamIndex >= 0 && teamIndex < currentSystemData.teams.length) {
        currentSystemData.teams[teamIndex][fieldName] = value;
        console.log(`Updated team[${teamIndex}].${fieldName} to:`, value);

        // If team identity or name changed, update the header
        if (fieldName === 'teamIdentity' || fieldName === 'teamName') {
            const teamDiv = input.closest('.team-edit');
            const header = teamDiv?.querySelector('h4');
            if (header) {
                 const indicator = header.querySelector('span');
                 const teamData = currentSystemData.teams[teamIndex];
                 header.textContent = `Team: ${teamData.teamIdentity || teamData.teamName || 'New Team'}`;
                 if(indicator) header.insertBefore(indicator, header.firstChild);
            }
        }
    } else {
        console.warn(`Could not update team data for index ${teamIndex}, field ${fieldName}`);
    }
}


/** Helper to display Senior Manager Assignment UI within SDM section */
function displaySeniorManagerAssignment(sdmSectionContainer, teamIndex, currentSdmId) {
    // Find the specific container using teamIndex (or could use sdmId if unique)
    let srMgrContainer = sdmSectionContainer.querySelector(`#srMgrAssignmentContainer_${teamIndex}`);
    if (!srMgrContainer) {
         console.error("Could not find Sr Mgr container for team index", teamIndex);
         return;
     }
    srMgrContainer.innerHTML = ''; // Clear previous content
    srMgrContainer.style.paddingLeft = '20px'; // Indent slightly

    // Ensure global data is available
    const allSdms = currentSystemData.sdms || [];
    const allSeniorManagers = currentSystemData.seniorManagers || [];

    const currentSdm = allSdms.find(sdm => sdm && sdm.sdmId === currentSdmId);

    if (!currentSdm) {
        srMgrContainer.innerText = 'Assign an SDM to manage Senior Manager assignment.';
        return; // No SDM assigned, nothing to show
    }

    let title = document.createElement('h6');
    title.innerText = `Senior Manager for SDM: ${currentSdm.sdmName}`;
    srMgrContainer.appendChild(title);

    const currentSrMgr = allSeniorManagers.find(sr => sr && sr.seniorManagerId === currentSdm.seniorManagerId);

    const srMgrDualList = createDualListContainer( // Call global helper
        teamIndex, // Pass teamIndex for context if needed by callbacks
        'Current Sr. Mgr:', 'Available Sr. Mgrs:',
        currentSrMgr ? [{ value: currentSrMgr.seniorManagerId, text: currentSrMgr.seniorManagerName }] : [],
        allSeniorManagers.filter(sr => sr && sr.seniorManagerId !== currentSdm.seniorManagerId)
                         .map(sr => ({ value: sr.seniorManagerId, text: sr.seniorManagerName })), // Map to value/text
        `currentSrMgr_${currentSdmId}`, // Field names specific to this SDM
        `availableSrMgrs_${currentSdmId}`,
        (movedSrMgrId, direction) => { // Callback on Sr Mgr move
            // Find the SDM in the main data again to modify it
            const sdmToUpdate = currentSystemData.sdms.find(s => s.sdmId === currentSdmId);
            if (sdmToUpdate) {
                 sdmToUpdate.seniorManagerId = (direction === 'add') ? movedSrMgrId : null;
                 console.log(`Set Sr Mgr for SDM ${currentSdmId} to ${sdmToUpdate.seniorManagerId}`);
             } else {
                 console.warn("Could not find SDM to update Sr Mgr for:", currentSdmId);
             }
        },
        false, // singleSelectLeft = true for current Sr Mgr (set multiSelectLeft to false)
        true, // Allow adding new Sr Mgrs
        'Enter New Sr. Manager Name',
        (newSrMgrName) => { // Callback for adding new Sr Mgr
            if (!newSrMgrName || newSrMgrName.trim() === '') return null;
            newSrMgrName = newSrMgrName.trim();
            let existingSrMgr = (currentSystemData.seniorManagers || []).find(s => s && s.seniorManagerName.toLowerCase() === newSrMgrName.toLowerCase()); // check s
            if (existingSrMgr) {
                alert(`Senior Manager "${newSrMgrName}" already exists.`);
                return null;
            }
            const newSrMgrId = 'srMgr-' + Date.now();
            const newSrMgr = { seniorManagerId: newSrMgrId, seniorManagerName: newSrMgrName };
            if (!currentSystemData.seniorManagers) currentSystemData.seniorManagers = []; // Ensure array exists
            currentSystemData.seniorManagers.push(newSrMgr); // Add to main data
            // We might need to update the local 'allSeniorManagers' if it's used elsewhere before a full refresh
            console.log("Added new Senior Manager:", newSrMgr);
            return { value: newSrMgrId, text: newSrMgrName }; // Return for UI update
        }
    );
    srMgrContainer.appendChild(srMgrDualList);
 }
// -----------------------------------

/** Helper to create Dual List Selectors */
function createDualListContainer(contextIndex, leftLabel, rightLabel, currentOptions, availableOptions, leftField, rightField, moveCallback, multiSelectLeft = true, allowAddNew = false, addNewPlaceholder = '', addNewCallback = null) {
    let container = document.createElement('div');
    container.className = 'dual-list-container';
    container.style.display = 'flex';
    container.style.alignItems = 'center';
    container.style.marginBottom = '10px';

    // Left List (Current)
    let leftDiv = document.createElement('div');
    leftDiv.style.flex = '1'; leftDiv.style.marginRight = '5px';
    let currentLabel = document.createElement('label');
    currentLabel.innerText = leftLabel; currentLabel.style.display = 'block';
    let currentSelect = document.createElement('select');
    currentSelect.multiple = multiSelectLeft; currentSelect.size = 5; currentSelect.style.width = '100%';
    currentSelect.setAttribute('data-list-context-index', contextIndex);
    currentSelect.setAttribute('data-field', leftField);
    (currentOptions || []).forEach(opt => currentSelect.appendChild(new Option(opt.text, opt.value)));
    leftDiv.appendChild(currentLabel); leftDiv.appendChild(currentSelect);

    // Buttons
    let buttonsDiv = document.createElement('div');
    buttonsDiv.style.display = 'flex'; buttonsDiv.style.flexDirection = 'column'; buttonsDiv.style.alignItems = 'center'; buttonsDiv.style.margin = '0 5px';
    let removeBtn = document.createElement('button'); removeBtn.type = 'button'; removeBtn.innerHTML = '&gt;'; removeBtn.title = 'Remove selected item(s)'; removeBtn.style.marginBottom = '5px';
    let addBtn = document.createElement('button'); addBtn.type = 'button'; addBtn.innerHTML = '&lt;'; addBtn.title = 'Add selected item(s)';

    // Right List (Available)
    let rightDiv = document.createElement('div');
    rightDiv.style.flex = '1'; rightDiv.style.marginLeft = '5px';
    let availableLabel = document.createElement('label');
    availableLabel.innerText = rightLabel; availableLabel.style.display = 'block';
    let availableSelect = document.createElement('select');
    availableSelect.multiple = true; availableSelect.size = 5; availableSelect.style.width = '100%';
    availableSelect.setAttribute('data-list-context-index', contextIndex);
    availableSelect.setAttribute('data-field', rightField);
    (availableOptions || []).forEach(opt => availableSelect.appendChild(new Option(opt.text, opt.value)));
    rightDiv.appendChild(availableLabel); rightDiv.appendChild(availableSelect);

    // Add New Item Input/Button
    let addNewContainer = null;
    if (allowAddNew && addNewCallback) {
        addNewContainer = document.createElement('div'); addNewContainer.style.marginTop = '5px'; addNewContainer.style.display = 'flex';
        let addNewInput = document.createElement('input'); addNewInput.type = 'text'; addNewInput.placeholder = addNewPlaceholder; addNewInput.style.flexGrow = '1'; addNewInput.style.marginRight = '5px';
        let addNewBtn = document.createElement('button'); addNewBtn.type = 'button'; addNewBtn.innerText = 'Add';
        addNewBtn.onclick = (e) => {
            e.preventDefault();
            const newItemData = addNewCallback(addNewInput.value);
            if (newItemData && newItemData.value && newItemData.text) {
                 const exists = Array.from(availableSelect.options).some(opt => opt.value === newItemData.value) || Array.from(currentSelect.options).some(opt => opt.value === newItemData.value);
                 if (!exists) { availableSelect.appendChild(new Option(newItemData.text, newItemData.value)); }
                 else if (!newItemData.preventAdd) { console.warn("Item already exists in lists:", newItemData.text); }
                 addNewInput.value = '';
             } else if (newItemData && newItemData.preventAdd) { addNewInput.value = ''; }
        };
        addNewContainer.appendChild(addNewInput); addNewContainer.appendChild(addNewBtn);
        rightDiv.appendChild(addNewContainer);
    }

    // Button Actions
    removeBtn.onclick = (e) => {
         e.preventDefault();
        Array.from(currentSelect.selectedOptions).forEach(option => { availableSelect.appendChild(option); moveCallback(option.value, 'remove', contextIndex); });
    };
    addBtn.onclick = (e) => {
         e.preventDefault();
        Array.from(availableSelect.selectedOptions).forEach(option => {
             if (!multiSelectLeft) {
                 while (currentSelect.options.length > 0) { let existingOption = currentSelect.options[0]; availableSelect.appendChild(existingOption); moveCallback(existingOption.value, 'remove', contextIndex); }
             }
             currentSelect.appendChild(option); moveCallback(option.value, 'add', contextIndex);
        });
    };

    buttonsDiv.appendChild(addBtn); buttonsDiv.appendChild(removeBtn);
    container.appendChild(leftDiv); container.appendChild(buttonsDiv); container.appendChild(rightDiv);
    return container;
} // --- End createDualListContainer ---

/** Display Teams for Editing **/
/** REVISED Display Teams for Editing - Adds Away-Team Management Section */
function displayTeamsForEditing(teams, expandedIndex = -1) {
    const teamsDiv = document.getElementById('teamsManagement');
    teamsDiv.innerHTML = ''; // Clear existing content

    // Pre-fetch global lists (keep as before)
    const allServices = (currentSystemData.services || []).map(service => ({ value: service.serviceName, text: service.serviceName, owningTeamId: service.owningTeamId || null }));
    const allSdms = currentSystemData.sdms || [];
    const allPmts = currentSystemData.pmts || [];
    const allSeniorManagers = currentSystemData.seniorManagers || [];
    // Note: Away-team list is per-team, not global selection here

    (teams || []).forEach((team, index) => {
        if (!team) { console.warn("Skipping invalid team object at index", index); return; }

        let teamDiv = document.createElement('div');
        teamDiv.className = 'team-edit';
        teamDiv.setAttribute('data-team-render-index', index); // Keep render index if needed

        // --- Header (Collapsible) - No Change ---
        let teamHeader = document.createElement('h4');
        teamHeader.style.cursor = 'pointer';
        let indicator = document.createElement('span');
        indicator.innerText = (index === expandedIndex) ? '- ' : '+ ';
        teamHeader.appendChild(indicator);
        teamHeader.appendChild(document.createTextNode(`Team: ${team.teamIdentity || team.teamName || 'New Team'}`));

        let teamDetails = document.createElement('div');
        teamDetails.className = 'team-details';
        teamDetails.style.display = (index === expandedIndex) ? 'block' : 'none';

        // Toggle Functionality (Keep as before, but refresh away-team list too)
        teamHeader.onclick = () => {
            const content = teamDetails;
            const isCurrentlyCollapsed = content.style.display === 'none' || content.style.display === '';
            content.style.display = isCurrentlyCollapsed ? 'block' : 'none';
            indicator.innerText = isCurrentlyCollapsed ? '- ' : '+ ';
            if (isCurrentlyCollapsed) {
                 // Refresh Available Services
                 refreshAvailableListsInDualList(content, 'currentServices', 'availableServices',
                    (currentSystemData.services || []).map(s => ({ value: s.serviceName, text: s.serviceName, owningTeamId: s.owningTeamId || null })),
                    team.teamId
                 );
                 // Refresh Sr Mgr display
                 displaySeniorManagerAssignment(content.querySelector(`#sdmSection_${index}`), index, team.sdmId);
                 // Refresh Away-Team List Display (in case data changed elsewhere)
                 displayAwayTeamMembers(team.awayTeamMembers || [], index);
                 // Refresh Effective BIS display
                 updateEffectiveBISDisplay(index);
            }
        };
        // --- End Header ---

        // --- Basic Info Inputs (Using revised helper) ---
        teamDetails.appendChild(createInputLabelPair(`teamIdentity_${index}`, 'Team Identity:', team.teamIdentity || '', 'text', index, 'teamIdentity'));
        teamDetails.appendChild(createInputLabelPair(`teamName_${index}`, 'Team Name:', team.teamName || '', 'text', index, 'teamName'));
        teamDetails.appendChild(createInputLabelPair(`teamDescription_${index}`, 'Team Description:', team.teamDescription || '', 'textarea', index, 'teamDescription'));
        // --- End Basic Info ---

        // --- Services Owned Dual List (Keep as before) ---
        const currentServices = allServices.filter(s => s.owningTeamId === team.teamId);
        const availableServices = allServices.filter(s => s.owningTeamId !== team.teamId);
        const servicesContainer = createDualListContainer(
             index, 'Services Owned:', 'Available Services:',
             currentServices, availableServices,
             'currentServices', 'availableServices',
             (movedOptionValue, direction, contextIndex) => { /* ... service move callback (no change) ... */
                const service = currentSystemData.services.find(s => s.serviceName === movedOptionValue);
                const targetTeam = currentSystemData.teams[contextIndex];
                if (service && targetTeam) {
                    service.owningTeamId = (direction === 'add') ? targetTeam.teamId : null;
                }
             }
        );
        teamDetails.appendChild(servicesContainer);
        teamDetails.appendChild(document.createElement('br'));
        // --- End Services ---

        // --- SDM Assignment & Senior Manager Assignment (Keep as before) ---
        const sdmSection = document.createElement('div'); /* ... sdm section setup (no change) ... */
        sdmSection.id = `sdmSection_${index}`; sdmSection.style.border = '1px dashed #ccc'; sdmSection.style.padding = '10px'; sdmSection.style.marginBottom = '10px';
        let sdmSectionTitle = document.createElement('h5'); sdmSectionTitle.innerText = 'SDM Assignment'; sdmSection.appendChild(sdmSectionTitle);
        const currentSdm = allSdms.find(sdm => sdm && sdm.sdmId === team.sdmId);
        const sdmContainer = createDualListContainer( /* ... sdm dual list setup (no change) ... */
            index, 'Current SDM:', 'Available SDMs:',
            currentSdm ? [{ value: currentSdm.sdmId, text: currentSdm.sdmName }] : [],
            allSdms.filter(sdm => sdm && sdm.sdmId !== team.sdmId).map(sdm => ({ value: sdm.sdmId, text: sdm.sdmName })),
            'currentSdm', 'availableSdms',
            (movedOptionValue, direction, contextIndex) => { // SDM Move Callback
                const targetTeam = currentSystemData.teams[contextIndex];
                if(targetTeam){
                    const newSdmId = (direction === 'add') ? movedOptionValue : null;
                    targetTeam.sdmId = newSdmId;
                    // Refresh Sr. Mgr section using the specific sdmSection container
                    displaySeniorManagerAssignment(sdmSection, contextIndex, newSdmId);
                }
            },
            false, true, 'Enter New SDM Name', // Single select left, allow add new
            (newSdmName) => { /* ... add new sdm callback (no change) ... */
                if (!newSdmName || newSdmName.trim() === '') return null; newSdmName = newSdmName.trim();
                let existingSdm = allSdms.find(s => s && s.sdmName.toLowerCase() === newSdmName.toLowerCase());
                if (existingSdm) { alert(`SDM "${newSdmName}" already exists.`); return null; }
                const newSdmId = 'sdm-' + Date.now(); const newSdm = { sdmId: newSdmId, sdmName: newSdmName, seniorManagerId: null };
                currentSystemData.sdms.push(newSdm); allSdms.push(newSdm); // Update local cache too
                console.log("Added new SDM:", newSdm); return { value: newSdmId, text: newSdmName };
             }
        );
        sdmSection.appendChild(sdmContainer);
        let srMgrAssignmentContainer = document.createElement('div'); srMgrAssignmentContainer.id = `srMgrAssignmentContainer_${index}`; srMgrAssignmentContainer.style.marginTop = '10px';
        sdmSection.appendChild(srMgrAssignmentContainer);
        teamDetails.appendChild(sdmSection); teamDetails.appendChild(document.createElement('br'));
        // Initial population of Sr Mgr (will also happen on expand)
        if (teamDetails.style.display === 'block') {
            displaySeniorManagerAssignment(sdmSection, index, team.sdmId);
        }
        // --- End SDM/SrMgr ---

        // --- PMT Assignment (Keep as before) ---
        const currentPmt = allPmts.find(pmt => pmt && pmt.pmtId === team.pmtId);
        const pmtContainer = createDualListContainer(/* ... pmt dual list setup (no change) ... */
            index, 'Current PMT:', 'Available PMTs:',
            currentPmt ? [{ value: currentPmt.pmtId, text: currentPmt.pmtName }] : [],
            allPmts.filter(pmt => pmt && pmt.pmtId !== team.pmtId).map(pmt => ({ value: pmt.pmtId, text: pmt.pmtName })),
            'currentPmt', 'availablePmts',
            (movedOptionValue, direction, contextIndex) => { // PMT Move Callback
                const targetTeam = currentSystemData.teams[contextIndex];
                if(targetTeam) targetTeam.pmtId = (direction === 'add') ? movedOptionValue : null;
            },
            false, true, 'Enter New PMT Name', // Single select left, allow add new
             (newPmtName) => { /* ... add new pmt callback (no change) ... */
                 if (!newPmtName || newPmtName.trim() === '') return null; newPmtName = newPmtName.trim();
                 let existingPmt = allPmts.find(p => p && p.pmtName.toLowerCase() === newPmtName.toLowerCase());
                 if (existingPmt) { alert(`PMT "${newPmtName}" already exists.`); return null; }
                 const newPmtId = 'pmt-' + Date.now(); const newPmt = { pmtId: newPmtId, pmtName: newPmtName };
                 currentSystemData.pmts.push(newPmt); allPmts.push(newPmt); // Update local cache
                 console.log("Added new PMT:", newPmt); return { value: newPmtId, text: newPmtName };
              }
        );
        teamDetails.appendChild(pmtContainer); teamDetails.appendChild(document.createElement('br'));
        // --- End PMT ---

        // --- Headcount Section ---
        teamDetails.appendChild(createInputLabelPair(`fundedHeadcount_${index}`, 'Finance Approved Funding:', team.fundedHeadcount ?? 0, 'number', index, 'fundedHeadcount'));

        // ** UPDATED: Display Effective BIS (Read Only) **
        const teamBIS = team.engineers?.length ?? 0;
        const awayTeamBIS = team.awayTeamMembers?.length ?? 0;
        const effectiveBIS = teamBIS + awayTeamBIS;
        const bisTooltip = `Team BIS: ${teamBIS}, Away-Team BIS: ${awayTeamBIS}`;
        teamDetails.appendChild(
            createInputLabelPair(`effectiveBIS_${index}`, 'Effective BIS:', effectiveBIS, 'text', index, 'effectiveBIS', true, bisTooltip) // isReadOnly = true
        );
        teamDetails.appendChild(document.createElement('br'));
        // --- End Headcount ---

        // --- Engineer Assignment (Keep as before) ---
        let engineersSectionTitle = document.createElement('h5'); /* ... engineer section setup (no change) ... */
        engineersSectionTitle.innerText = 'Team Engineer Assignment'; engineersSectionTitle.style.marginTop = '15px'; teamDetails.appendChild(engineersSectionTitle);
        const currentEngineerOptions = (team.engineers || []).map(eng => ({ value: eng.name, text: `${eng.name} (L${eng.level ?? '?'})` })); // Show level in list
        // Available needs to be calculated carefully now
        let allEngineerNamesMap = new Map();
        (currentSystemData.teams || []).forEach(t => { (t.engineers || []).forEach(eng => { if (eng?.name) allEngineerNamesMap.set(eng.name, t.teamId); }); });
        const availableEngineerOptions = Array.from(allEngineerNamesMap.keys()).filter(name => allEngineerNamesMap.get(name) !== team.teamId).map(name => ({ value: name, text: name }));

        const engineerContainer = createDualListContainer( /* ... engineer dual list setup (no change in basic structure) ... */
            index, 'Current Engineers:', 'Available Engineers:', currentEngineerOptions, availableEngineerOptions,
            'currentEngineers', 'availableEngineers',
            (movedEngineerName, direction, contextIndex) => { // Engineer Move Callback
                 const currentTeam = currentSystemData.teams[contextIndex]; if (!currentTeam) return;
                 if (direction === 'add') { /* ... remove from other teams, add to current (no change) ... */
                    let engineerLevel = 1; // Default level
                    // Try find the engineer on another team to get their level
                    currentSystemData.teams.forEach(otherTeam => {
                         const existingEng = (otherTeam.engineers || []).find(eng => eng.name === movedEngineerName);
                         if (existingEng) engineerLevel = existingEng.level ?? 1;
                    });

                     // Remove from *all* other teams first
                     currentSystemData.teams.forEach((otherTeam, otherIdx) => {
                         if (otherTeam.teamId !== currentTeam.teamId && otherTeam.engineers) {
                             const initialLength = otherTeam.engineers.length;
                             otherTeam.engineers = otherTeam.engineers.filter(eng => eng.name !== movedEngineerName);
                             if (otherTeam.engineers.length < initialLength) {
                                 updateEffectiveBISDisplay(otherIdx); // Update other team's displayed BIS
                             }
                         }
                     });
                    // Add engineer to current team if not already present
                    if (!currentTeam.engineers) currentTeam.engineers = [];
                    if (!currentTeam.engineers.some(eng => eng.name === movedEngineerName)) {
                        currentTeam.engineers.push({ name: movedEngineerName, level: engineerLevel }); // Use found/default level
                        console.log(`Added ${movedEngineerName} to team ${currentTeam.teamId}`);
                    }
                 } else { // Remove from current team
                     if (currentTeam.engineers) {
                        currentTeam.engineers = currentTeam.engineers.filter(eng => eng.name !== movedEngineerName);
                        console.log(`Removed ${movedEngineerName} from team ${currentTeam.teamId}`);
                     }
                 }
                 // Update Effective BIS display for the current team
                 updateEffectiveBISDisplay(contextIndex);
                 // Refresh available lists for *all* team editors after moving an engineer
                 refreshAllAvailableEngineerLists();

            },
            true, false, '', null // multiSelectLeft = true, allowAddNew = false for engineers
        );
        engineerContainer.id = `engineersList_${index}`; teamDetails.appendChild(engineerContainer);
        // --- End Engineers ---

        // *** NEW: Away-Team Management Section ***
        let awayTeamSection = document.createElement('div');
        awayTeamSection.style.marginTop = '15px';
        awayTeamSection.style.padding = '10px';
        awayTeamSection.style.border = '1px solid #add8e6'; // Light blue border
        awayTeamSection.style.backgroundColor = '#f0f8ff'; // Alice blue background

        let awayTeamTitle = document.createElement('h5');
        awayTeamTitle.innerText = 'Away-Team Members';
        awayTeamSection.appendChild(awayTeamTitle);

        // Container to display current away-team members
        let awayMemberListDiv = document.createElement('div');
        awayMemberListDiv.id = `awayMemberList_${index}`;
        awayMemberListDiv.style.marginBottom = '10px';
        awayMemberListDiv.style.maxHeight = '150px'; // Prevent excessive height
        awayMemberListDiv.style.overflowY = 'auto'; // Add scroll if needed
        awayMemberListDiv.style.border = '1px solid #ccc';
        awayMemberListDiv.style.padding = '5px';
        awayTeamSection.appendChild(awayMemberListDiv);
        // Initial population of the list happens later in displayAwayTeamMembers

        // Form to add new away-team members
        let addAwayForm = document.createElement('div');
        addAwayForm.style.marginTop = '10px';
        addAwayForm.innerHTML = `
            <label for="newAwayName_${index}" style="margin-right: 5px;">Name:</label>
            <input type="text" id="newAwayName_${index}" placeholder="Away Member Name" style="width: 150px; margin-right: 10px;">
            <label for="newAwayLevel_${index}" style="margin-right: 5px;">Level:</label>
            <input type="number" id="newAwayLevel_${index}" min="1" max="5" placeholder="1-5" style="width: 50px; margin-right: 10px;">
            <label for="newAwaySource_${index}" style="margin-right: 5px;">Source:</label>
            <input type="text" id="newAwaySource_${index}" placeholder="Source Team/Org" style="width: 150px; margin-right: 10px;">
            <button type="button" id="addAwayBtn_${index}">Add Away Member</button>
        `;
        awayTeamSection.appendChild(addAwayForm);

        teamDetails.appendChild(awayTeamSection);
        teamDetails.appendChild(document.createElement('br'));

        // Attach event listener to the 'Add Away Member' button
        // Need to do this *after* the button is added to the DOM
         setTimeout(() => { // Use setTimeout to ensure element exists
            const addBtn = document.getElementById(`addAwayBtn_${index}`);
            if (addBtn) {
                 addBtn.onclick = () => handleAddAwayTeamMember(index);
             } else {
                 console.warn(`Could not find Add Away button for team index ${index}`);
             }
             // Initial population of the away team list display
             displayAwayTeamMembers(team.awayTeamMembers || [], index);
         }, 0);
        // *** END Away-Team Section ***


        // --- Action Buttons (Save/Delete Team) - No Change ---
        let actionButtonsDiv = document.createElement('div');
        actionButtonsDiv.style.marginTop = '15px';
        let saveButton = document.createElement('button'); saveButton.type = 'button'; saveButton.innerText = 'Save Team Changes'; saveButton.onclick = () => saveTeamChanges(index); actionButtonsDiv.appendChild(saveButton);
        let deleteButton = document.createElement('button'); deleteButton.type = 'button'; deleteButton.innerText = 'Delete Team'; deleteButton.style.marginLeft = '10px'; deleteButton.style.color = 'red'; deleteButton.onclick = () => deleteTeam(index); actionButtonsDiv.appendChild(deleteButton);
        teamDetails.appendChild(actionButtonsDiv);
        // --- End Actions ---

        teamDiv.appendChild(teamHeader);
        teamDiv.appendChild(teamDetails);
        teamsDiv.appendChild(teamDiv);
    }); // End teams.forEach
} // --- End displayTeamsForEditing ---


// *** NEW HELPER FUNCTIONS FOR AWAY TEAM MANAGEMENT ***

/** Displays the list of current away team members for a specific team */
function displayAwayTeamMembers(awayMembers, teamIndex) {
    const listDiv = document.getElementById(`awayMemberList_${teamIndex}`);
    if (!listDiv) {
        console.error(`Could not find away member list div for team index ${teamIndex}`);
        return;
    }
    listDiv.innerHTML = ''; // Clear current list

    if (!awayMembers || awayMembers.length === 0) {
        listDiv.innerHTML = '<em style="color: #666;">No away-team members assigned.</em>';
        return;
    }

    awayMembers.forEach((member, memberIndex) => {
        const itemDiv = document.createElement('div');
        itemDiv.style.display = 'flex';
        itemDiv.style.justifyContent = 'space-between';
        itemDiv.style.alignItems = 'center';
        itemDiv.style.marginBottom = '3px';
        itemDiv.style.padding = '2px';
        itemDiv.style.borderBottom = '1px dashed #eee';

        const memberInfo = document.createElement('span');
        memberInfo.textContent = `${member.name || 'Unnamed'} (L${member.level ?? '?'}) - ${member.sourceTeam || 'Unknown Source'}`;
        itemDiv.appendChild(memberInfo);

        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove';
        removeBtn.style.fontSize = '0.8em';
        removeBtn.style.padding = '1px 4px';
        removeBtn.style.cursor = 'pointer';
        removeBtn.onclick = () => handleRemoveAwayTeamMember(teamIndex, memberIndex);
        itemDiv.appendChild(removeBtn);

        listDiv.appendChild(itemDiv);
    });
}

/** Handles clicking the 'Add Away Member' button */
function handleAddAwayTeamMember(teamIndex) {
    const nameInput = document.getElementById(`newAwayName_${teamIndex}`);
    const levelInput = document.getElementById(`newAwayLevel_${teamIndex}`);
    const sourceInput = document.getElementById(`newAwaySource_${teamIndex}`);

    const name = nameInput?.value.trim();
    const level = parseInt(levelInput?.value);
    const sourceTeam = sourceInput?.value.trim();

    // Validation
    if (!name) { alert('Please enter a name for the away-team member.'); return; }
    if (isNaN(level) || level < 1 || level > 5) { alert('Please enter a valid level (1-5).'); return; }
    if (!sourceTeam) { alert('Please enter the source team/organization.'); return; }

    // Add to data model
    const team = currentSystemData.teams[teamIndex];
    if (!team) { console.error(`Cannot add away member, team index ${teamIndex} not found.`); return; }
    if (!team.awayTeamMembers) { team.awayTeamMembers = []; }

    // Check if member with same name already exists *in this team's away list*
    if (team.awayTeamMembers.some(m => m.name.toLowerCase() === name.toLowerCase())) {
        alert(`An away-team member named "${name}" is already assigned to this team.`);
        return;
    }

    team.awayTeamMembers.push({ name, level, sourceTeam });
    console.log(`Added away member to team ${teamIndex}:`, { name, level, sourceTeam });

    // Clear inputs
    if (nameInput) nameInput.value = '';
    if (levelInput) levelInput.value = '';
    if (sourceInput) sourceInput.value = '';

    // Refresh display
    displayAwayTeamMembers(team.awayTeamMembers, teamIndex);
    updateEffectiveBISDisplay(teamIndex); // Update the read-only BIS display
}

/** Handles clicking the 'Remove' button for an away-team member */
function handleRemoveAwayTeamMember(teamIndex, memberIndex) {
    const team = currentSystemData.teams[teamIndex];
    if (!team || !team.awayTeamMembers || memberIndex >= team.awayTeamMembers.length) {
        console.error(`Cannot remove away member, invalid indices: team ${teamIndex}, member ${memberIndex}`);
        return;
    }

    const removedMember = team.awayTeamMembers.splice(memberIndex, 1);
    console.log(`Removed away member from team ${teamIndex}:`, removedMember);

    // Refresh display
    displayAwayTeamMembers(team.awayTeamMembers, teamIndex);
    updateEffectiveBISDisplay(teamIndex); // Update the read-only BIS display
}

/** Helper to update the read-only Effective BIS display for a team */
function updateEffectiveBISDisplay(teamIndex) {
    const team = currentSystemData.teams[teamIndex];
    if (!team) return;

    const teamBIS = team.engineers?.length ?? 0;
    const awayTeamBIS = team.awayTeamMembers?.length ?? 0;
    const effectiveBIS = teamBIS + awayTeamBIS;
    const bisTooltip = `Team BIS: ${teamBIS}, Away-Team BIS: ${awayTeamBIS}`;

    const effectiveBISSpan = document.getElementById(`effectiveBIS_${teamIndex}`);
    const effectiveBISLabel = effectiveBISSpan?.previousElementSibling; // Get label for tooltip update

    if (effectiveBISSpan) {
        effectiveBISSpan.textContent = effectiveBIS;
        effectiveBISSpan.title = bisTooltip; // Update value tooltip
    }
     if (effectiveBISLabel) {
        effectiveBISLabel.title = bisTooltip; // Update label tooltip
     }
}

/** Helper to refresh available engineer lists in all open team edit sections */
function refreshAllAvailableEngineerLists() {
     console.log("Refreshing all available engineer lists...");
     const allTeamEditDivs = document.querySelectorAll('#teamsManagement .team-edit');
     let allEngineerNamesMap = new Map(); // Recalculate global map
     (currentSystemData.teams || []).forEach(t => { (t.engineers || []).forEach(eng => { if (eng?.name) allEngineerNamesMap.set(eng.name, t.teamId); }); });

     allTeamEditDivs.forEach((teamDiv, index) => {
         // Only refresh if the details are potentially visible (no easy way to know for sure without checking style)
         // This is a simplification; ideally, only refresh *actually* visible ones.
         const teamData = currentSystemData.teams[index]; // Assuming render index matches data index
         if (!teamData) return;

         const availableEngineersSelect = teamDiv.querySelector('select[data-field="availableEngineers"]');
         const currentEngineersSelect = teamDiv.querySelector('select[data-field="currentEngineers"]');

         if (availableEngineersSelect && currentEngineersSelect) {
             const currentTeamEngineers = Array.from(currentEngineersSelect.options).map(opt => opt.value);
             availableEngineersSelect.innerHTML = ''; // Clear current options
             Array.from(allEngineerNamesMap.keys())
                 .filter(name => !currentTeamEngineers.includes(name)) // Filter out engineers already in the current list
                 .forEach(name => {
                     availableEngineersSelect.appendChild(new Option(name, name));
                 });
         }
     });
}

/** Helper to refresh available options in a specific dual list (used for services) */
function refreshAvailableListsInDualList(contentContainer, currentListField, availableListField, allOptionsData, currentTeamId) {
    const currentSelect = contentContainer.querySelector(`select[data-field='${currentListField}']`);
    const availableSelect = contentContainer.querySelector(`select[data-field='${availableListField}']`);

    if (currentSelect && availableSelect) {
        const currentlyAssignedValues = Array.from(currentSelect.options).map(opt => opt.value);
        availableSelect.innerHTML = ''; // Clear
        allOptionsData.forEach(optionData => {
            // For services, filter out those owned by the current team OR already in the 'current' list
             if (optionData.owningTeamId !== currentTeamId && !currentlyAssignedValues.includes(optionData.value)) {
                 availableSelect.appendChild(new Option(optionData.text, optionData.value));
             }
        });
        console.log(`Refreshed available list for field: ${availableListField}`);
    } else {
         console.warn(`Could not find select lists for refresh: ${currentListField} / ${availableListField}`);
    }
}

/** NEW Helper Function: Creates a summary string of away-team sources */
function getSourceSummary(awayTeamMembers) {
    if (!awayTeamMembers || awayTeamMembers.length === 0) {
        return '';
    }
    const sources = awayTeamMembers
        .map(m => m.sourceTeam)
        .filter(source => source && source.trim() !== ''); // Get non-empty sources

    const uniqueSources = [...new Set(sources)]; // Get unique sources

    if (uniqueSources.length === 0) {
        return 'Unknown Source'; // Fallback if sources were empty strings
    } else if (uniqueSources.length === 1) {
        return uniqueSources[0];
    } else if (uniqueSources.length === 2) {
        return uniqueSources.join(', ');
    } else {
        return `${uniqueSources.slice(0, 1).join(', ')} & Others`; // Show first + others if more than 2
    }
}

// *** END NEW HELPER FUNCTIONS ***


function updateTeamSize(teamIndex, newSize) {
    currentSystemData.teams[teamIndex].sizeOfTeam = newSize;

    // Update the UI element for "Size of Team"
    const teamDiv = document.querySelectorAll('.team-edit')[teamIndex];
    const sizeInput = teamDiv.querySelector('input[data-field="sizeOfTeam"]');
    sizeInput.value = newSize;

    // **Update sizeOfTeam in currentSystemData**
    currentSystemData.teams[teamIndex].sizeOfTeam = newSize;
}

function updateAvailableEngineersInOtherTeams(engineerName, assignedTeamId) {
    // Loop through all teams
    currentSystemData.teams.forEach((team, idx) => {
        // Skip the team where the engineer was just added or removed
        if (team.teamId === assignedTeamId) {
            return;
        }

        const teamDiv = document.querySelectorAll('.team-edit')[idx];
        const availableEngineersSelect = teamDiv.querySelector('select[data-field="availableEngineers"]');
        const currentEngineersSelect = teamDiv.querySelector('select[data-field="currentEngineers"]');

        if (assignedTeamId) {
            // Remove from availableEngineersSelect
            const option = Array.from(availableEngineersSelect.options).find(opt => opt.value === engineerName);
            if (option) {
                availableEngineersSelect.removeChild(option);
            }
        } else {
            // Add to availableEngineersSelect if not already present
            const optionExists = Array.from(availableEngineersSelect.options).some(opt => opt.value === engineerName);
            const inCurrentEngineers = Array.from(currentEngineersSelect.options).some(opt => opt.value === engineerName);
            if (!optionExists && !inCurrentEngineers) {
                let option = document.createElement('option');
                option.value = engineerName;
                option.text = engineerName;
                availableEngineersSelect.appendChild(option);
            }
        }
    });
}

function updateAvailableServicesInOtherTeams(serviceName, assignedTeamId) {
    // Loop through all teams
    currentSystemData.teams.forEach((team, idx) => {
        // Skip the team where the service was just added or removed
        if (team.teamId === assignedTeamId) {
            return;
        }

        const teamDiv = document.querySelectorAll('.team-edit')[idx];
        const availableServicesSelect = teamDiv.querySelector('select[data-field="availableServices"]');
        const currentServicesSelect = teamDiv.querySelector('select[data-field="currentServices"]');

        if (assignedTeamId) {
            // Remove from availableServicesSelect
            const option = Array.from(availableServicesSelect.options).find(opt => opt.value === serviceName);
            if (option) {
                availableServicesSelect.removeChild(option);
            }
        } else {
            // Add to availableServicesSelect if not already present
            const optionExists = Array.from(availableServicesSelect.options).some(opt => opt.value === serviceName);
            const inCurrentServices = Array.from(currentServicesSelect.options).some(opt => opt.value === serviceName);
            if (!optionExists && !inCurrentServices) {
                let option = document.createElement('option');
                option.value = serviceName;
                option.text = serviceName;
                availableServicesSelect.appendChild(option);
            }
        }
    });
}

function removeServiceFromPreviousTeam(serviceName, prevTeamId) {
    const prevTeamIndex = currentSystemData.teams.findIndex(t => t.teamId === prevTeamId);
    if (prevTeamIndex !== -1) {
        const prevTeamDiv = document.querySelectorAll('.team-edit')[prevTeamIndex];
        const prevCurrentServicesSelect = prevTeamDiv.querySelector('select[data-field="currentServices"]');
        const prevOption = Array.from(prevCurrentServicesSelect.options).find(opt => opt.value === serviceName);
        if (prevOption) {
            prevCurrentServicesSelect.removeChild(prevOption);
            // Add to availableServicesSelect of previous team
            const prevAvailableServicesSelect = prevTeamDiv.querySelector('select[data-field="availableServices"]');
            prevAvailableServicesSelect.appendChild(prevOption.cloneNode(true));
        }
    }
}

function removeEngineerFromPreviousTeam(engineerName, prevTeamId) {
    const prevTeamIndex = currentSystemData.teams.findIndex(t => t.teamId === prevTeamId);
    if (prevTeamIndex !== -1) {
        const prevTeamDiv = document.querySelectorAll('.team-edit')[prevTeamIndex];
        const prevCurrentEngineersSelect = prevTeamDiv.querySelector('select[data-field="currentEngineers"]');
        const prevOption = Array.from(prevCurrentEngineersSelect.options).find(opt => opt.value === engineerName);
        if (prevOption) {
            prevCurrentEngineersSelect.removeChild(prevOption);
            // Update uniqueEngineers
            const engineer = uniqueEngineers.find(e => e.engineerName === engineerName);
            if (engineer) engineer.teamId = null;
        }
    }
}

function validateTeamChanges() {
    // Check for engineers assigned to multiple teams
    const engineerAssignments = {};
    currentSystemData.teams.forEach(team => {
        const teamEngineers = team.engineerNames ? team.engineerNames.split(',').map(name => name.trim()) : [];
        teamEngineers.forEach(engineerName => {
            if (engineerName) {
                if (engineerAssignments[engineerName]) {
                    engineerAssignments[engineerName].push(team.teamName || team.teamIdentity || 'Unnamed Team');
                } else {
                    engineerAssignments[engineerName] = [team.teamName || team.teamIdentity || 'Unnamed Team'];
                }
            }
        });
    });

    const conflictingEngineers = Object.entries(engineerAssignments).filter(([_, teams]) => teams.length > 1);

    // Check for services owned by multiple teams
    const serviceAssignments = {};
    currentSystemData.services.forEach(service => {
        if (service.owningTeamId) {
            if (serviceAssignments[service.serviceName]) {
                serviceAssignments[service.serviceName].push(service.owningTeamId);
            } else {
                serviceAssignments[service.serviceName] = [service.owningTeamId];
            }
        }
    });

    const conflictingServices = Object.entries(serviceAssignments).filter(([_, teams]) => teams.length > 1);

    let validationErrors = '';

    if (conflictingEngineers.length > 0) {
        validationErrors += 'The following engineers are assigned to multiple teams:\n';
        conflictingEngineers.forEach(([engineerName, teams]) => {
            validationErrors += `- ${engineerName}: ${teams.join(', ')}\n`;
        });
    }

    if (conflictingServices.length > 0) {
        validationErrors += 'The following services are owned by multiple teams:\n';
        conflictingServices.forEach(([serviceName, teamIds]) => {
            const teamNames = teamIds.map(teamId => {
                const team = currentSystemData.teams.find(t => t.teamId === teamId);
                return team ? (team.teamName || team.teamIdentity || 'Unnamed Team') : 'Unknown Team';
            });
            validationErrors += `- ${serviceName}: ${teamNames.join(', ')}\n`;
        });
    }

    if (validationErrors) {
        alert('Validation Errors:\n' + validationErrors);
        return false;
    }

    return true;
}


/** Updated Save Team Changes **/
/** Updated Save Team Changes - Includes Collapse Logic & Validation Call **/
function saveTeamChanges(index) {
    // Get the specific team object
    if (!currentSystemData || !currentSystemData.teams || index >= currentSystemData.teams.length) {
        console.error("Cannot save team, invalid index or data:", index);
        return;
    }
    const team = currentSystemData.teams[index];

    // --- Data is assumed to be updated by input listeners and dual-list callbacks ---

    // Recalculate Builders In Seats just to be sure it matches the array
    team.buildersInSeats = team.engineers ? team.engineers.length : 0;

    // Validate required fields for this team
    if (!team.teamIdentity || !team.teamName) {
        alert('Team Identity and Team Name are required.');
        return; // Don't proceed if basic info missing
    }

    // *** Add cross-team validation before saving system state ***
    if (!validateEngineerAssignments()) { // Call validation function
        return; // Stop saving if validation fails
    }
    // *********************************************************

    console.log("Saving changes for team (via saveSystemChanges):", JSON.stringify(team, null, 2));

    // --- Save the entire system data to local storage ---
    saveSystemChanges(); // This function now also includes validation internally

    // --- Update related UI elements ---
    generateTeamTable(currentSystemData); // Update main Team Breakdown table
    generateTeamVisualization(currentSystemData); // Update Team Visualization

    alert(`Changes for team "${team.teamName || team.teamIdentity}" potentially saved (system state saved).`);

    // --- Collapse the edit section after saving attempt ---
    const teamDivs = document.querySelectorAll('#teamsManagement .team-edit');
    if (index < teamDivs.length) {
         const teamDiv = teamDivs[index];
         const teamDetails = teamDiv.querySelector('.team-details');
         const indicator = teamDiv.querySelector('h4 > span');
         // Check if elements exist before modifying
         if (teamDetails) teamDetails.style.display = 'none';
         if (indicator) indicator.innerText = '+ ';
     }
    // -----------------------------------------------------
}


/** Display Services for Editing **/

/** REVISED Display Services for Editing - Refresh on Add Platform Dep **/
function displayServicesForEditing(services, containerId, expandedIndex = -1) {
    const servicesDiv = document.getElementById(containerId);
    servicesDiv.innerHTML = ''; // Clear existing content

    // Get a list of existing teams for the owning team selection
    const teamOptions = (currentSystemData.teams || []).map(team => ({ // Added default empty array
        teamId: team.teamId,
        teamIdentity: team.teamIdentity
    }));

    // Ensure platformDependencies is initialized and rebuilt
    if (!currentSystemData.platformDependencies) {
        currentSystemData.platformDependencies = [];
    }

    (services || []).forEach((service, index) => { // Added default empty array
        if (!service) return; // Skip potentially null entries if array was modified externally

        let serviceDiv = document.createElement('div');
        serviceDiv.className = 'service-edit';
        serviceDiv.setAttribute('data-service-index', index); // Add index for easier selection

        // Header (collapsible)
        let serviceHeader = document.createElement('h4');
        // Ensure serviceName exists before using it
        const headerText = service.serviceName || 'New Service';
        serviceHeader.style.cursor = 'pointer';
        let indicator = document.createElement('span');
        indicator.innerText = (index === expandedIndex) ? '- ' : '+ '; // Set initial state based on expandedIndex
        serviceHeader.appendChild(indicator);
        serviceHeader.appendChild(document.createTextNode(`Service: ${headerText}`));

        // Details container
        let serviceDetails = document.createElement('div');
        serviceDetails.className = 'service-details';
        serviceDetails.style.display = (index === expandedIndex) ? 'block' : 'none'; // Set initial state

        // Toggle Functionality - Modified to refresh lists on expand
        serviceHeader.onclick = () => {
            const content = serviceDetails; // Use variable already defined
            const isCurrentlyCollapsed = content.style.display === 'none' || content.style.display === '';
            content.style.display = isCurrentlyCollapsed ? 'block' : 'none';
            indicator.innerText = isCurrentlyCollapsed ? '- ' : '+ ';

            // Refresh available lists only when expanding
            if (isCurrentlyCollapsed) {
                console.log("Refreshing lists on expand for service:", service.serviceName);
                // Refresh Available Platform Dependencies
                const otherPlatDepsSelect = content.querySelector('select[data-field="availablePlatformDependencies"]');
                const currentPlatDepsSelect = content.querySelector('select[data-field="currentPlatformDependencies"]');
                if (otherPlatDepsSelect && currentPlatDepsSelect) {
                    const currentPlatDeps = Array.from(currentPlatDepsSelect.options).map(opt => opt.value);
                    otherPlatDepsSelect.innerHTML = ''; // Clear
                     (currentSystemData.platformDependencies || []).forEach(dep => {
                        if (!currentPlatDeps.includes(dep)) {
                            otherPlatDepsSelect.appendChild(new Option(dep, dep));
                        }
                    });
                }

                // Refresh Available Service Dependencies
                const otherSvcDepsSelect = content.querySelector('select[data-field="availableServiceDependencies"]');
                const currentSvcDepsSelect = content.querySelector('select[data-field="currentServiceDependencies"]');
                if (otherSvcDepsSelect && currentSvcDepsSelect) {
                    const currentSvcDeps = Array.from(currentSvcDepsSelect.options).map(opt => opt.value);
                    otherSvcDepsSelect.innerHTML = ''; // Clear
                     (currentSystemData.services || []).forEach(otherSvc => {
                        if (otherSvc.serviceName !== service.serviceName && !currentSvcDeps.includes(otherSvc.serviceName)) {
                            otherSvcDepsSelect.appendChild(new Option(otherSvc.serviceName, otherSvc.serviceName));
                        }
                    });
                }

                // Refresh Available APIs for each API within this service
                const apiEditDivs = content.querySelectorAll('.api-edit');
                const allApisList = (currentSystemData.services || []).flatMap(s => (s.apis || []).map(a => a.apiName));
                apiEditDivs.forEach((apiDiv, apiIdx) => {
                     const currentApiName = service.apis[apiIdx]?.apiName; // Get current API name
                     const otherApiDepsSelect = apiDiv.querySelector('select[data-field="availableApis"]');
                     const currentApiDepsSelect = apiDiv.querySelector('select[data-field="currentDependentApis"]');
                     if (otherApiDepsSelect && currentApiDepsSelect && currentApiName) {
                         const currentApiDeps = Array.from(currentApiDepsSelect.options).map(opt => opt.value);
                         otherApiDepsSelect.innerHTML = ''; // Clear
                         allApisList.forEach(apiName => {
                             if (apiName !== currentApiName && !currentApiDeps.includes(apiName)) {
                                 otherApiDepsSelect.appendChild(new Option(apiName, apiName));
                             }
                         });
                     }
                 });
            }
        };

        // --- Service Name & Description ---
        let nameLabel = document.createElement('label');
        nameLabel.innerText = 'Service Name:';
        let nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = service.serviceName || '';
        nameInput.setAttribute('data-service-index', index);
        nameInput.setAttribute('data-field', 'serviceName');
        nameInput.addEventListener('change', handleServiceInputChange); // Use shared handler
        serviceDetails.appendChild(nameLabel); serviceDetails.appendChild(document.createElement('br'));
        serviceDetails.appendChild(nameInput); serviceDetails.appendChild(document.createElement('br'));

        let descLabel = document.createElement('label');
        descLabel.innerText = 'Service Description:';
        let descTextarea = document.createElement('textarea');
        descTextarea.rows = 2; descTextarea.style.width = '90%';
        descTextarea.value = service.serviceDescription || '';
        descTextarea.setAttribute('data-service-index', index);
        descTextarea.setAttribute('data-field', 'serviceDescription');
        descTextarea.addEventListener('change', handleServiceInputChange); // Use shared handler
        serviceDetails.appendChild(descLabel); serviceDetails.appendChild(document.createElement('br'));
        serviceDetails.appendChild(descTextarea); serviceDetails.appendChild(document.createElement('br'));
        // -----------------------------------

        // --- Platform Dependencies ---
        const currentPlatDeps = (service.platformDependencies || []).map(dep => ({ value: dep, text: dep }));
        const availablePlatDeps = (currentSystemData.platformDependencies || []).filter(dep => !(service.platformDependencies || []).includes(dep)).map(dep => ({ value: dep, text: dep }));
        const platformContainer = createDualListContainer(
            index, 'Current Platform Deps:', 'Available Platform Deps:',
            currentPlatDeps, availablePlatDeps,
            'currentPlatformDependencies', 'availablePlatformDependencies',
            (movedDep, direction, serviceIdx) => { // Callback updates data model directly
                const targetService = currentSystemData.services[serviceIdx];
                if (!targetService.platformDependencies) targetService.platformDependencies = [];
                if (direction === 'add') {
                    if (!targetService.platformDependencies.includes(movedDep)) targetService.platformDependencies.push(movedDep);
                } else {
                    targetService.platformDependencies = targetService.platformDependencies.filter(d => d !== movedDep);
                }
            },
            true, true, 'Enter New Platform Dependency', // multiSelectLeft = true, allowAddNew = true
            (newDepName) => { // Add New Callback for Platform Deps (Simplified like SDM/PMT)
                        const textInput = platformContainer.querySelector('input[type="text"]'); // Get input relative to this dual list
                        if (!newDepName || newDepName.trim() === '') {
                            if(textInput) textInput.value = ''; // Clear input even if empty
                            return null;
                        }
                        newDepName = newDepName.trim();

                        // Ensure global platform dependencies array exists
                        if (!currentSystemData.platformDependencies) {
                            currentSystemData.platformDependencies = [];
                        }

                        const alreadyExistsGlobally = currentSystemData.platformDependencies.includes(newDepName);

                        // Find the specific select lists for THIS service instance to check if already visible
                        const currentPlatDepsSelect = platformContainer.querySelector('select[data-field="currentPlatformDependencies"]');
                        const availablePlatDepsSelect = platformContainer.querySelector('select[data-field="availablePlatformDependencies"]');

                        if (!currentPlatDepsSelect || !availablePlatDepsSelect) {
                             console.error("Could not find platform dependency select lists for service index:", index);
                             if(textInput) textInput.value = '';
                             return null;
                         }

                        const inCurrentList = Array.from(currentPlatDepsSelect.options).some(opt => opt.value === newDepName);
                        const inAvailableList = Array.from(availablePlatDepsSelect.options).some(opt => opt.value === newDepName);

                        if (inCurrentList || inAvailableList) {
                             alert(`Platform dependency "${newDepName}" is already listed for this service.`);
                             if(textInput) textInput.value = '';
                             return null; // Already present for this service, do nothing more
                         }

                        // If it doesn't exist globally, add it to the global data list
                        if (!alreadyExistsGlobally) {
                            currentSystemData.platformDependencies.push(newDepName);
                            console.log("Added new global platform dependency to data:", newDepName);
                        } else {
                            console.log(`"${newDepName}" already exists globally.`);
                        }

                        // --- ALWAYS RETURN THE ITEM ---
                        // Let createDualListContainer handle adding it to the 'Available' list for *this instance*.
                        // The fact it's in currentSystemData.platformDependencies ensures it's available later.
                        if (textInput) textInput.value = ''; // Clear the input field
                        return { value: newDepName, text: newDepName };
                    }
        );
        serviceDetails.appendChild(platformContainer);
        serviceDetails.appendChild(document.createElement('br'));
        // ---------------------------

         // --- Service Dependencies ---
         const currentSvcDeps = (service.serviceDependencies || []).map(dep => ({ value: dep, text: dep }));
         const availableSvcDeps = (currentSystemData.services || [])
             .filter(s => s.serviceName !== service.serviceName && !(service.serviceDependencies || []).includes(s.serviceName))
             .map(s => ({ value: s.serviceName, text: s.serviceName }));
         const serviceDepContainer = createDualListContainer(
             index, 'Current Service Deps:', 'Available Services:',
             currentSvcDeps, availableSvcDeps,
             'currentServiceDependencies', 'availableServiceDependencies',
             (movedSvc, direction, serviceIdx) => { // Callback updates data model directly
                 const targetService = currentSystemData.services[serviceIdx];
                 if (!targetService.serviceDependencies) targetService.serviceDependencies = [];
                 if (direction === 'add') {
                     if (!targetService.serviceDependencies.includes(movedSvc)) targetService.serviceDependencies.push(movedSvc);
                 } else {
                     targetService.serviceDependencies = targetService.serviceDependencies.filter(d => d !== movedSvc);
                 }
             },
             true // multiSelectLeft = true
             // Cannot add new *services* from here, only from main 'Add New Service' button
         );
         serviceDetails.appendChild(serviceDepContainer);
         serviceDetails.appendChild(document.createElement('br'));
        // ------------------------

        // --- APIs Section ---
        let apisContainer = document.createElement('div');
        apisContainer.className = 'apis-container';
        let apisLabel = document.createElement('h5');
        apisLabel.innerText = 'APIs:'; apisLabel.style.marginTop = '15px';
        apisContainer.appendChild(apisLabel);

        const allApisList = (currentSystemData.services || []).flatMap(s => (s.apis || []).map(a => a.apiName));

        (service.apis || []).forEach((api, apiIndex) => {
            let apiDiv = document.createElement('div');
            apiDiv.className = 'api-edit';

            let apiNameLabel = document.createElement('label'); apiNameLabel.innerText = 'API Name:';
            let apiNameInput = document.createElement('input'); apiNameInput.type = 'text'; apiNameInput.value = api.apiName || '';
            apiNameInput.setAttribute('data-service-index', index); apiNameInput.setAttribute('data-api-index', apiIndex); apiNameInput.setAttribute('data-field', 'apiName');
            apiNameInput.addEventListener('change', handleApiInputChange); // Use shared handler
            apiDiv.appendChild(apiNameLabel); apiDiv.appendChild(document.createElement('br'));
            apiDiv.appendChild(apiNameInput); apiDiv.appendChild(document.createElement('br'));

            let apiDescLabel = document.createElement('label'); apiDescLabel.innerText = 'API Description:';
            let apiDescTextarea = document.createElement('textarea'); apiDescTextarea.rows = 2; apiDescTextarea.style.width = '90%'; apiDescTextarea.value = api.apiDescription || '';
            apiDescTextarea.setAttribute('data-service-index', index); apiDescTextarea.setAttribute('data-api-index', apiIndex); apiDescTextarea.setAttribute('data-field', 'apiDescription');
            apiDescTextarea.addEventListener('change', handleApiInputChange); // Use shared handler
            apiDiv.appendChild(apiDescLabel); apiDiv.appendChild(document.createElement('br'));
            apiDiv.appendChild(apiDescTextarea); apiDiv.appendChild(document.createElement('br'));

            // API Dependencies Dual List
            const currentApiDeps = (api.dependentApis || []).map(dep => ({ value: dep, text: dep }));
            const availableApiDeps = allApisList
                .filter(aName => aName !== api.apiName && !(api.dependentApis || []).includes(aName))
                .map(aName => ({ value: aName, text: aName }));
            const apiDepsContainer = createDualListContainer(
                 apiIndex, // Context is the API index within the service
                 'Current API Deps:', 'Available APIs:',
                 currentApiDeps, availableApiDeps,
                 'currentDependentApis', 'availableApis',
                 (movedApi, direction, currentApiIndex) => { // Callback updates data model directly
                     const targetService = currentSystemData.services[index]; // Outer service index
                     const targetApi = targetService?.apis[currentApiIndex];
                     if (targetApi) {
                         if (!targetApi.dependentApis) targetApi.dependentApis = [];
                         if (direction === 'add') {
                             if (!targetApi.dependentApis.includes(movedApi)) targetApi.dependentApis.push(movedApi);
                         } else {
                             targetApi.dependentApis = targetApi.dependentApis.filter(d => d !== movedApi);
                         }
                     }
                 },
                 true // multiSelectLeft = true
                 // Cannot add *new* APIs here, only via the service's 'Add New API' button
             );
             apiDiv.appendChild(apiDepsContainer);
             apiDiv.appendChild(document.createElement('br'));


            let deleteApiButton = document.createElement('button'); deleteApiButton.type = 'button'; deleteApiButton.innerText = 'Delete API';
            deleteApiButton.onclick = () => deleteApi(index, apiIndex, containerId); // Pass containerId
            apiDiv.appendChild(deleteApiButton);

            apisContainer.appendChild(apiDiv);
        });

        let addApiButton = document.createElement('button'); addApiButton.type = 'button'; addApiButton.innerText = 'Add New API';
        addApiButton.onclick = () => addNewApi(index, containerId); // Pass containerId
        apisContainer.appendChild(addApiButton);
        serviceDetails.appendChild(apisContainer);
        serviceDetails.appendChild(document.createElement('br'));
        // --------------------

        // --- Action Buttons ---
        let deleteServiceButton = document.createElement('button'); deleteServiceButton.type = 'button'; deleteServiceButton.innerText = 'Delete Service';
        deleteServiceButton.style.color = 'red'; deleteServiceButton.style.marginLeft = '10px';
        deleteServiceButton.onclick = () => { if (confirm('Are you sure?')) deleteService(index, containerId); }; // Pass containerId
        serviceDetails.appendChild(deleteServiceButton);

        let saveServiceButton = document.createElement('button'); saveServiceButton.type = 'button'; saveServiceButton.innerText = 'Save Service Changes';
        saveServiceButton.style.marginLeft = '10px';
        saveServiceButton.onclick = () => saveServiceChanges(index); // Saves only this service's state from currentSystemData
        serviceDetails.appendChild(saveServiceButton);
        // --------------------

        serviceDiv.appendChild(serviceHeader);
        serviceDiv.appendChild(serviceDetails);
        servicesDiv.appendChild(serviceDiv);
    }); // End services.forEach

    // --- Shared Event Handlers for Inputs ---
    function handleServiceInputChange(event) {
        const serviceIndex = parseInt(event.target.getAttribute('data-service-index'));
        const field = event.target.getAttribute('data-field');
        const value = event.target.value;
        if (serviceIndex >= 0 && serviceIndex < currentSystemData.services.length) {
            currentSystemData.services[serviceIndex][field] = value;
            // If service name changed, update the header
            if (field === 'serviceName') {
                 const header = event.target.closest('.service-edit')?.querySelector('h4');
                 if (header) {
                     const indicatorSpan = header.querySelector('span');
                     header.textContent = `Service: ${value || 'New Service'}`; // Recreate text
                     if(indicatorSpan) header.insertBefore(indicatorSpan, header.firstChild); // Add indicator back
                 }
            }
        }
    }

     function handleApiInputChange(event) {
        const serviceIndex = parseInt(event.target.getAttribute('data-service-index'));
        const apiIndex = parseInt(event.target.getAttribute('data-api-index'));
        const field = event.target.getAttribute('data-field');
        const value = event.target.value;
        if (serviceIndex >= 0 && serviceIndex < currentSystemData.services.length &&
            apiIndex >= 0 && apiIndex < currentSystemData.services[serviceIndex].apis.length) {
            currentSystemData.services[serviceIndex].apis[apiIndex][field] = value;
        }
    }
    // ------------------------------------

    // --- Helper to find current expanded service index ---
     function findExpandedServiceIndex(containerId = 'editServicesManagement') { // Default containerId
         const servicesContainerDiv = document.getElementById(containerId);
         if (!servicesContainerDiv) {
             console.warn("findExpandedServiceIndex: Could not find container with ID:", containerId);
             return -1;
         }
         const serviceDetailDivs = servicesContainerDiv.querySelectorAll('.service-details'); // Use class selector
         for (let i = 0; i < serviceDetailDivs.length; i++) {
             // Check the display style directly
             if (serviceDetailDivs[i].style.display === 'block') {
                 // Find the parent service-edit div to get the index attribute
                 const parentEditDiv = serviceDetailDivs[i].closest('.service-edit');
                 if (parentEditDiv) {
                     const indexAttr = parentEditDiv.getAttribute('data-service-index');
                     if (indexAttr !== null) {
                         return parseInt(indexAttr); // Return the index from the attribute
                     }
                 }
             }
         }
         return -1; // Not found or none expanded
     }

} // --- End displayServicesForEditing ---

function saveServiceChanges(serviceIndex) {
    // Perform validation (optional)
    const service = currentSystemData.services[serviceIndex];
    if (!service.serviceName || service.serviceName.trim() === '') {
        alert('Service name cannot be empty.');
        return;
    }

    const serviceEditDivs = document.querySelectorAll('.service-edit');
    const currentServiceDiv = serviceEditDivs[serviceIndex];

    // Update Platform Dependencies
    const currentDepsSelect = currentServiceDiv.querySelector('select[data-field="currentPlatformDependencies"]');
    const selectedDependencies = Array.from(currentDepsSelect.options).map(option => option.value);
    service.platformDependencies = selectedDependencies;

    // Update Service Dependencies
    const currentServiceDepsSelect = currentServiceDiv.querySelector('select[data-field="currentServiceDependencies"]');
    const selectedServiceDependencies = Array.from(currentServiceDepsSelect.options).map(option => option.value);
    service.serviceDependencies = selectedServiceDependencies;

    // **Update APIs and their Dependent APIs**
    const apisContainer = currentServiceDiv.querySelector('.apis-container');
    const apiEditDivs = apisContainer.querySelectorAll('.api-edit');

    service.apis.forEach((api, apiIndex) => {
        const apiDiv = apiEditDivs[apiIndex];

        // Update API fields
        const apiNameInput = apiDiv.querySelector('input[data-field="apiName"]');
        api.apiName = apiNameInput.value;

        const apiDescTextarea = apiDiv.querySelector('textarea[data-field="apiDescription"]');
        api.apiDescription = apiDescTextarea.value;

        // Update Dependent APIs
        const currentDependentApisSelect = apiDiv.querySelector('select[data-field="currentDependentApis"]');
        const selectedDependentApis = Array.from(currentDependentApisSelect.options).map(option => option.value);
        api.dependentApis = selectedDependentApis;
    });

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    systems[currentSystemData.systemName] = currentSystemData;
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    alert('Service changes saved.');

    // **Update the Team Breakdown and Service Dependencies Tables**
    generateTeamTable(currentSystemData);
    generateServiceDependenciesTable();
    
    // Optionally collapse the service details or provide additional feedback
}

/** Add New Service in Edit Form **/
function addNewEditService() {
    // Create a new service object with default values
    const newService = {
        serviceName: 'New Service',
        serviceDescription: '',
        owningTeamId: '',
        apis: [],
        serviceDependencies: [],
        platformDependencies: []
    };

    // Add to the system data
    if (!currentSystemData.services) {
        currentSystemData.services = [];
    }
    currentSystemData.services.push(newService);

    // Refresh the service editing display for the edit form
    displayServicesForEditing(currentSystemData.services, 'editServicesManagement');
}

/** Add New Service **/

/** REVISED Add New Service - Simplified Refresh Call **/
function addNewService() {
    // Create a new service object with default values
    const newService = {
        serviceName: 'New Service ' + ((currentSystemData.services?.length || 0) + 1),
        serviceDescription: '',
        owningTeamId: null,
        apis: [],
        serviceDependencies: [],
        platformDependencies: []
    };

    // Add to the system data
    if (!currentSystemData.services) {
        currentSystemData.services = [];
    }
    currentSystemData.services.push(newService);
    console.log("Added new service to data:", newService); // Log data addition

    // --- Refresh BOTH Service and Team editing displays ---
    // Call display functions WITHOUT trying to preserve expanded index for now
    console.log("Refreshing service editors...");
    try {
        displayServicesForEditing(currentSystemData.services, 'editServicesManagement');
    } catch (error) {
         console.error("Error during displayServicesForEditing:", error);
         alert("Error refreshing service list. Check console.");
         return; // Stop if service display fails
    }


    console.log("Refreshing team editors...");
    try {
         displayTeamsForEditing(currentSystemData.teams);
     } catch (error) {
         console.error("Error during displayTeamsForEditing:", error);
         alert("Error refreshing team list. Check console.");
         return; // Stop if team display fails
     }
    console.log("UI refresh attempt complete after adding service.");
    // ------------------------------------------------------
}

/** Delete Service **/

function deleteService(serviceIndex, containerId) {
    // Remove the service from the system data
    currentSystemData.services.splice(serviceIndex, 1);

    // **Update the Team Breakdown and Service Dependencies Tables**
    generateTeamTable(currentSystemData);
    generateServiceDependenciesTable();
    
    // Refresh the service editing display
    displayServicesForEditing(currentSystemData.services, containerId,serviceIndex);
}

/** Add New API **/

/** REVISED Add New API - Refresh UI **/
function addNewApi(serviceIndex, containerId = 'editServicesManagement') { // Added containerId parameter
    // Find the service
    if (!currentSystemData || !currentSystemData.services || serviceIndex >= currentSystemData.services.length) {
        console.error("Cannot add API, invalid service index:", serviceIndex);
        return;
    }
    const service = currentSystemData.services[serviceIndex];

    // Create a new API object with default values
    const newApi = {
        apiName: 'New API ' + ((service.apis?.length || 0) + 1), // Slightly more unique default name
        apiDescription: '',
        dependentApis: []
    };

    // Add to the service's APIs
    if (!service.apis) {
        service.apis = [];
    }
    service.apis.push(newApi);

    // --- Refresh the service editing display ---
    // Re-rendering ensures all 'Available APIs' lists are updated
    console.log(`Refreshing service editors after adding new API to service index ${serviceIndex}...`);
    displayServicesForEditing(currentSystemData.services, containerId, serviceIndex); // Try to re-expand the current service
    // -----------------------------------------
}

/** Delete API **/

function deleteApi(serviceIndex, apiIndex, containerId) {
    // Remove the API from the service's APIs
    currentSystemData.services[serviceIndex].apis.splice(apiIndex, 1);

    // Refresh the service editing display
    displayServicesForEditing(currentSystemData.services, containerId, serviceIndex);
}


/** Add New Team **/

/** Updated Add New Team **/
function addNewTeam() {
    // Generate a unique teamId (simple approach for now)
    const newTeamId = 'team-' + Date.now();

    // Create a new team object with the updated default structure
    const newTeam = {
        teamId: newTeamId,
        teamName: '', // Blank initially
        teamIdentity: '', // Blank initially
        teamDescription: '', // Added field
        fundedHeadcount: 0, // Default funded HC
        buildersInSeats: 0, // Default BIS (no engineers yet)
        engineers: [], // Start with an empty array for engineers
        sdmId: null, // No default SDM assigned
        pmtId: null  // No default PMT assigned
        // Removed sdmName, pmtName as they are derived via IDs
    };

    // Add to the system data
    if (!currentSystemData.teams) {
        currentSystemData.teams = [];
    }
    currentSystemData.teams.push(newTeam);

    // Get the index of the newly added team
    const newTeamIndex = currentSystemData.teams.length - 1;

    // Refresh the team editing display and expand the new team
    // Pass -1 if displayTeamsForEditing doesn't handle expansion correctly, or pass newTeamIndex
    displayTeamsForEditing(currentSystemData.teams, newTeamIndex);
}

/** Delete Team **/

function deleteTeam(index) {
    const team = currentSystemData.teams[index];
    const confirmDelete = confirm(`Are you sure you want to delete the team "${team.teamName}"? This action cannot be undone.`);
    if (confirmDelete) {
        // Remove the team from currentSystemData.teams
        currentSystemData.teams.splice(index, 1);

        // Update services that reference this team
        currentSystemData.services.forEach(service => {
            if (service.owningTeamId === team.teamId) {
                service.owningTeamId = null;
            }
        });

        // Update uniqueEngineers array
        uniqueEngineers = uniqueEngineers.filter(engineer => engineer.teamId !== team.teamId);

        // Update team assignments in engineers
        currentSystemData.teams.forEach(t => {
            if (t.teamId !== team.teamId) {
                const engineers = t.engineerNames ? t.engineerNames.split(',').map(name => name.trim()) : [];
                t.engineerNames = engineers.filter(name => {
                    const engineer = uniqueEngineers.find(e => e.engineerName === name);
                    return engineer && engineer.teamId === t.teamId;
                }).join(', ');
            }
        });

        // Save changes to local storage
        saveSystemChanges();
        
        // Notify the user
        alert(`Team "${team.teamName}" has been deleted.`);

        // Refresh the teams editing interface
        displayTeamsForEditing(currentSystemData.teams);

        // Update other UI components
        generateTeamTable(currentSystemData);
        generateTeamVisualization(currentSystemData);
        generateServiceDependenciesTable();
        populateServiceSelection();
        populateDependencyServiceSelection();
        updateServiceVisualization();
        updateDependencyVisualization();
    }
}

/** Save System Details **/

function saveSystemDetails() {
    // Get updated system name and description
    console.log("*** 1 document.getElementById('systemNameInput').value",document.getElementById('systemNameInput').value);    
    console.log("*** 2 document.getElementById('systemDescriptionInput'",document.getElementById('systemDescriptionInput').value);    
    
    const systemNameInput = document.getElementById('systemNameInput');
    const systemDescriptionTextarea = document.getElementById('systemDescriptionInput');

    console.log("*** 3 systemNameInput = ", systemNameInput.value);
    console.log("*** 4 systemDescriptionTextarea = ", systemDescriptionTextarea.value);  
  
    const oldSystemName = currentSystemData.systemName;
    const newSystemName = systemNameInput.value.trim();

    if (!newSystemName) {
        alert('System name cannot be empty.');
        return;
    }

    currentSystemData.systemName = newSystemName;
    currentSystemData.systemDescription = systemDescriptionTextarea.value.trim();

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');

    systems[newSystemName] = currentSystemData;

    console.log('Saving to local storage:', systems);

    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    alert('System details saved, please continue to update the services and teams. Note: If you changed the system name, it is treated as a new system');

    if (currentMode == Modes.EDITING) {
      // Update UI components
      generateTeamTable(currentSystemData);
      generateServiceDependenciesTable();
      updateServiceVisualization();
      updateDependencyVisualization();
    }
}

/** Save All Changes **/

/** REVISED Save All Changes - Handles Creation and Updates */
function saveAllChanges() {
//    if (currentMode !== Modes.CREATING && currentMode !== Modes.EDITING) {
//         alert('Not in creation or edit mode. No changes to save.');
//         return;
//    }

    // --- Get Final System Name and Description from Form ---
    const systemNameInput = document.getElementById('systemNameInput');
    const systemDescriptionTextarea = document.getElementById('systemDescriptionInput');
    const finalSystemName = systemNameInput.value.trim();
    const finalSystemDescription = systemDescriptionTextarea.value.trim();

    if (!finalSystemName) {
        alert('System Name cannot be empty. Please enter a name before saving.');
        systemNameInput.focus(); // Focus the input field
        return;
    }
    // Basic check for description, can be optional
    if (!finalSystemDescription) {
         if (!confirm('System Description is empty. Save anyway?')) {
             systemDescriptionTextarea.focus();
             return;
         }
    }
    // --------------------------------------------------

    // --- Update currentSystemData with final name/desc ---
    // This ensures the object being saved has the correct top-level info
    const oldSystemNameKey = currentSystemData.systemName; // Store the name *before* updating
    currentSystemData.systemName = finalSystemName;
    currentSystemData.systemDescription = finalSystemDescription;
    console.log(`Attempting to save system as: "${finalSystemName}"`);
    // -----------------------------------------------------

    // --- Perform Validation ---
    // Ensure engineer assignments are valid before saving
    if (!validateEngineerAssignments()) {
         // If validation fails, revert name/desc change in the data object
         // to avoid potential mismatches if user cancels or tries again.
         currentSystemData.systemName = oldSystemNameKey;
         currentSystemData.systemDescription = document.getElementById('systemDescriptionInput').value; // Or revert based on how it was before validation
         return; // Stop the save
    }
    // Add other validation checks here if needed (e.g., required fields for teams/services)
    // ------------------------
    
    // --- Save to Local Storage ---
    try {
        const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');

         // Check if renaming an existing system or creating a new one
         if (currentMode === Modes.EDITING && oldSystemNameKey && oldSystemNameKey !== finalSystemName) {
             // If the name changed during editing, remove the old entry
             if (systems[oldSystemNameKey]) {
                 delete systems[oldSystemNameKey];
                 console.log(`Removed old system entry for key: "${oldSystemNameKey}" due to rename.`);
             }
         }
         // Check if overwriting another system with the new name (relevant for 'Create New' if name exists)
         if (systems[finalSystemName] && (currentMode === Modes.CREATING || oldSystemNameKey !== finalSystemName)) {
            if (!confirm(`A system named "${finalSystemName}" already exists. Overwrite it?`)) {
                // Revert data object name change before cancelling
                currentSystemData.systemName = oldSystemNameKey;
                currentSystemData.systemDescription = document.getElementById('systemDescriptionInput').value; // Revert desc too
                return; // User cancelled overwrite
            }
         }


        // Save the current data under the final name
        systems[finalSystemName] = currentSystemData;
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

        alert(`System "${finalSystemName}" saved successfully.`);

        // --- Post-Save Actions ---
        if (currentMode === Modes.CREATING) {
             // After successfully creating, switch to Browse mode for the new system
             currentMode = Modes.Browse;
             // Optionally reload the view for the newly saved system
             loadSavedSystem(finalSystemName); // Load it properly
        } else {
             // If editing, maybe exit edit mode or refresh views
              exitEditMode(); // Go back to Browse mode
        }
        // -----------------------

    } catch (error) {
        console.error("Error saving system to local storage:", error);
        alert("An error occurred while trying to save the system. Please check the console for details.");
         // Revert data object name change on error
         currentSystemData.systemName = oldSystemNameKey;
         currentSystemData.systemDescription = document.getElementById('systemDescriptionInput').value;
    }
    // -------------------------
}

/** Exit Edit Mode **/

function exitEditMode() {
    if (currentMode === Modes.CREATING) {
        if (confirm('Are you sure you want to cancel creating the new system? All unsaved changes will be lost.')) {
            currentMode = Modes.NAVIGATION;
            currentSystemData = null;
            // Clear the UI and return to navigation mode
            returnToHome();
        }
    } else {
      // Hide the edit form
      document.getElementById('systemEditForm').style.display = 'none';
  
      // Show the visualizations
      document.getElementById('visualization').style.display = 'block';
      document.getElementById('teamVisualization').style.display = 'block';
      document.getElementById('teamBreakdown').style.display = 'block';
  
      // Update the page title and description
      document.getElementById('pageTitle').innerText = currentSystemData.systemName;
      document.getElementById('systemDescription').innerText = currentSystemData.systemDescription || '';
      
      document.getElementById('organogramView').style.display = 'none';
      document.getElementById('engineerTableView').style.display = 'none';
      
      // Show the "Edit System" button
      document.querySelector('.edit-menu').style.display = 'block';
  
      loadSavedSystem(currentSystemData.systemName);    
      currentMode = Modes.BROWSING;
    }
}

/** 09/28 Worked on CreateNewSystem workflows **/
/** Updated function to handle "Create New Software System" button click **/
function createNewSystem() {
    currentMode = Modes.CREATING;

    // Default Senior Managers Data
    const defaultSeniorManagersData = [
        { seniorManagerId: 'srMgr1', seniorManagerName: 'Enter Sr. Manager Name Here' }
    ];

    // Default SDMs Data (with seniorManagerId)
    const defaultSDMsData = [
        { sdmId: 'sdm1', sdmName: 'Enter SDM Name Here', seniorManagerId: 'srMgr1' } // Added seniorManagerId
    ];

    // Default PMTs Data
    const defaultPMTsData = [
        { pmtId: 'pmt1', pmtName: 'Enter PMT Name Here' }
    ];

    // Default Teams Data (using new structure)
    const defaultTeamsData = [
        {
            teamId: 'team1', // Will be regenerated on save if needed, but useful for default service
            teamName: 'Enter Team Name Here',
            teamIdentity: 'Enter Team Identity Here',
            teamDescription: 'Enter Team Description Here...', // Added description field based on usage elsewhere
            fundedHeadcount: 1, // Example default
            buildersInSeats: 1, // Matches the single default engineer
            engineers: [ // Changed from engineerNames string to engineers array
                { name: 'Enter Engineer Name Here', level: 2 } // Example default engineer with level
            ],
            sdmId: 'sdm1', // Reference to the default SDM
            pmtId: 'pmt1'  // Reference to the default PMT
        }
    ];

    // Default Services Data
    const defaultServicesData = [
        {
            serviceName: 'Enter Service Name Here',
            serviceDescription: 'Enter Service Description Here...',
            owningTeamId: 'team1', // Reference to the default Team
            apis: [
                {
                    apiName: 'Enter API Name Here',
                    apiDescription: 'Enter API Description Here...',
                    dependentApis: []
                }
            ],
            serviceDependencies: [],
            platformDependencies: []
        }
    ];

    // Default System Data (including seniorManagers)
    const defaultSystemData = {
        systemName: '', // Start blank, user must enter in form
        systemDescription: '', // Start blank, user must enter in form
        seniorManagers: defaultSeniorManagersData, // Added
        sdms: defaultSDMsData,
        pmts: defaultPMTsData,
        teams: defaultTeamsData,
        services: defaultServicesData,
        platformDependencies: [], 
        yearlyInitiatives: []
    };

    // Assign to currentSystemData
    currentSystemData = defaultSystemData;

    // Clear the page title and description
    document.getElementById('pageTitle').innerText = 'Create New Software System';
    document.getElementById('systemDescription').innerText = 'Define the new system details, services, and teams below.';

    // Hide the menu and other sections
    document.querySelector('.menu').style.display = 'none';
    document.getElementById('visualization').style.display = 'none';
    document.getElementById('teamVisualization').style.display = 'none';
    document.getElementById('teamBreakdown').style.display = 'none';
    document.getElementById('serviceRelationshipsVisualization').style.display = 'none';
    document.getElementById('dependencyVisualization').style.display = 'none';
    document.getElementById('serviceDependenciesTable').style.display = 'none';
    document.querySelector('.edit-menu').style.display = 'none';
    document.getElementById('systemEditForm').style.display = 'none'; // Hide initially

    document.getElementById('organogramView').style.display = 'none';
    document.getElementById('engineerTableView').style.display = 'none';
    // Display the system information for editing using the standard edit mode function
    enterEditMode(true); // Pass true flag for creation mode
}

/** REVISED Return to Home - Hides Back Button Too */
function returnToHome() {
    console.log("Returning to home view (Clearing System)...");
    const wasSystemLoaded = !!currentSystemData; // Check if a system *was* loaded before clearing
    currentMode = Modes.NAVIGATION;
    currentSystemData = null; // Reset loaded system data

    // --- Hide ALL possible view sections ---
    const allViews = [
        'systemEditForm', 'visualization', 'teamVisualization', 'teamBreakdown',
        'serviceRelationshipsVisualization', 'dependencyVisualization', 'serviceDependenciesTable',
        'organogramView', 'engineerTableView', 'planningView' // Include planning view
    ];
    allViews.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.style.display = 'none';
    });
    // --- End Hide Views ---

    // --- Restore Top Elements to Default ---
    const pageTitleH1 = document.getElementById('pageTitle');
    const systemDescP = document.getElementById('systemDescription');
    const editMenu = document.querySelector('.edit-menu');
    const mainMenu = document.querySelector('.menu'); // The initial menu

    if(pageTitleH1) {
         pageTitleH1.innerText = "Architecture Visualization Tool"; // Default title
         pageTitleH1.style.display = 'block'; // Make visible
    }
    if(systemDescP) {
         systemDescP.innerText = "Load a previously saved system or create a new system..."; // Default text
         systemDescP.style.display = 'block'; // Make visible
    }
    // Hide edit menu, show main menu
    if (editMenu) editMenu.style.display = 'none';
    if (mainMenu) mainMenu.style.display = 'block'; // Show main load/create menu
     // --- End Restore Top ---


     // --- Hide BOTH Action Buttons ---
     const returnHomeBtn = document.getElementById('returnHomeButton');
     const backButton = document.getElementById('backToSystemViewButton'); // Get the Back button
     if(returnHomeBtn) returnHomeBtn.style.display = 'none'; // Hide on true home screen
     if(backButton) backButton.style.display = 'none'; // *** ADDED: Hide Back button too ***
     // -----------------------------


    // Clear any potential leftover popups (like the system list)
    const systemListDiv = document.getElementById('systemListDiv');
    if (systemListDiv) {
        document.body.removeChild(systemListDiv);
    }
    // Remove lingering tooltips
    d3.selectAll('.tooltip').remove();

    console.log("Home view displayed.");
}

function resetToDefaults() {
    if (confirm('This will erase all your saved systems and restore the default sample systems. Do you want to proceed?')) {
        // Clear the local storage for systems
        localStorage.removeItem(LOCAL_STORAGE_KEY);

        // Re-initialize with sample systems
        const systems = {
            'StreamView': sampleSystemDataStreamView,
            'ConnectPro': sampleSystemDataContactCenter
        };
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

        alert('Systems have been reset to defaults.');

        // Return to the home page
        returnToHome();
    }
}

function populateServiceSelection() {
    const serviceSelection = document.getElementById('serviceSelection');
    serviceSelection.innerHTML = ''; // Clear existing options

    // Add "All Services View" option
    let allServicesOption = document.createElement('option');
    allServicesOption.value = 'all';
    allServicesOption.text = 'All Services View';
    serviceSelection.appendChild(allServicesOption);

    // Add individual services
    currentSystemData.services.forEach(service => {
        let option = document.createElement('option');
        option.value = service.serviceName;
        option.text = service.serviceName;
        serviceSelection.appendChild(option);
    });
}

function getServiceDependencies(service, collectedServices = {}, visitedServices = {}) {
    if (!service || visitedServices[service.serviceName]) {
        return [];
    }
    visitedServices[service.serviceName] = true;
    collectedServices[service.serviceName] = service;

    // Recursively collect dependencies
    service.serviceDependencies.forEach(depName => {
        const depService = currentSystemData.services.find(s => s.serviceName === depName);
        getServiceDependencies(depService, collectedServices, visitedServices);
    });

    return Object.values(collectedServices);
}

function updateServiceVisualization() {
    const selectedService = document.getElementById('serviceSelection').value;

    // Ensure the service selection is populated with the latest data
    populateServiceSelection();
    
    if (selectedService === 'all') {
        generateServiceVisualization(currentSystemData.services, null); // No service is selected
    } else {
        // Find the selected service and its dependencies
        const selectedServiceData = currentSystemData.services.find(service => service.serviceName === selectedService);
        const relatedServices = getServiceDependencies(selectedServiceData);

        generateServiceVisualization(relatedServices, selectedService);
    }
}

function generateServiceVisualization(services, selectedServiceName) {
    let svg = d3.select('#serviceSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // Prepare nodes and links data
    let nodes = [];
    let links = [];
    let nodeMap = {};
   
    // Set SVG dimensions
    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    // Define node radius
    const radius = 20;
   
    // Create a color scale based on teams
    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = currentSystemData.teams.map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Map service names to services for quick lookup
    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    // Create nodes for services
    services.forEach(service => {
        let teamId = service.owningTeamId || 'unassigned';
        let nodeColor = teamColorScale(teamId);

        // Check if this is the selected service
        let isSelected = service.serviceName === selectedServiceName;

        nodes.push({
            id: service.serviceName,
            type: 'service',
            teamId: teamId,
            color: nodeColor,
            isSelected: isSelected
        });
        nodeMap[service.serviceName] = { id: service.serviceName, type: 'service' };
    });

    // Add platform dependencies as nodes
    services.forEach(service => {
        if (service.platformDependencies) {
            service.platformDependencies.forEach(platform => {
                if (!nodeMap[platform]) {
                    nodes.push({ id: platform, type: 'platform', color: '#a04040', isSelected: false }); // Add isSelected property
                    nodeMap[platform] = { id: platform, type: 'platform' };
                }
                // Link service to platform
                links.push({
                    source: service.serviceName,
                    target: platform,
                    type: 'platform-dependency'
                });
            });
        }
    });

    // Create links based on service dependencies
    services.forEach(service => {
        // Service dependencies
        service.serviceDependencies.forEach(dependency => {
            if (nodeMap[dependency]) {
                links.push({
                    source: service.serviceName,
                    target: dependency,
                    type: 'service-dependency'
                });
            }
        });
    });

    // Set up the simulation
    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 30));

    // **Corrected Node Creation and Attribute Setting**

    let node = svg.append('g')
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', d => d.isSelected ? 25 : 20) // Increase radius for selected node
        .attr('fill', d => d.color)
        .attr('stroke', d => d.isSelected ? 'red' : '#fff') // Change stroke color to red for selected node
        .attr('stroke-width', d => d.isSelected ? 4 : 2) // Increase stroke width for selected node
        .call(drag(simulation));

    // Add labels to nodes
    let labels = svg.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 0)
        .attr('dy', 4)
        .attr('text-anchor', 'middle')
        .text(d => d.id)
        .attr('fill', d => d.isSelected ? 'red' : 'black'); // Change text color to red for selected node

    // Tooltip
    let tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let info = '';
        if (d.type === 'service') {
            let service = serviceMap[d.id];
            let team = currentSystemData.teams.find(t => t.teamId === service.owningTeamId);
            info = `<strong>Service Name:</strong> ${service.serviceName}<br>
                    <strong>Description:</strong> ${service.serviceDescription}<br>
                    <strong>Team:</strong> ${team ? `${team.teamName} (${team.teamIdentity})` : 'Unassigned'}`;
        } else if (d.type === 'platform') {
            info = `<strong>Platform Dependency:</strong> ${d.id}`;
        }
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5);
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    // **Add links to the SVG after nodes are created**
    let link = svg.append('g')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-dasharray', d => {
            if (d.type === 'service-dependency') return '5,5';
            else if (d.type === 'platform-dependency') return '10,5';
            else return '1,0';
        })
        .attr('stroke-width', 2);

    // Add legend for teams
    let legendData = currentSystemData.teams.map(team => ({
        teamIdentity: team.teamIdentity,
        color: teamColorScale(team.teamId)
    }));

    let legend = d3.select('#serviceLegend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item');

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
}

//Create a function to populate the dropdown menu with available services.
function populateDependencyServiceSelection() {
    const serviceSelection = document.getElementById('dependencyServiceSelection');
    serviceSelection.innerHTML = ''; // Clear existing options

    // Add individual services
    currentSystemData.services.forEach(service => {
        let option = document.createElement('option');
        option.value = service.serviceName;
        option.text = service.serviceName;
        serviceSelection.appendChild(option);
    });
}

//We need to build a graph with nodes and links, ensuring that nodes are not duplicated and circular dependencies are handled.
//We use a breadth-first search (BFS) traversal to explore both upstream and downstream services, handling cycles by keeping track of visited services.
//We build nodes and links without duplicating nodes.
//Ensure the edges are defined in the correct direction (from upstream to downstream).
function buildDependencyGraph(serviceName) {
    const nodes = [];
    const links = [];
    const nodeMap = {};

    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    const queue = [];
    const visited = new Set();

    queue.push(serviceName);
    visited.add(serviceName);

    while (queue.length > 0) {
        const currentServiceName = queue.shift();
        const currentService = serviceMap[currentServiceName];

        if (!nodeMap[currentServiceName]) {
            nodes.push({ id: currentServiceName, type: 'service' });
            nodeMap[currentServiceName] = true;
        }

        // Process upstream dependencies
        currentService.serviceDependencies.forEach(depName => {
            if (!nodeMap[depName]) {
                nodes.push({ id: depName, type: 'service' });
                nodeMap[depName] = true;
            }
            // Edge from dependency to current service
            links.push({
                source: depName,
                target: currentServiceName,
                type: 'service-dependency',
            });
            if (!visited.has(depName)) {
                visited.add(depName);
                queue.push(depName);
            }
        });

        // Process platform dependencies
        if (currentService.platformDependencies) {
            currentService.platformDependencies.forEach(platform => {
                if (!nodeMap[platform]) {
                    nodes.push({ id: platform, type: 'platform' });
                    nodeMap[platform] = true;
                }
                // Edge from platform to current service
                links.push({
                    source: platform,
                    target: currentServiceName,
                    type: 'platform-dependency',
                });
            });
        }

        // Process downstream dependents
        currentSystemData.services.forEach(service => {
            if (service.serviceDependencies.includes(currentServiceName)) {
                const dependentName = service.serviceName;
                if (!nodeMap[dependentName]) {
                    nodes.push({ id: dependentName, type: 'service' });
                    nodeMap[dependentName] = true;
                }
                // Edge from current service to dependent
                links.push({
                    source: currentServiceName,
                    target: dependentName,
                    type: 'service-dependency',
                });
                if (!visited.has(dependentName)) {
                    visited.add(dependentName);
                    queue.push(dependentName);
                }
            }
        });
    }

    return { nodes, links };
}

//Create functions to build the data structure representing upstream and downstream dependencies.
function buildDependencyTree(serviceName) {
    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    // Recursive function to get upstream dependencies
    function getUpstream(service, visited = new Set()) {
        if (!service || visited.has(service.serviceName)) return null;
        visited.add(service.serviceName);

        let dependencies = [];
        service.serviceDependencies.forEach(depName => {
            const depService = serviceMap[depName];
            const upstreamNode = getUpstream(depService, visited);
            if (upstreamNode) {
                dependencies.push(upstreamNode);
            } else if (depService) {
                dependencies.push({ name: depService.serviceName, children: [] });
            }
        });

        return { name: service.serviceName, children: dependencies };
    }

    // Recursive function to get downstream dependencies
    function getDownstream(service, visited = new Set()) {
        if (!service || visited.has(service.serviceName)) return null;
        visited.add(service.serviceName);

        let dependents = [];
        currentSystemData.services.forEach(otherService => {
            if (otherService.serviceDependencies.includes(service.serviceName)) {
                const downstreamNode = getDownstream(otherService, visited);
                if (downstreamNode) {
                    dependents.push(downstreamNode);
                } else {
                    dependents.push({ name: otherService.serviceName, children: [] });
                }
            }
        });

        return { name: service.serviceName, children: dependents };
    }

    const rootService = serviceMap[serviceName];

    const upstreamTree = getUpstream(rootService);
    const downstreamTree = getDownstream(rootService);

    // Combine upstream and downstream trees
    const treeData = {
        name: rootService.serviceName,
        children: []
    };

    if (upstreamTree && upstreamTree.children.length > 0) {
        treeData.children.push({
            name: 'Upstream Dependencies',
            direction: 'upstream',
            children: upstreamTree.children
        });
    }

    if (downstreamTree && downstreamTree.children.length > 0) {
        treeData.children.push({
            name: 'Downstream Dependencies',
            direction: 'downstream',
            children: downstreamTree.children
        });
    }

    return treeData;
}

//The function uses a force-directed graph to display service dependencies, handling circular dependencies by linking back to existing nodes.
//Nodes represent services and platforms.
//Links represent dependencies, with arrowheads to indicate direction.
//The graph is interactive, with zoom/pan and node dragging.
//Labels are added to nodes, and tooltips provide additional information
function generateDependencyForceVisualization(selectedServiceName) {
    const svg = d3.select('#dependencySvg');
    svg.selectAll('*').remove(); // Clear existing content

    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    const { nodes, links } = buildDependencyGraph(selectedServiceName);

    // Assign index to links
    links.forEach((link, index) => {
        link.index = index;
    });

    // Create a color scale
    const color = d3.scaleOrdinal()
        .domain(['service', 'platform'])
        .range(['#1f77b4', '#ff7f0e']); // Customize colors as needed

    // Create simulation
    const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collide', d3.forceCollide(40))
        .on('tick', ticked);

    // Add zoom and pan
    const zoom = d3.zoom()
        .scaleExtent([0.1, 5])
        .on('zoom', (event) => {
            container.attr('transform', event.transform);
        });

    svg.call(zoom);

    // Create container for nodes and links
    const container = svg.append('g');

    // Define arrowheads
    svg.append('defs').selectAll('marker')
        .data(['service-dependency', 'platform-dependency'])
        .enter().append('marker')
        .attr('id', d => `arrow-${d}`)
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 25) // Adjusted for larger arrowhead
        .attr('refY', 0)
        .attr('markerWidth', 10) // Increased size
        .attr('markerHeight', 10) // Increased size
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#999');

    // Define arrowheads for legend
    svg.append('defs').selectAll('marker')
        .data(['arrow-service-dependency', 'arrow-platform-dependency'])
        .enter().append('marker')
        .attr('id', d => d)
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 12)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#999');

    // Add links
    const link = container.append('g')
        .attr('stroke', '#999')
        .attr('stroke-opacity', 0.6)
        .selectAll('line')
        .data(links)
        .enter().append('line')
        .attr('stroke-width', 2)
        .attr('marker-end', d => `url(#arrow-${d.type})`)
        .attr('stroke-dasharray', d => {
            if (d.type === 'platform-dependency') return '5,5';
            else return '0';
        });

    // Add nodes
    const node = container.append('g')
        .attr('stroke', '#fff')
        .selectAll('circle')
        .data(nodes)
        .enter().append('circle')
        .attr('r', d => d.id === selectedServiceName ? 15 : 10)
        .attr('fill', d => {
            if (d.id === selectedServiceName) return 'red'; // Highlight selected service
            else if (d.type === 'service') return color('service');
            else return color('platform');
        })
        .attr('stroke-width', d => d.id === selectedServiceName ? 3 : 1.5)
        .call(drag(simulation));

    // Add labels
    const label = container.append('g')
        .selectAll('text')
        .data(nodes)
        .enter().append('text')
        .attr('dy', -15)
        .attr('text-anchor', 'middle')
        .text(d => d.id)
        .attr('font-weight', d => d.id === selectedServiceName ? 'bold' : 'normal')
        .attr('fill', d => d.id === selectedServiceName ? 'red' : 'black');

    // Tooltip
    const tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    // Variables for highlighting
    let highlightedNodes = new Set();
    let highlightedLinks = new Set();

    // Node mouseover event
    node.on('mouseover', function(event, d) {
        let info = '';
        if (d.type === 'service') {
            const service = currentSystemData.services.find(s => s.serviceName === d.id);
            if (service) {
                // Fetch upstreams and downstreams
                const upstreams = service.serviceDependencies;
                const downstreams = currentSystemData.services
                    .filter(s => s.serviceDependencies.includes(service.serviceName))
                    .map(s => s.serviceName);
                // Fetch platform dependencies
                const platformDeps = service.platformDependencies || [];
    
                // Build the tooltip content
                info = `<strong>Service Name:</strong> ${service.serviceName}<br>`;
                info += `<strong>Upstreams:</strong> ${upstreams.length > 0 ? upstreams.join(', ') : 'None'}<br>`;
                info += `<strong>Downstreams:</strong> ${downstreams.length > 0 ? downstreams.join(', ') : 'None'}<br>`;
                info += `<strong>Platform Dependencies:</strong> ${platformDeps.length > 0 ? platformDeps.join(', ') : 'None'}`;
            }
        } else if (d.type === 'platform') {
            info = `<strong>Platform Dependency:</strong> ${d.id}`;
        }
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    
        // Highlight connected nodes and links
        highlightConnected(d);
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    
        // Remove highlighting
        unhighlight();
    });

    // Function to highlight connected nodes and links
    function highlightConnected(d) {
        // Clear previous highlights
        highlightedNodes.clear();
        highlightedLinks.clear();

        // Add the hovered node
        highlightedNodes.add(d.id);

        // Highlight upstream nodes and links
        links.forEach(link => {
            if (link.target.id === d.id) {
                highlightedNodes.add(link.source.id);
                highlightedLinks.add(link.index);
            }
        });

        // Highlight downstream nodes and links
        links.forEach(link => {
            if (link.source.id === d.id) {
                highlightedNodes.add(link.target.id);
                highlightedLinks.add(link.index);
            }
        });

        // Update node styles
        node.style('opacity', n => highlightedNodes.has(n.id) ? 1 : 0.1);
        label.style('opacity', n => highlightedNodes.has(n.id) ? 1 : 0.1);

        // Update link styles
        link.style('opacity', l => highlightedLinks.has(l.index) ? 1 : 0.1);
    }

    // Function to remove highlighting
    function unhighlight() {
        node.style('opacity', 1);
        label.style('opacity', 1);
        link.style('opacity', 1);
    }

    // Add legend
    const legendData = [
        { label: 'Selected Service', color: 'red', shape: 'circle' },
        { label: 'Service', color: color('service'), shape: 'circle' },
        { label: 'Platform', color: color('platform'), shape: 'circle' },
        { label: 'Service Dependency', color: '#999', type: 'line', marker: 'arrow-service-dependency', dash: '0' },
        { label: 'Platform Dependency', color: '#999', type: 'line', marker: 'arrow-platform-dependency', dash: '5,5' }
    ];

    // Create a legend container
    const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', `translate(${20},${20})`);

    // Add legend items
    legendData.forEach((item, index) => {
        const legendRow = legend.append('g')
            .attr('transform', `translate(0, ${index * 20})`);

        if (item.shape === 'circle') {
            // Draw circle
            legendRow.append('circle')
                .attr('r', 6)
                .attr('fill', item.color)
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .attr('cx', 0)
                .attr('cy', 0);
        } else if (item.type === 'line') {
            // Draw line with arrow
            legendRow.append('line')
                .attr('x1', -10)
                .attr('y1', 0)
                .attr('x2', 10)
                .attr('y2', 0)
                .attr('stroke', item.color)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', item.dash)
                .attr('marker-end', `url(#${item.marker})`);
        }

        // Add text
        legendRow.append('text')
            .attr('x', 20)
            .attr('y', 5)
            .text(item.label)
            .attr('text-anchor', 'start')
            .attr('font-size', '12px');
    });

    // Tick function
    function ticked() {
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);

        node
            .attr('cx', d => d.x)
            .attr('cy', d => d.y);

        label
            .attr('x', d => d.x)
            .attr('y', d => d.y - 15);
    }

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }
}


//Create a function to update the visualization when a new service is selected.
function updateDependencyVisualization() {
    const selectedServiceName = document.getElementById('dependencyServiceSelection').value;
    // Ensure the service selection is populated with the latest data
    populateDependencyServiceSelection();
    generateDependencyForceVisualization(selectedServiceName); //forced dependency works best
}


//Create a function to add the legend to the SVG.
//Legend Items: The legend displays the meanings of node colors, shapes, and edge styles.
//Arrowhead Definition: An arrowhead is defined for use in the legend.
function addDependencyLegend(svg) {
    const legendData = [
        { label: 'Selected Service', color: 'red', shape: 'rect' },
        { label: 'Service', color: '#1f77b4', shape: 'rect' },
        { label: 'Platform', color: '#ff7f0e', shape: 'rect' },
        { label: 'Service Dependency', style: 'stroke: #333; stroke-width: 2px;', arrowhead: true },
        { label: 'Platform Dependency', style: 'stroke: #333; stroke-width: 2px; stroke-dasharray: 5,5;', arrowhead: true },
    ];

    const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', 'translate(20, 20)');

    legendData.forEach((item, index) => {
        const legendItem = legend.append('g')
            .attr('transform', `translate(0, ${index * 25})`);

        if (item.shape === 'rect') {
            legendItem.append('rect')
                .attr('x', 0)
                .attr('y', -10)
                .attr('width', 20)
                .attr('height', 20)
                .attr('style', `fill: ${item.color}; stroke: #fff; stroke-width: 1.5px;`);
        } else {
            // Draw line
            const line = legendItem.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', 20)
                .attr('y2', 0)
                .attr('style', item.style);

            if (item.arrowhead) {
                line.attr('marker-end', 'url(#arrowhead)');
            }
        }

        legendItem.append('text')
            .attr('x', 30)
            .attr('y', 5)
            .text(item.label)
            .attr('text-anchor', 'start')
            .attr('font-size', '12px');
    });

    // Define arrowhead for legend lines
    svg.append('defs').append('marker')
        .attr('id', 'arrowhead')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 10)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#333');
}

function generateServiceDependenciesTable() {
    const tbody = document.querySelector('#serviceDependenciesTable tbody');
    tbody.innerHTML = ''; // Clear existing content

    currentSystemData.services.forEach(service => {
        const row = document.createElement('tr');

        // Service Name
        const nameCell = document.createElement('td');
        nameCell.textContent = service.serviceName;
        row.appendChild(nameCell);

        // Description
        const descCell = document.createElement('td');
        descCell.textContent = service.serviceDescription;
        row.appendChild(descCell);

        // Owning Team
        const team = currentSystemData.teams.find(t => t.teamId === service.owningTeamId);
        const teamCell = document.createElement('td');
        teamCell.textContent = team ? team.teamName : 'Unassigned';
        row.appendChild(teamCell);

        // Upstream Dependencies (Services Depended On)
        const upstreamServices = service.serviceDependencies;
        const upstreamCell = document.createElement('td');
        upstreamCell.textContent = upstreamServices.length > 0 ? upstreamServices.join(', ') : 'None';
        row.appendChild(upstreamCell);

        // Platform Dependencies
        const platformDependencies = service.platformDependencies || [];
        const platformCell = document.createElement('td');
        platformCell.textContent = platformDependencies.length > 0 ? platformDependencies.join(', ') : 'None';
        row.appendChild(platformCell);

        // Downstream Dependencies (Services That Depend On This Service)
        const downstreamServices = currentSystemData.services
            .filter(s => s.serviceDependencies.includes(service.serviceName))
            .map(s => s.serviceName);
        const downstreamCell = document.createElement('td');
        downstreamCell.textContent = downstreamServices.length > 0 ? downstreamServices.join(', ') : 'None';
        row.appendChild(downstreamCell);

        tbody.appendChild(row);
    });
}

/** NEW Validation function to check engineer assignments */
function validateEngineerAssignments() {
    if (!currentSystemData || !currentSystemData.teams) {
        console.error("Validation skipped: No team data loaded.");
        return true; // Allow saving if no data? Or return false? Safer to allow.
    }

    const engineerAssignments = new Map(); // Key: engineerName, Value: Set<teamId>
    let isValid = true;
    let errorMessages = [];

    currentSystemData.teams.forEach(team => {
        if (!team || !team.teamId) return; // Skip invalid team entries
        (team.engineers || []).forEach(engineer => {
            if (!engineer || !engineer.name) return; // Skip invalid engineer entries
            const name = engineer.name;
            if (!engineerAssignments.has(name)) {
                engineerAssignments.set(name, new Set());
            }
            engineerAssignments.get(name).add(team.teamId);
        });
    });

    // Check for overallocations
    engineerAssignments.forEach((assignedTeamIds, engineerName) => {
        if (assignedTeamIds.size > 1) {
            isValid = false;
            const teamNames = Array.from(assignedTeamIds).map(tId => {
                const team = currentSystemData.teams.find(t => t.teamId === tId);
                return team ? (team.teamName || team.teamIdentity) : tId;
            }).join(', ');
            errorMessages.push(`Engineer "${engineerName}" is assigned to multiple teams: ${teamNames}.`);
        }
    });

    if (!isValid) {
        alert("Validation Error: Cannot save changes.\n\n" + errorMessages.join("\n"));
    }

    return isValid;
}

/** Updated Save System Changes (used by Save All/Save Team) - Add Validation **/
function saveSystemChanges() {
    // Get updated system name and description (if called directly, maybe redundant)
    const systemNameInput = document.getElementById('systemNameInput');
    const systemDescriptionTextarea = document.getElementById('systemDescriptionInput');
    if (systemNameInput && systemDescriptionTextarea) { // Check if elements exist
         currentSystemData.systemName = systemNameInput.value.trim();
         currentSystemData.systemDescription = systemDescriptionTextarea.value.trim();
    } else if (currentMode === Modes.CREATING || currentMode === Modes.EDITING) {
         // If called during saveAll/saveTeam, these might not be the source of truth anymore
         console.warn("saveSystemChanges called without direct access to system name/desc inputs. Assuming currentSystemData properties are up-to-date.");
    }


    if (!currentSystemData.systemName && (currentMode === Modes.CREATING || currentMode === Modes.EDITING)) {
        alert('System name cannot be empty.');
        return;
    }

    // *** Add validation before saving to local storage ***
    if (!validateEngineerAssignments()) {
        return; // Stop saving if validation fails
    }
    // *********************************************************

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    systems[currentSystemData.systemName] = currentSystemData; // Use potentially updated name as key
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    console.log('System changes saved to local storage.'); // Changed alert to console log

    // Note: UI updates are typically handled by the calling function (like saveTeamChanges or exitEditMode)
}

// Generate a unique ID for new teams
function generateUniqueId() {
    return 'team-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
}

function deleteSystem() {
    if (currentSystemData && currentSystemData.systemName) {
        // Confirm deletion
        if (confirm(`Are you sure you want to delete the system "${currentSystemData.systemName}"? This action cannot be undone.`)) {
            // Remove from local storage
            const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
            delete systems[currentSystemData.systemName];
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

            // Optionally, you might want to remove any other related data

            // Clear current system data and reset the mode
            const deletedSystemName = currentSystemData.systemName; // Store the name before clearing
            currentSystemData = null;
            currentMode = Modes.NAVIGATION;

            // Clear the UI and display the main menu
            returnToHome();

            // Notify the user
            alert(`The system "${deletedSystemName}" has been deleted.`);
        }
    } else {
        alert('No system is currently loaded.');
    }
}

/** REVISED Builds hierarchical data for Organogram - Adds Away-Team Info */
function buildHierarchyData() {
    console.log("Building hierarchy data with away-team info...");
    if (!currentSystemData) return null;

    // Create maps for efficient lookup
    const sdmMap = new Map((currentSystemData.sdms || []).map(sdm => [sdm.sdmId, { ...sdm, children: [], type: 'sdm' }])); // Add type
    const srMgrMap = new Map((currentSystemData.seniorManagers || []).map(sr => [sr.seniorManagerId, { ...sr, children: [], type: 'srMgr' }])); // Add type

    // Nest SDMs under Senior Managers
    sdmMap.forEach(sdm => {
        if (sdm.seniorManagerId && srMgrMap.has(sdm.seniorManagerId)) {
            srMgrMap.get(sdm.seniorManagerId).children.push(sdm);
        } else {
            // Handle SDMs without a valid Senior Manager
            const unassignedSrMgrKey = 'unassigned-sr-mgr';
            if (!srMgrMap.has(unassignedSrMgrKey)) {
                srMgrMap.set(unassignedSrMgrKey, { seniorManagerId: unassignedSrMgrKey, seniorManagerName: 'Unassigned Senior Manager', children: [], type: 'srMgr' });
            }
            if(sdm && sdm.sdmId) srMgrMap.get(unassignedSrMgrKey).children.push(sdm);
        }
    });

    // Nest Teams under SDMs
    (currentSystemData.teams || []).forEach(team => {
        const awayTeamCount = team.awayTeamMembers?.length ?? 0; // Calculate away team count
        const sourceSummary = getSourceSummary(team.awayTeamMembers); // Get source summary

        const teamNode = {
            name: team.teamIdentity || team.teamName || 'Unnamed Team',
            type: 'team',
            details: `BIS: ${team.engineers?.length ?? 0} / Funded: ${team.fundedHeadcount ?? 'N/A'}`, // Show Team BIS vs Funded here
            awayTeamCount: awayTeamCount, // Store away team count
            awaySourceSummary: sourceSummary, // Store source summary
            children: (team.engineers || []).map(eng => ({
                name: `${eng.name || 'Unnamed'} (L${eng.level ?? '?'})`,
                type: 'engineer'
            }))
        };

        if (team.sdmId && sdmMap.has(team.sdmId)) {
            sdmMap.get(team.sdmId).children.push(teamNode);
        } else {
            // Handle Teams without a valid SDM
            const unassignedSdmKey = 'unassigned-sdm';
            if (!sdmMap.has(unassignedSdmKey)) {
                sdmMap.set(unassignedSdmKey, { sdmId: unassignedSdmKey, sdmName: 'Unassigned SDM', children: [], type: 'sdm' });
                // Add this unassigned SDM group under the unassigned Sr Mgr group
                const unassignedSrMgrKey = 'unassigned-sr-mgr';
                if (!srMgrMap.has(unassignedSrMgrKey)) {
                     srMgrMap.set(unassignedSrMgrKey, { seniorManagerId: unassignedSrMgrKey, seniorManagerName: 'Unassigned Senior Manager', children: [], type: 'srMgr' });
                }
                srMgrMap.get(unassignedSrMgrKey).children.push(sdmMap.get(unassignedSdmKey));
            }
            if(team && team.teamId) sdmMap.get(unassignedSdmKey).children.push(teamNode);
        }
    });

    // Define the root node
    const root = {
        name: currentSystemData.systemName || 'Organization',
        type: 'root',
        children: Array.from(srMgrMap.values()) // Use Sr Mgrs as top-level children
    };

    console.log("Finished building hierarchy data.");
    return root;
}

/** REVISED Generates the Organogram using HTML structure - Displays Away-Team Annotation */
/** REVISED Generates the Organogram using HTML structure - Fixes ReferenceError */
function generateOrganogram() {
    console.log("Generating Organogram HTML...");
    const hierarchicalData = buildHierarchyData(); // Get data with away-team info
    const container = document.getElementById('organogramContent');
    if (!hierarchicalData || !container) {
        console.error("No data or container for organogram HTML.");
        if(container) container.innerHTML = '<p style="color: red;">Could not generate organogram data.</p>';
        return;
    }
    container.innerHTML = ''; // Clear previous content
    container.style.fontFamily = 'Arial, sans-serif'; // Ensure consistent font

    // Recursive function to build nested HTML
    function buildHtmlLevel(node, level) {
        if (!node) return '';

        // Indentation and Styling
        let html = `<div class="org-level-${level}" style="margin-left: ${level * 25}px; margin-bottom: 5px; padding: 3px 5px; border-left: 2px solid #eee; position: relative;">`;
        let nodeContent = '';
        let nodeStyle = '';
        let detailsStyle = 'font-size: 0.8em; color: #555; margin-left: 5px;';

        // Define content and style based on node type
        switch(node.type) {
            case 'root':
                nodeContent = `<strong>System: ${node.name || 'N/A'}</strong>`;
                nodeStyle = 'font-size: 1.2em; color: #333;';
                break;
            case 'srMgr':
                 nodeContent = `<strong title="${node.seniorManagerId || ''}">Sr. Manager: ${node.seniorManagerName || node.name || 'N/A'}</strong>`;
                 nodeStyle = 'font-size: 1.1em; color: #0056b3;';
                break;
            case 'sdm':
                 nodeContent = `<strong title="${node.sdmId || ''}">SDM: ${node.sdmName || node.name || 'N/A'}</strong>`;
                 nodeStyle = 'color: #007bff;';
                break;
            case 'team':
                // *** CORRECTED LINE: Removed title attribute using undefined 'team' variable ***
                nodeContent = `<span style="color: #17a2b8;">Team: ${node.name || 'N/A'}</span> <span style="${detailsStyle}">(${node.details || ''})</span>`;
                // *****************************************************************************
                // Add Away-Team Annotation
                if (node.awayTeamCount > 0) {
                    const awaySourceText = node.awaySourceSummary || 'Source Unknown';
                    // Add tooltip to the annotation itself
                    const annotation = ` <span style="color: #dc3545; font-style: italic; font-size: 0.9em;" title="Away-Team Sources: ${awaySourceText}">(+${node.awayTeamCount} Away)</span>`;
                    nodeContent += annotation;
                }
                break;
            case 'engineer':
                nodeContent = `<span style="font-size: 0.9em;">${node.name || 'N/A'}</span>`;
                break;
            default:
                nodeContent = `<strong>${node.name || 'Group'}</strong>`;
                nodeStyle = 'color: #6c757d;';
        }

        // Apply style to a wrapper span for the main content
        html += `<span style="${nodeStyle}">${nodeContent}</span>`;

        // Recursively add children (excluding engineers directly under teams)
        if (node.children && node.children.length > 0 && node.type !== 'team') {
            node.children.forEach(child => {
                if (!child.type) { /* ... infer type ... */
                    if (level === 0) child.type = 'srMgr'; else if (level === 1) child.type = 'sdm'; else if (level === 2) child.type = 'team'; else if (level === 3 && node.type === 'team') child.type = 'engineer';
                }
                if (child.type !== 'engineer') { html += buildHtmlLevel(child, level + 1); }
            });
        }
        // Optional: Explicitly list engineers under team (currently commented out)
        /* else if (node.type === 'team' && node.children && node.children.length > 0) { ... } */

        html += `</div>`;
        return html;
    } // --- End buildHtmlLevel ---

    // Start building from the root (level 0)
    container.innerHTML = buildHtmlLevel(hierarchicalData, 0);
    console.log("Finished generating Organogram HTML (v2 - Fix).");
}

// Global state for engineer table sorting
let engineerSortState = { key: 'name', ascending: true };

/** Generates the HTML table for engineers */
/** REVISED Generates the HTML table for engineers - Adds Row Counter & Away-Team Indicator */
function generateEngineerTable() {
    console.log("Generating Engineer Table with Counter & Away Indicator..."); // Log start

    // --- Get Table Elements ---
    const engineerTableView = document.getElementById('engineerTableView');
    const table = document.getElementById('engineerTable');
    const tableHead = table?.querySelector('thead'); // Get the thead
    const tableBody = table?.querySelector('tbody');
    const tableFoot = table?.querySelector('tfoot'); // Get tfoot (though not directly used here)
    const heading = document.getElementById('engineerTableHeading');

    // --- Basic Data & Element Checks ---
    if (!currentSystemData || !currentSystemData.teams) { /* ... no change ... */
        console.error("Cannot generate engineer table: No system or team data loaded.");
        if(heading) heading.innerText = 'Engineer Resource List (Error: No Data)';
        if(tableBody) tableBody.innerHTML = '';
        return;
     }
    if (!table || !tableHead || !tableBody || !heading) { /* ... no change ... */
         console.error("Cannot generate engineer table: Required HTML elements not found (table, thead, tbody, or heading).");
         if(engineerTableView) engineerTableView.style.display = 'none';
         return;
     }
    tableBody.innerHTML = ''; // Clear existing rows

    // --- 1. Update Column Headers (Add '#' column) ---
    const headerRow = tableHead.querySelector('tr');
    headerRow.innerHTML = ''; // Clear existing headers

    // Define headers including the new '#' column
    const headersConfig = [
        { text: '#', title: 'Row Number' }, // NEW Counter Column
        { text: 'Engineer Name', title: 'Name of the engineer. (Away) indicates an away-team resource.', key: 'name'},
        { text: 'Level', title: 'Skill level of the engineer (L1-L5).', key: 'level'},
        { text: 'Team Name', title: 'The team the engineer is currently assigned to.', key: 'teamName'},
        { text: 'SDM Name', title: 'Software Development Manager for the assigned team.', key: 'sdmName'},
        { text: 'Senior Manager Name', title: 'Senior Manager overseeing the SDM.', key: 'srMgrName'}
    ];

    headersConfig.forEach(config => {
        const th = document.createElement('th');
        th.textContent = config.text;
        th.title = config.title;
        th.style.border = '1px solid #ccc';
        th.style.padding = '8px';
        th.style.textAlign = 'left';
        th.style.backgroundColor = '#f2f2f2';
        th.style.position = 'sticky';
        th.style.top = '0';
        th.style.zIndex = '1';
        // Add sort key and cursor pointer if defined
        if (config.key) {
            th.setAttribute('data-sort-key', config.key);
            th.style.cursor = 'pointer';
        }
        headerRow.appendChild(th);
    });
     // --- End Header Update ---

    // --- 2. Calculate System-Wide Totals (No change from previous step) ---
    let totalFundedHC = 0;
    let totalTeamBIS = 0;
    let totalAwayTeamBIS = 0;
    let totalEffectiveBIS = 0;
    let engineerListData = [];

    const sdmsMap = new Map((currentSystemData.sdms || []).map(s => [s.sdmId, s]));
    const srMgrsMap = new Map((currentSystemData.seniorManagers || []).map(s => [s.seniorManagerId, s]));

    currentSystemData.teams.forEach(team => {
        const currentFunded = team.fundedHeadcount ?? 0;
        const currentTeamBIS = team.engineers?.length ?? 0;
        const currentAwayTeamBIS = team.awayTeamMembers?.length ?? 0;

        totalFundedHC += currentFunded;
        totalTeamBIS += currentTeamBIS;
        totalAwayTeamBIS += currentAwayTeamBIS;
        totalEffectiveBIS += (currentTeamBIS + currentAwayTeamBIS);

        // Add regular engineers to list
        (team.engineers || []).forEach(eng => { /* ... no change ... */
             if (!eng || !eng.name) return;
             const sdm = team.sdmId ? sdmsMap.get(team.sdmId) : null;
             const srMgr = sdm ? srMgrsMap.get(sdm.seniorManagerId) : null;
             engineerListData.push({
                 name: eng.name, level: eng.level ?? 'N/A',
                 teamName: team.teamName || team.teamIdentity || 'N/A',
                 sdmName: sdm ? sdm.sdmName : 'N/A', srMgrName: srMgr ? srMgr.seniorManagerName : 'N/A',
                 isAwayTeam: false // Explicitly false for regular members
             });
        });
        // Add away team members to list
        (team.awayTeamMembers || []).forEach(awayEng => { /* ... no change ... */
              if (!awayEng || !awayEng.name) return;
              const sdm = team.sdmId ? sdmsMap.get(team.sdmId) : null;
              const srMgr = sdm ? srMgrsMap.get(sdm.seniorManagerId) : null;
              engineerListData.push({
                  name: awayEng.name, level: awayEng.level ?? 'N/A',
                  teamName: team.teamName || team.teamIdentity || 'N/A', // Assigned team
                  sdmName: sdm ? sdm.sdmName : 'N/A', srMgrName: srMgr ? srMgr.seniorManagerName : 'N/A',
                  isAwayTeam: true, // Flag as away team
                  sourceTeam: awayEng.sourceTeam || 'Unknown Source' // Include source
              });
        });
    });

    const totalHiringGap = totalFundedHC - totalTeamBIS;
    // --- End Total Calculations ---

    // --- 3. Update Heading Text (No change from previous step) ---
    heading.innerText = `Engineer Resource List (Funded: ${totalFundedHC} | Team BIS: ${totalTeamBIS} | Away BIS: ${totalAwayTeamBIS} | Effective BIS: ${totalEffectiveBIS} | Hiring Gap: ${totalHiringGap})`;
    heading.style.color = totalHiringGap < 0 ? 'blue' : (totalHiringGap > 0 ? 'darkorange' : 'green');
    heading.title = `Finance Approved Funding: ${totalFundedHC}\nActual Team Members (BIS): ${totalTeamBIS}\nAway-Team Members: ${totalAwayTeamBIS}\nTotal Effective Capacity (Team + Away): ${totalEffectiveBIS}\nHiring Gap (Funded - Team BIS): ${totalHiringGap}`;
    // --- End Heading Update ---

    // --- 4. Sorting (No change from previous step) ---
    engineerListData.sort((a, b) => { /* ... no changes ... */
        const key = engineerSortState.key;
        const ascending = engineerSortState.ascending;
        let valA = a[key];
        let valB = b[key];
        if (key === 'level') {
           valA = (typeof valA === 'number') ? valA : -1;
           valB = (typeof valB === 'number') ? valB : -1;
           return ascending ? valA - valB : valB - valA;
        }
        valA = (valA || '').toString().toLowerCase();
        valB = (valB || '').toString().toLowerCase();
        if (valA < valB) return ascending ? -1 : 1;
        if (valA > valB) return ascending ? 1 : -1;
        return 0;
     });
    // --- End Sorting ---

    // --- 5. Populate Table Body (Add counter and away indicator) ---
    let rowCounter = 1; // Initialize counter
    engineerListData.forEach(engData => {
        let row = tableBody.insertRow();

        // NEW: Insert Counter Cell
        const counterCell = row.insertCell();
        counterCell.textContent = rowCounter++;
        counterCell.style.textAlign = 'center';
        counterCell.style.fontSize = '0.9em';
        counterCell.style.color = '#666';

        // Engineer Name Cell (with Away indicator)
        const nameCell = row.insertCell();
        let nameDisplay = engData.name;
        if (engData.isAwayTeam) {
            nameDisplay = `(Away) ${engData.name}`; // Add prefix
            nameCell.title = `Away-Team member from: ${engData.sourceTeam}`; // Add tooltip
            nameCell.style.fontStyle = 'italic'; // Style away team members
            nameCell.style.color = '#0056b3'; // Example different color
        }
        nameCell.textContent = nameDisplay;

        // Other Cells (no change in logic)
        row.insertCell().textContent = engData.level;
        row.insertCell().textContent = engData.teamName;
        row.insertCell().textContent = engData.sdmName;
        row.insertCell().textContent = engData.srMgrName;
    });
    // --- End Populate Table ---

    // --- 6. Add Sorting Click Handlers (Update sort indicators) ---
    document.querySelectorAll('#engineerTable th[data-sort-key]').forEach(th => {
        const handler = (event) => handleSortClick(event);
        th.removeEventListener('click', th.__sortHandler); // Use stored handler reference
        th.addEventListener('click', handler);
        th.__sortHandler = handler; // Store handler reference

        // Update sort indicator
        const key = th.getAttribute('data-sort-key');
        let indicator = ' \u2195'; // Default: Up/Down arrow
        // Clear any existing indicator before adding new one
        let currentText = th.textContent.replace(/ [\u2195\u25B2\u25BC]/g, '');
        if (key === engineerSortState.key) {
            indicator = engineerSortState.ascending ? ' \u25B2' : ' \u25BC'; // Up or Down arrow
        }
        th.textContent = currentText + indicator;
    });
    // --- End Sorting Handlers ---
    console.log("Finished generating Engineer Table with counter & away indicator."); // Log end
}

// Keep handleSortClick, showOrganogramView, showEngineerTableView functions as they were.
// Make sure buildHierarchyData also still exists.

/** Handles clicking on sortable table headers */
function handleSortClick(event) {
    const key = event.target.getAttribute('data-sort-key');
    if (!key) return;

    if (engineerSortState.key === key) {
        engineerSortState.ascending = !engineerSortState.ascending; // Toggle direction
    } else {
        engineerSortState.key = key; // Change sort key
        engineerSortState.ascending = true; // Default to ascending
    }
    generateEngineerTable(); // Re-generate table with new sort order
}


/** Shows the Organogram View */
function showOrganogramView() {
    // Hide other views
    document.getElementById('visualization').style.display = 'none';
    document.getElementById('teamVisualization').style.display = 'none';
    document.getElementById('teamBreakdown').style.display = 'none';
    document.getElementById('serviceRelationshipsVisualization').style.display = 'none';
    document.getElementById('dependencyVisualization').style.display = 'none';
    document.getElementById('serviceDependenciesTable').style.display = 'none';
    document.getElementById('systemEditForm').style.display = 'none';
    document.getElementById('engineerTableView').style.display = 'none'; // Hide engineer table

    // Generate and show organogram
    generateOrganogram();
    document.getElementById('organogramView').style.display = 'block';
    document.querySelector('.edit-menu').style.display = 'block'; // Keep view buttons visible
}

/** Shows the Engineer Table View */
function showEngineerTableView() {
    // Hide other views
    document.getElementById('visualization').style.display = 'none';
    document.getElementById('teamVisualization').style.display = 'none';
    document.getElementById('teamBreakdown').style.display = 'none';
    document.getElementById('serviceRelationshipsVisualization').style.display = 'none';
    document.getElementById('dependencyVisualization').style.display = 'none';
    document.getElementById('serviceDependenciesTable').style.display = 'none';
    document.getElementById('systemEditForm').style.display = 'none';
    document.getElementById('organogramView').style.display = 'none'; // Hide organogram

    // Generate and show engineer table
    generateEngineerTable(); // Generate with default sort
    document.getElementById('engineerTableView').style.display = 'block';
    document.querySelector('.edit-menu').style.display = 'block'; // Keep view buttons visible
}

/*** Next sections is code for the Planning Feature **/

/** Handles changes to the 'Protected' checkbox in the planning table */
function handleProtectedChange(event) {
    const checkbox = event.target;
    const initiativeId = checkbox.getAttribute('data-initiative-id');
    const isChecked = checkbox.checked;

    if (!initiativeId) {
        console.error("Could not find initiative ID on checkbox:", checkbox);
        return;
    }

    // Find the initiative in the main data array
    const initiative = currentSystemData.yearlyInitiatives.find(init => init.initiativeId === initiativeId);

    if (initiative) {
        // Update the data model
        initiative.isProtected = isChecked;
        console.log(`Updated 'isProtected' for initiative ${initiativeId} to ${isChecked}`);

        // Re-generate the table to reflect the sort change
        generatePlanningTable();
    } else {
        console.error("Could not find initiative data for ID:", initiativeId);
    }
}

/** Stores the ID of the row being dragged */
let draggedInitiativeId = null;
let draggedRowElement = null; // Store the element itself for styling

/** REVISED Handles the start of a drag operation - Check Protection */
function handleDragStart(event) {
    const initiativeId = event.target.getAttribute('data-initiative-id');
    const initiative = currentSystemData.yearlyInitiatives.find(init => init.initiativeId === initiativeId);

    // Double-check: Do not allow dragging protected items
    if (!initiative || initiative.isProtected) {
        console.log(`Preventing drag start for protected or invalid item: ${initiativeId}`);
        event.preventDefault(); // Stop the drag operation before it starts
        return;
    }

    draggedInitiativeId = initiativeId; // Store the ID of the item being dragged
    draggedRowElement = event.target; // Store the element itself for styling
    event.dataTransfer.setData('text/plain', draggedInitiativeId);
    event.dataTransfer.effectAllowed = 'move';

    // Add visual feedback (defer slightly)
    setTimeout(() => {
        if(draggedRowElement) draggedRowElement.classList.add('dragging');
    }, 0);
    console.log(`Drag Start: ${draggedInitiativeId}`);
}

/** Handles dragging over a potential drop target */
function handleDragOver(event) {
    event.preventDefault(); // Necessary to allow dropping
    event.dataTransfer.dropEffect = 'move';

    const targetRow = event.target.closest('tr');
    if (!targetRow || targetRow === draggedRowElement) return; // Don't highlight self

    // Add a class to indicate drop zone (e.g., border)
    targetRow.classList.add('drag-over');
}

/** Handles leaving a potential drop target */
function handleDragLeave(event) {
    const targetRow = event.target.closest('tr');
     if (targetRow) {
        targetRow.classList.remove('drag-over');
    }
}

/** REVISED Handles the drop operation - Adds Robust Protection Checks */
function handleDrop(event) {
    event.preventDefault();
    const targetRow = event.target.closest('tr');
    if(targetRow) targetRow.classList.remove('drag-over'); // Clean up visual indicator

    if (!targetRow || !draggedInitiativeId || targetRow.getAttribute('data-initiative-id') === draggedInitiativeId) {
        console.log("Drop cancelled - invalid target or same item.");
        // No need to reset draggedInitiativeId here, handleDragEnd will do it
        return;
    }

    const targetInitiativeId = targetRow.getAttribute('data-initiative-id');
    console.log(`Drop: ${draggedInitiativeId} onto ${targetInitiativeId}`);

    // --- Find initiatives and indices ---
    const initiatives = currentSystemData.yearlyInitiatives;
    const draggedIndex = initiatives.findIndex(init => init.initiativeId === draggedInitiativeId);
    const targetIndex = initiatives.findIndex(init => init.initiativeId === targetInitiativeId);

    if (draggedIndex === -1 || targetIndex === -1) {
        console.error("Could not find dragged or target initiative in data array during drop.");
        // No need to reset draggedInitiativeId here, handleDragEnd will do it
        return;
    }

    const draggedInitiative = initiatives[draggedIndex];
    const targetInitiative = initiatives[targetIndex];

    // --- Apply Reordering Constraints ---
    // Constraint 0: Cannot drag anything if the dragged item wasn't found or was somehow protected
     if (!draggedInitiative || draggedInitiative.isProtected) {
         console.log("Drop invalid: Dragged item is protected or invalid.");
         alert("Cannot move a protected item.");
         // handleDragEnd will reset state
         return;
     }
    // Constraint 1: Cannot drop ONTO a protected row (target is protected)
    if (targetInitiative.isProtected) {
        console.log("Drop invalid: Cannot drop onto a protected item.");
        alert("Cannot drop an item onto a protected item.");
         // handleDragEnd will reset state
        return;
    }
    // Constraint 2: Check if dropping would place the non-protected item *above* any protected items.
    // This means the new index (targetIndex) must be less than the index of the *first* non-protected item.
    const firstNonProtectedIndex = initiatives.findIndex(init => !init.isProtected);
    if (targetIndex < firstNonProtectedIndex && firstNonProtectedIndex !== -1) {
         console.log("Drop invalid: Cannot move item above the protected block.");
         alert("Cannot move items above the block of protected initiatives.");
         // handleDragEnd will reset state
         return;
    }
    // --- End Constraints ---


    // --- Perform Reorder in the Data Array ---
    const [movedItem] = initiatives.splice(draggedIndex, 1);
    const newTargetIndex = initiatives.findIndex(init => init.initiativeId === targetInitiativeId); // Recalculate index after splice
    // Determine insert position based on drop position relative to target row middle
     const rect = targetRow.getBoundingClientRect();
     const dropY = event.clientY;
     const insertBefore = dropY < rect.top + rect.height / 2;

     if (insertBefore) {
         initiatives.splice(newTargetIndex, 0, movedItem); // Insert before target
     } else {
         initiatives.splice(newTargetIndex + 1, 0, movedItem); // Insert after target
     }

    console.log("Reordered initiatives array:", initiatives.map(i => i.initiativeId));
    // --- End Reorder ---


    // --- Refresh the Table ---
    // The draggedInitiativeId is reset in handleDragEnd
    generatePlanningTable();
    // --- End Refresh ---
}

/** Cleans up after drag operation ends (dropped or cancelled) */
function handleDragEnd(event) {
    // Remove the dragging class from the original element
     if (draggedRowElement) {
        draggedRowElement.classList.remove('dragging');
    }
    // Clean up any lingering drag-over styles just in case
    document.querySelectorAll('#planningTableBody tr.drag-over').forEach(row => {
        row.classList.remove('drag-over');
    });

    console.log("Drag End");
    draggedInitiativeId = null;
    draggedRowElement = null;
}

/** Handles changes to SDE Year estimate inputs in the planning table */
function handleEstimateChange(event) {
    const input = event.target;
    const initiativeId = input.getAttribute('data-initiative-id');
    const teamId = input.getAttribute('data-team-id');
    const newValue = parseFloat(input.value);

    if (!initiativeId || !teamId) {
        console.error("Missing initiative or team ID on estimate input:", input);
        return;
    }

    // Validate the input value
    const validatedValue = (!isNaN(newValue) && newValue > 0) ? newValue : 0;

    // Find the initiative
    const initiative = currentSystemData.yearlyInitiatives.find(init => init.initiativeId === initiativeId);
    if (!initiative) {
        console.error("Could not find initiative data for ID:", initiativeId);
        return;
    }

    // Ensure assignments array exists
    if (!initiative.assignments) {
        initiative.assignments = [];
    }

    // Find existing assignment for this team
    const assignmentIndex = initiative.assignments.findIndex(a => a.teamId === teamId);

    if (validatedValue > 0) {
        if (assignmentIndex > -1) {
            // Update existing assignment
            initiative.assignments[assignmentIndex].sdeYears = validatedValue;
            console.log(`Updated estimate for ${initiativeId}, team ${teamId} to ${validatedValue}`);
        } else {
            // Add new assignment
            initiative.assignments.push({ teamId: teamId, sdeYears: validatedValue });
            console.log(`Added estimate for ${initiativeId}, team ${teamId}: ${validatedValue}`);
        }
        // Optionally reformat the input value after successful update
        input.value = validatedValue.toFixed(2);
    } else {
        // Remove assignment if value is 0 or invalid
        if (assignmentIndex > -1) {
            initiative.assignments.splice(assignmentIndex, 1);
            console.log(`Removed assignment for ${initiativeId}, team ${teamId}`);
        }
        // Clear the input field if the value was invalid or zero
        input.value = '';
    }

    // --- Refresh the entire table to recalculate totals and statuses ---
    generatePlanningTable();
    // --- End Refresh ---

    // Optional: Maintain focus if needed, though redraw might make it tricky
    // input.focus(); // Might not work reliably after full redraw
}

/** Sets the capacity scenario for planning and redraws the table */
function setPlanningScenario(scenario) {
  console.log(`Setting planning scenario to: ${scenario}`);
  // Allow 'effective', 'funded', or 'team_bis'
  if (scenario === 'effective' || scenario === 'funded' || scenario === 'team_bis') {
    planningCapacityScenario = scenario;
    // Redraw the planning table to apply the change
    generatePlanningTable();
  } else {
    console.warn("Invalid planning scenario provided:", scenario);
  }
}
// Make it globally accessible if not already
window.setPlanningScenario = setPlanningScenario;

/**
 * REVISED (v6.3) - Generates the Team Load Summary table - Fixes element selection for collapsible section.
 */
function generateTeamLoadSummaryTable() {
    console.log("Generating Team Load Summary Table (v6.3 - Fix Selector)...");

    // --- Get Container and Content Div ---
    // We check for the *content* div where the table actually lives now.
    const summaryContentDiv = document.getElementById('teamLoadSummaryContent');
    const summaryContainer = document.getElementById('teamLoadSummarySection'); // Get the outer container too for title update

    if (!summaryContentDiv || !summaryContainer) {
        console.error("Missing Team Load Summary elements (contentDiv or container). Cannot generate summary.");
        // Avoid modifying the container if it doesn't exist properly
        return;
    }

    // --- Find tbody and tfoot *within* the contentDiv ---
    const summaryTable = summaryContentDiv.querySelector('#teamLoadSummaryTable'); // Find table inside content
    const summaryTableBody = summaryTable?.querySelector('#teamLoadSummaryTableBody'); // Find tbody inside table
    const summaryTableFoot = summaryTable?.querySelector('#teamLoadSummaryTableFoot'); // Find tfoot inside table

    if (!summaryTable || !summaryTableBody || !summaryTableFoot) {
         console.error("Missing Team Load Summary table/tbody/tfoot elements *within* teamLoadSummaryContent.");
         // Clear body/foot if they exist but maybe table is broken
         if(summaryTableBody) summaryTableBody.innerHTML = '<tr ><td colspan="9" style="color:red;">Error: Cannot find table body.</td></tr>';
         if(summaryTableFoot) summaryTableFoot.innerHTML = '';
         return;
    }
    summaryTableBody.innerHTML = ''; // Clear previous rows
    summaryTableFoot.innerHTML = ''; // Clear previous footer
    // --- End Element Selection Fix ---

    if (!currentSystemData || !currentSystemData.yearlyInitiatives || !currentSystemData.teams) {
        const summaryTitle = summaryContainer.querySelector('h4 > span:last-child'); // Get text part of h4
        if(summaryTitle) summaryTitle.textContent = ' Team Load Summary (No System Data)'; // Update title text
        summaryTableBody.innerHTML = '<tr ><td colspan="9">Load a system with initiatives and teams.</td></tr>';
        return;
    }

    // --- Recalculate Capacities (Overall & Per Team) ---
    let totalFundedHC = 0, totalTeamBIS = 0, totalAwayTeamBIS = 0;
    const teamCapacities = {}; // Store { fundedHC, teamBIS, effectiveBIS } per teamId
    const teams = currentSystemData.teams || [];
    teams.forEach(team => {
        if (!team || !team.teamId) { console.warn("Skipping team with missing data during capacity calculation:", team); return; }
        const funded = team.fundedHeadcount ?? 0;
        const teamBIS = team.engineers?.length ?? 0;
        const awayBIS = team.awayTeamMembers?.length ?? 0;
        const effectiveBIS = teamBIS + awayBIS;
        totalFundedHC += funded; totalTeamBIS += teamBIS; totalAwayTeamBIS += awayBIS;
        teamCapacities[team.teamId] = { fundedHC: funded, teamBIS: teamBIS, awayBIS: awayBIS, effectiveBIS: effectiveBIS };
    });
    const totalEffectiveBIS = totalTeamBIS + totalAwayTeamBIS;

    // --- Determine Overall ATL/BTL Limit & Update Title ---
    let atlBtlCapacityLimit; let scenarioName = '';
    if (planningCapacityScenario === 'funded') { atlBtlCapacityLimit = totalFundedHC; scenarioName = 'Funded HC'; }
    else if (planningCapacityScenario === 'team_bis') { atlBtlCapacityLimit = totalTeamBIS; scenarioName = 'Team BIS'; }
    else { atlBtlCapacityLimit = totalEffectiveBIS; scenarioName = 'Effective BIS'; } // Default to effective

    const summaryTitleHeader = summaryContainer.querySelector('h4'); // Get the H4 element itself
    if (summaryTitleHeader) {
        // Reconstruct the title content carefully
        const toggleSpan = summaryTitleHeader.querySelector('span.toggle-indicator');
        summaryTitleHeader.textContent = ` Team Load Summary (for ATL Initiatives - Scenario: ${scenarioName})`; // Set text content AFTER span
        if (toggleSpan) {
             summaryTitleHeader.insertBefore(toggleSpan, summaryTitleHeader.firstChild); // Prepend the toggle span
        }
    }


    // --- Calculate Assigned ATL SDEs per Team ---
    const sortedInitiatives = [...currentSystemData.yearlyInitiatives].sort((a, b) => { if (a.isProtected && !b.isProtected) return -1; if (!a.isProtected && b.isProtected) return 1; return 0; });
    let overallCumulativeSde = 0; let teamAtlSdeAssigned = {};
    teams.forEach(team => { if(team && team.teamId) teamAtlSdeAssigned[team.teamId] = 0; }); // Initialize
    sortedInitiatives.forEach(initiative => {
        let initiativeTotalSde = 0;
        (initiative.assignments || []).forEach(a => { initiativeTotalSde += a.sdeYears; });
        overallCumulativeSde += initiativeTotalSde;
        // Only include assignments if the initiative is considered ATL based on the *overall* limit
        if (overallCumulativeSde <= atlBtlCapacityLimit) {
            (initiative.assignments || []).forEach(assignment => {
                 if (teamAtlSdeAssigned.hasOwnProperty(assignment.teamId)) { teamAtlSdeAssigned[assignment.teamId] += assignment.sdeYears; }
            });
        }
    });

    // --- Populate Summary Table Body ---
    let totalAssignedAtlSdeOverall = 0;
    let totalScenarioCapacityOverall = 0;

    teams.sort((a,b) => (a?.teamName || a?.teamIdentity || '').localeCompare(b?.teamName || b?.teamIdentity || ''))
         .forEach(team => {
        if (!team || !team.teamId) return;
        const teamId = team.teamId; const capacity = teamCapacities[teamId]; const assignedAtlSde = teamAtlSdeAssigned[teamId] || 0;
        if (!capacity) { console.warn(`Capacity data not found for teamId: ${teamId}. Skipping row generation.`); return; }
        let teamScenarioLimit = 0;
        if (planningCapacityScenario === 'funded') { teamScenarioLimit = capacity?.fundedHC ?? 0; } else if (planningCapacityScenario === 'team_bis') { teamScenarioLimit = capacity?.teamBIS ?? 0; } else { teamScenarioLimit = capacity?.effectiveBIS ?? 0; }
        const remainingCapacity = teamScenarioLimit - assignedAtlSde;
        totalAssignedAtlSdeOverall += assignedAtlSde; totalScenarioCapacityOverall += teamScenarioLimit;
        let statusText = ' OK'; let statusColor = 'green'; if (remainingCapacity < 0) { statusText = ' Overloaded'; statusColor = 'red'; } else if (remainingCapacity < 0.5 && teamScenarioLimit > 0) { statusText = ' Near Limit'; statusColor = 'darkorange'; }

        const row = summaryTableBody.insertRow();
        // Populate cells (same as before)
        row.insertCell().textContent = team.teamIdentity || team.teamName || teamId; // Col 0
        row.insertCell().textContent = (capacity?.fundedHC ?? 0).toFixed(2);        // Col 1
        row.insertCell().textContent = (capacity?.teamBIS ?? 0).toFixed(2);         // Col 2
        row.insertCell().textContent = (capacity?.awayBIS ?? 0).toFixed(2);         // Col 3
        row.insertCell().textContent = (capacity?.effectiveBIS ?? 0).toFixed(2);    // Col 4
        row.insertCell().textContent = assignedAtlSde.toFixed(2);                   // Col 5
        row.insertCell().textContent = teamScenarioLimit.toFixed(2);                // Col 6
        const remainingCell = row.insertCell();                                     // Col 7
              remainingCell.textContent = remainingCapacity.toFixed(2);
              remainingCell.style.color = remainingCapacity < 0 ? 'red' : 'green';
        const statusCell = row.insertCell();                                        // Col 8
              statusCell.textContent = statusText;
              statusCell.style.color = statusColor;

        // Apply Styling (including center alignment)
        const cells = Array.from(row.cells);
        cells.forEach((cell, index) => {
            cell.style.border = '1px solid #ccc';
            cell.style.padding = '4px 6px';
             if (index === 0) { cell.style.textAlign = 'left';} // Team Name
             else if (index === cells.length - 1) { cell.style.textAlign = 'center'; } // Status Cell
             else { cell.style.textAlign = 'center'; } // Numerical columns
        });
    }); // End teams.forEach

     // --- Populate Footer ---
     const footerRow = summaryTableFoot.insertRow();
     footerRow.insertCell().textContent = 'Totals';                              // Col 0
     footerRow.insertCell().textContent = totalFundedHC.toFixed(2);              // Col 1
     footerRow.insertCell().textContent = totalTeamBIS.toFixed(2);               // Col 2
     footerRow.insertCell().textContent = totalAwayTeamBIS.toFixed(2);           // Col 3
     footerRow.insertCell().textContent = totalEffectiveBIS.toFixed(2);          // Col 4
     footerRow.insertCell().textContent = totalAssignedAtlSdeOverall.toFixed(2); // Col 5
     footerRow.insertCell().textContent = totalScenarioCapacityOverall.toFixed(2);// Col 6
     const totalRemainingCell = footerRow.insertCell();                         // Col 7
           totalRemainingCell.textContent = (totalScenarioCapacityOverall - totalAssignedAtlSdeOverall).toFixed(2);
           totalRemainingCell.style.color = (totalScenarioCapacityOverall - totalAssignedAtlSdeOverall) < 0 ? 'red' : 'green';
     footerRow.insertCell().textContent = '';                                     // Col 8 (Status)

     // Apply Footer Styling
     const footerCells = Array.from(footerRow.cells);
     footerCells.forEach((cell, index) => {
         cell.style.border = '1px solid #ccc';
         cell.style.padding = '4px 6px';
         cell.style.backgroundColor = '#f8f9fa';
         if (index === 0) { cell.style.textAlign = 'left'; } // Totals label
         else if (index === footerCells.length - 1) { cell.style.textAlign = 'center';} // Status Cell
         else { cell.style.textAlign = 'center'; } // Numerical columns
     });

     console.log("Finished generating Team Load Summary Table (v6.3 - Fix Selector).");
}


/** REVISED (v6) - Generates planning table - Persistent Green/Red Team Cells & Scoped Row Styles */
function generatePlanningTable() {
    console.log("Generating planning table (v6 - Persistent Team Colors)...");
    const planningViewDiv = document.getElementById('planningView');
    const capacitySummaryDiv = document.getElementById('planningCapacitySummary');
    const scenarioControlDiv = document.getElementById('planningScenarioControl');
    const tableContainer = document.getElementById('planningTableContainer');

    // --- Clear previous content ONLY from relevant areas ---
    if (capacitySummaryDiv) capacitySummaryDiv.innerHTML = ''; else console.error("Missing #planningCapacitySummary div");
    if (scenarioControlDiv) scenarioControlDiv.innerHTML = ''; else console.error("Missing #planningScenarioControl div");
    if (tableContainer) tableContainer.innerHTML = ''; else console.error("Missing #planningTableContainer div");

    if (!currentSystemData || !currentSystemData.yearlyInitiatives || !currentSystemData.teams) {
        if (tableContainer) tableContainer.innerHTML = '<p style="color: orange;">No planning data loaded or no initiatives/teams found. Use "Edit System" to load or define data.</p>';
        if (capacitySummaryDiv) capacitySummaryDiv.innerHTML = 'Load a system to see capacity.';
        return;
    }

    // --- 1. Calculate Detailed Capacity (Overall & Per Team) --- (No change)
    let totalFundedHC = 0, totalTeamBIS = 0, totalAwayTeamBIS = 0;
    const teamCapacities = {}; // Store { fundedHC, teamBIS, effectiveBIS } per teamId
    const teams = currentSystemData.teams || [];
    teams.forEach(team => {
        const funded = team.fundedHeadcount ?? 0;
        const teamBIS = team.engineers?.length ?? 0;
        const awayBIS = team.awayTeamMembers?.length ?? 0;
        const effectiveBIS = teamBIS + awayBIS;
        totalFundedHC += funded;
        totalTeamBIS += teamBIS;
        totalAwayTeamBIS += awayBIS;
        teamCapacities[team.teamId] = { fundedHC: funded, teamBIS: teamBIS, effectiveBIS: effectiveBIS };
    });
    const totalEffectiveBIS = totalTeamBIS + totalAwayTeamBIS;

    // --- 2. Update Capacity Summary Display --- (No change)
    if (capacitySummaryDiv) { /* ... same as v5 ... */
        capacitySummaryDiv.innerHTML = `
            <span title="Finance Approved Headcount" style="margin-right: 15px;">Funded HC: <strong style="color: #28a745;">${totalFundedHC.toFixed(2)}</strong></span> |
            <span title="Actual Team Members" style="margin-right: 15px;">Team BIS: <strong style="color: #17a2b8;">${totalTeamBIS.toFixed(2)}</strong></span> |
            <span title="Borrowed / Away-Team Members" style="margin-right: 15px;">Away BIS: <strong style="color: #ffc107;">${totalAwayTeamBIS.toFixed(2)}</strong></span> |
            <span title="Total Effective Capacity (Team + Away)">Effective BIS: <strong style="color: #007bff;">${totalEffectiveBIS.toFixed(2)}</strong></span>
        `;
    }

    // --- 3. Add/Update Scenario Toggle UI --- (No change)
    if (scenarioControlDiv) { /* ... same as v5 ... */
        const baseButtonStyle = 'padding: 5px 10px; margin-left: 10px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 0.9em;';
        const activeButtonStyle = baseButtonStyle + ' background-color: #007bff; color: white; border-color: #0056b3; font-weight: bold;';
        const inactiveButtonStyle = baseButtonStyle + ' background-color: #e9ecef; color: #495057;';
        const effectiveButtonStyle = (planningCapacityScenario === 'effective') ? activeButtonStyle : inactiveButtonStyle;
        const fundedButtonStyle = (planningCapacityScenario === 'funded') ? activeButtonStyle : inactiveButtonStyle;
        const teamBisButtonStyle = (planningCapacityScenario === 'team_bis') ? activeButtonStyle : inactiveButtonStyle;
        scenarioControlDiv.innerHTML = `
            <strong style="margin-right: 10px;">Calculate ATL/BTL using:</strong>
            <button type="button" id="btnEffectiveBIS" style="${effectiveButtonStyle}" title="Use Effective BIS (${totalEffectiveBIS.toFixed(2)}) = Team + Away" onclick="setPlanningScenario('effective')">Effective BIS</button>
            <button type="button" id="btnTeamBIS" style="${teamBisButtonStyle}" title="Use Team BIS (${totalTeamBIS.toFixed(2)}) = Only Team Members" onclick="setPlanningScenario('team_bis')">Team BIS</button>
            <button type="button" id="btnFundedHC" style="${fundedButtonStyle}" title="Use Funded HC (${totalFundedHC.toFixed(2)}) = Budgeted Headcount" onclick="setPlanningScenario('funded')">Funded HC</button>
            <button type="button" id="savePlanButton"
                    style="${baseButtonStyle} background-color: #dc3545; color: white; border-color: #dc3545; margin-left: 25px;"
                    title="Save the current order and estimates for all initiatives in this plan.">
                Save Current Plan Order & Estimates
            </button>
        `;

        // --- Re-attach listener AFTER button is added to DOM ---
        // We need to find the button *after* innerHTML is set
        setTimeout(() => { // Use timeout to ensure DOM update
            const savePlanButton = document.getElementById('savePlanButton');
            if (savePlanButton) {
                 // Remove old listener if it exists from previous renders (safer)
                 savePlanButton.removeEventListener('click', handleSavePlan);
                 // Add the listener
                 savePlanButton.addEventListener('click', handleSavePlan);
                 console.log("Attached click listener to moved Save button.");
            } else {
                 console.error("Could not find moved Save button to attach listener.");
            }
       }, 0);
       // --- End of setTimeout block ---    
    
    } // End of the if (scenarioControlDiv) block
    // Determine Overall ATL/BTL Limit based on scenario
    let atlBtlCapacityLimit;
    if (planningCapacityScenario === 'funded') { atlBtlCapacityLimit = totalFundedHC; }
    else if (planningCapacityScenario === 'team_bis') { atlBtlCapacityLimit = totalTeamBIS; }
    else { atlBtlCapacityLimit = totalEffectiveBIS; }
    console.log(`Using capacity limit for ATL/BTL: ${atlBtlCapacityLimit.toFixed(2)} (Scenario: ${planningCapacityScenario})`);

    generateTeamLoadSummaryTable();

    // --- 4. Prepare Table Structure ---
    const tableWrapper = document.createElement('div'); tableWrapper.id = 'planningTableWrapper';
    const table = document.createElement('table'); table.style.width = '100%'; table.style.borderCollapse = 'collapse'; table.id = 'planningTable';
    const thead = document.createElement('thead'); const headerRow = document.createElement('tr');
    const fixedHeaders = ['Protected', 'Title', 'ID', 'Description', 'Total SDE Years', 'Cumulative SDE Years', 'Capacity Status', 'ATL/BTL'];
    fixedHeaders.forEach(text => { const th = document.createElement('th'); th.textContent = text; th.style.border = '1px solid #ccc'; th.style.padding = '8px'; th.style.textAlign = 'left'; th.style.whiteSpace = 'nowrap'; headerRow.appendChild(th); });
    const teamHeaderMap = new Map();
    teams.forEach((team, index) => { 
      const th = document.createElement('th'); 
      const teamDisplayIdentity = team.teamIdentity || team.teamId || 'Unknown'; // Use ID if identity missing
      const teamFullName = team.teamName || teamDisplayIdentity; // Use full name or identity/ID for title
      th.textContent = teamDisplayIdentity; // Display the identity
      th.title = `Team: ${teamFullName}\nIdentity: ${teamDisplayIdentity}\n(Funded: ${teamCapacities[team.teamId]?.fundedHC.toFixed(2)}, Team BIS: ${teamCapacities[team.teamId]?.teamBIS.toFixed(2)}, Eff. BIS: ${teamCapacities[team.teamId]?.effectiveBIS.toFixed(2)})`; // Update title
      th.setAttribute('data-team-id', team.teamId); th.style.border = '1px solid #ccc'; 
      th.style.padding = '8px'; 
      th.style.textAlign = 'center'; 
      th.style.writingMode = 'vertical-lr'; 
      th.style.textOrientation = 'mixed'; 
      th.style.whiteSpace = 'nowrap'; 
      th.style.minWidth = '35px'; 
      th.style.maxWidth = '35px'; 
      headerRow.appendChild(th); 
      teamHeaderMap.set(fixedHeaders.length + index, team.teamId); 
    });
    thead.appendChild(headerRow); table.appendChild(thead);
    const tbody = document.createElement('tbody'); tbody.id = 'planningTableBody';


    // --- 5. Sort Initiatives & Populate Body ---
    const sortedInitiatives = [...currentSystemData.yearlyInitiatives].sort((a, b) => { /* ... same sort ... */ if (a.isProtected && !b.isProtected) return -1; if (!a.isProtected && b.isProtected) return 1; return 0; });
    let cumulativeSdeTotal = 0; // Overall cumulative
    let teamCumulativeSde = {}; // { teamId: cumulativeValue }
    teams.forEach(team => { teamCumulativeSde[team.teamId] = 0; }); // Initialize

    sortedInitiatives.forEach((initiative, rowIndex) => {
        if (!initiative || !initiative.initiativeId) { console.warn("Skipping invalid initiative data at index:", rowIndex); return; }
        const row = tbody.insertRow(); row.setAttribute('data-initiative-id', initiative.initiativeId); row.style.borderBottom = '1px solid #eee'; row.style.padding = '2px 0';
        // Drag and drop setup (No change)
        row.setAttribute('draggable', !initiative.isProtected); row.addEventListener('dragover', handleDragOver); row.addEventListener('dragleave', handleDragLeave); row.addEventListener('drop', handleDrop); row.addEventListener('dragend', handleDragEnd); if (!initiative.isProtected) { row.addEventListener('dragstart', handleDragStart); row.style.cursor = 'move'; } else { row.style.cursor = 'default'; }

        // Fixed Cells (Protected, Title, ID, Desc) - No changes
        const protectedCell = row.insertCell(); const protectedCheckbox = document.createElement('input'); protectedCheckbox.type = 'checkbox'; protectedCheckbox.checked = initiative.isProtected; protectedCheckbox.setAttribute('data-initiative-id', initiative.initiativeId); protectedCheckbox.style.cursor = 'pointer'; protectedCheckbox.onchange = handleProtectedChange; protectedCell.appendChild(protectedCheckbox); protectedCell.style.textAlign = 'center';
        const titleCell = row.insertCell(); titleCell.textContent = initiative.title || 'No Title'; titleCell.style.fontWeight = initiative.isProtected ? 'bold' : 'normal';
        const idCell = row.insertCell(); idCell.textContent = initiative.initiativeId; idCell.style.fontSize = '0.8em'; idCell.style.color = '#555';
        const descCell = row.insertCell(); const descText = initiative.description || ''; descCell.textContent = descText.length > 50 ? descText.substring(0, 47) + '...' : descText; descCell.title = descText;

        // Placeholder cells for overall totals/status
        const totalSdeCell = row.insertCell(); totalSdeCell.style.textAlign = 'right';
        const cumSdeCell = row.insertCell(); cumSdeCell.style.textAlign = 'right';
        const statusCell = row.insertCell(); statusCell.style.textAlign = 'center';
        const atlBtlCell = row.insertCell(); atlBtlCell.style.fontWeight = 'bold'; atlBtlCell.style.textAlign = 'center';

        let initiativeTotalSde = 0;
        const assignmentsMap = new Map((initiative.assignments || []).map(a => [a.teamId, a.sdeYears]));

        // *** REVISED: Per-Team Cell Coloring Logic ***
        teamHeaderMap.forEach((teamId, colIndex) => {
            const teamCell = row.insertCell();
            const currentEstimate = assignmentsMap.get(teamId) || 0;
            teamCumulativeSde[teamId] += currentEstimate; // Increment this team's cumulative

            // Estimate Input (still needed)
            const estimateInput = document.createElement('input');
            estimateInput.type = 'number'; estimateInput.min = '0'; estimateInput.step = '0.25'; estimateInput.value = currentEstimate > 0 ? currentEstimate.toFixed(2) : '';
            estimateInput.setAttribute('data-initiative-id', initiative.initiativeId); estimateInput.setAttribute('data-team-id', teamId);
            estimateInput.style.width = '60px'; estimateInput.style.textAlign = 'right';
            estimateInput.style.border = 'none';
            estimateInput.style.backgroundColor = 'transparent'; // Make input see-through
            estimateInput.addEventListener('change', handleEstimateChange);
            teamCell.appendChild(estimateInput);
            teamCell.style.textAlign = 'center';

            // Determine team's scenario limit
            const teamData = teamCapacities[teamId];
            let teamScenarioLimit = 0;
            let scenarioLabel = '';
            if (planningCapacityScenario === 'funded') { teamScenarioLimit = teamData?.fundedHC ?? 0; scenarioLabel = `Funded HC: ${teamScenarioLimit.toFixed(2)}`; }
            else if (planningCapacityScenario === 'team_bis') { teamScenarioLimit = teamData?.teamBIS ?? 0; scenarioLabel = `Team BIS: ${teamScenarioLimit.toFixed(2)}`; }
            else { teamScenarioLimit = teamData?.effectiveBIS ?? 0; scenarioLabel = `Effective BIS: ${teamScenarioLimit.toFixed(2)}`; }

            // Apply Green/Red based ONLY on cumulative vs scenario limit
            const currentTeamCumulative = teamCumulativeSde[teamId];
            if (currentTeamCumulative <= teamScenarioLimit) {
                teamCell.style.backgroundColor = '#d4edda'; // Green
                teamCell.title = `Cumulative: ${currentTeamCumulative.toFixed(2)} / Scenario Limit (${scenarioLabel}) - OK`;
            } else {
                teamCell.style.backgroundColor = '#f8d7da'; // Red
                teamCell.title = `Cumulative: ${currentTeamCumulative.toFixed(2)} / Scenario Limit (${scenarioLabel}) - Overloaded`;
            }

            // Note: We REMOVED the specific override for currentEstimate <= 0 here.
            // Color now persists based on cumulative status.

            initiativeTotalSde += currentEstimate;
        }); // End teamHeaderMap.forEach

        // Calculate and display OVERALL row totals and status
        totalSdeCell.textContent = initiativeTotalSde.toFixed(2);
        cumulativeSdeTotal += initiativeTotalSde;
        cumSdeCell.textContent = cumulativeSdeTotal.toFixed(2);

        // Overall Capacity Status (vs Team BIS and Funded HC) - No change
         if (cumulativeSdeTotal <= totalTeamBIS) { statusCell.textContent = ''; statusCell.title = `Within Team BIS (${totalTeamBIS.toFixed(2)})`; statusCell.style.backgroundColor = '#d4edda';} else if (cumulativeSdeTotal <= totalFundedHC) { statusCell.textContent = ''; statusCell.title = `Exceeds Team BIS (${totalTeamBIS.toFixed(2)}), Within Funded HC (${totalFundedHC.toFixed(2)}). Requires hiring or away-team.`; statusCell.style.backgroundColor = '#fff3cd'; } else { statusCell.textContent = ''; statusCell.title = `Exceeds Funded HC (${totalFundedHC.toFixed(2)})`; statusCell.style.backgroundColor = '#f8d7da'; }

        // Overall ATL/BTL Status (vs Scenario Limit) - No change in text/color logic
        const isBTL = cumulativeSdeTotal > atlBtlCapacityLimit;
        if (!isBTL) {
            atlBtlCell.textContent = 'ATL'; atlBtlCell.style.color = 'green';
            // Add nuance tooltips (No change)
            /* ... tooltips comparing scenario limit vs other limits ... */
             if (planningCapacityScenario === 'effective' && cumulativeSdeTotal > totalFundedHC) { row.style.opacity = '0.8'; row.title = 'ATL (vs Effective BIS), but BTL vs Funded HC.'; } else if (planningCapacityScenario === 'team_bis' && cumulativeSdeTotal > totalEffectiveBIS) { row.style.opacity = '0.8'; row.title = 'ATL (vs Team BIS), but BTL vs Effective BIS.'; } else if (planningCapacityScenario === 'team_bis' && cumulativeSdeTotal > totalFundedHC) { row.style.opacity = '0.8'; row.title = 'ATL (vs Team BIS), but BTL vs Funded HC.'; } else if (planningCapacityScenario === 'funded' && cumulativeSdeTotal > totalEffectiveBIS) { row.style.opacity = '0.8'; row.title = 'ATL (vs Funded HC), but BTL vs Effective BIS.'; } else { row.style.opacity = '1'; row.title = ''; }
        } else {
            atlBtlCell.textContent = 'BTL'; atlBtlCell.style.color = 'red';
        }

        // *** REVISED: Apply Row Styling ONLY to Fixed Columns ***
        row.querySelectorAll('td').forEach((cell, idx) => {
            if (idx < fixedHeaders.length) { // Apply only to fixed columns
                if (initiative.isProtected) {
                    cell.style.backgroundColor = '#f8f9fa'; // Gray for protected fixed cells
                } else if (isBTL) {
                    cell.style.backgroundColor = '#ffeeee'; // Light red for BTL fixed cells
                } else {
                    // Set default for non-protected, non-BTL fixed cells (except status cell)
                    if (idx !== fixedHeaders.indexOf('Capacity Status')) {
                       cell.style.backgroundColor = '#fff'; // Default white
                    }
                }
            }
            // Ensure Capacity Status cell retains its independent color
            if (idx === fixedHeaders.indexOf('Capacity Status')) {
                 if (cumulativeSdeTotal <= totalTeamBIS) { cell.style.backgroundColor = '#d4edda';} else if (cumulativeSdeTotal <= totalFundedHC) { cell.style.backgroundColor = '#fff3cd'; } else { cell.style.backgroundColor = '#f8d7da'; }
                 // Also override if protected/BTL applies to fixed columns
                 if (initiative.isProtected) cell.style.backgroundColor = '#f8f9fa';
                 else if (isBTL) cell.style.backgroundColor = '#ffeeee';
            }
        });

    }); // End sortedInitiatives.forEach

    // --- Assemble the table structure ---
    table.appendChild(tbody);
    tableWrapper.appendChild(table);
    if (tableContainer) { tableContainer.appendChild(tableWrapper); }
    // --- End Assemble Table Structure ---

    adjustPlanningTableHeight();
    console.log("Finished generating planning table (v6 - Persistent Team Colors).");
} // --- End generatePlanningTable ---

/** Dynamically adjusts the max-height of the planning table scroll wrapper */
function adjustPlanningTableHeight() {
    const planningViewDiv = document.getElementById('planningView');
    const tableWrapper = document.getElementById('planningTableWrapper');
    const controlsAboveTable = document.getElementById('planningScenarioControl'); // Use scenario controls as a reference point above the table

    if (!planningViewDiv || !tableWrapper || !controlsAboveTable || planningViewDiv.style.display === 'none') {
        // Don't adjust if the view isn't visible or elements are missing
        return;
    }

    // Calculate available height
    const viewportHeight = window.innerHeight;
    const controlsRect = controlsAboveTable.getBoundingClientRect(); // Get position of controls above the table
    const controlsBottom = controlsRect.bottom; // Bottom edge of the controls
    const tableWrapperTop = tableWrapper.getBoundingClientRect().top; // Top edge of the table wrapper itself

    // Determine space available below the controls. Use whichever top position is lower (should be tableWrapperTop).
    const availableSpace = viewportHeight - tableWrapperTop;

    // Set a reasonable bottom margin/padding
    const bottomMargin = 60; // Adjust as needed (accounts for "Add Initiative" section, footer, etc.)

    let calculatedMaxHeight = availableSpace - bottomMargin;

    // Set a minimum height to prevent it becoming too small
    const minHeight = 200; // Minimum pixels for the table area
    calculatedMaxHeight = Math.max(minHeight, calculatedMaxHeight);

    console.log(`Adjusting planning table max-height to: ${calculatedMaxHeight}px`);
    tableWrapper.style.maxHeight = `${calculatedMaxHeight}px`;
}

/**
 * REVISED - Toggles the visibility of a collapsible section and updates its indicator.
 * Added logging to verify arguments.
 * Also triggers recalculation of the main planning table height.
 * @param {string} contentId - The ID of the div containing the content to toggle.
 * @param {string} indicatorId - The ID of the span element showing (+) or (-).
 */
function toggleCollapsibleSection(contentId, indicatorId) {
    // *** ADDED LOGGING HERE ***
    console.log(`toggleCollapsibleSection called with contentId: '${contentId}', indicatorId: '${indicatorId}'`);

    const contentDiv = document.getElementById(contentId);
    const indicatorSpan = document.getElementById(indicatorId);

    if (!contentDiv || !indicatorSpan) {
        console.error(`Cannot toggle section: Missing content or indicator element. ID searched for content: '${contentId}', ID searched for indicator: '${indicatorId}'`);
        return;
    }

    const isHidden = contentDiv.style.display === 'none' || contentDiv.style.display === '';
    contentDiv.style.display = isHidden ? 'block' : 'none'; // Use 'block' for general divs
    indicatorSpan.textContent = isHidden ? '(-)' : '(+)';

    // Crucially, recalculate table height AFTER changing display
    adjustPlanningTableHeight();
    console.log(`Toggled section ${contentId} to ${isHidden ? 'visible' : 'hidden'}`);
}

/** REVISED (v2) function to show the main system overview - Restores all views */
function showSystemOverview() {
    console.log("Navigating back to system overview...");
    if (!currentSystemData) {
        console.warn("showSystemOverview called but no system is loaded. Returning home instead.");
        returnToHome(); // Go home if no system is loaded
        return;
    }
    currentMode = Modes.Browse; // Set appropriate mode

    // --- Hide ALL specific sub-view sections ---
    // (These are views you navigate *away* from the overview to)
    const viewsToHide = [
        'systemEditForm',       // Edit Form
        'organogramView',       // Org Chart View
        'engineerTableView',    // Engineer Table View
        'planningView'          // Planning View
    ];
    viewsToHide.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.style.display = 'none';
    });
    // --- End Hide Sub-Views ---

    // --- Show System Overview Title/Desc/Nav ---
    const pageTitleH1 = document.getElementById('pageTitle');
    const systemDescP = document.getElementById('systemDescription');
    const editMenu = document.querySelector('.edit-menu'); // The system-specific menu

    if (pageTitleH1) {
         pageTitleH1.innerText = currentSystemData.systemName || "System Overview";
         pageTitleH1.style.display = 'block'; // Make visible
    }
    if(systemDescP) {
         systemDescP.innerText = currentSystemData.systemDescription || "";
         systemDescP.style.display = 'block'; // Make visible
    }
    // Show the edit menu
    if (editMenu) editMenu.style.display = 'block';
     // --- End Show Title/Desc/Nav ---

    // --- *** ADDED: Show and Regenerate Overview Content *** ---
    const viewsToShowAndGenerate = [
        'visualization',                // System Visualization
        'teamVisualization',            // Team Relationships Visualization
        'teamBreakdown',                // Team Breakdown Table
        'serviceRelationshipsVisualization', // Service Relationships Visualization
        'dependencyVisualization',      // Service Dependency Visualization
        'serviceDependenciesTable'      // Service Dependencies Table
    ];
    viewsToShowAndGenerate.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.style.display = 'block'; else console.warn(`Element not found for overview: ${id}`);
    });

    // Call generation functions (similar to loadSavedSystem)
    try {
        // Ensure platformDependencies are up-to-date before visualizing
        buildGlobalPlatformDependencies();

        generateVisualization(currentSystemData);
        generateTeamVisualization(currentSystemData);
        generateTeamTable(currentSystemData); // Regenerate team table
        populateServiceSelection();           // Repopulate dropdowns
        updateServiceVisualization();       // Update service viz
        populateDependencyServiceSelection(); // Repopulate dropdowns
        updateDependencyVisualization();    // Update dependency viz
        generateServiceDependenciesTable();   // Regenerate dependencies table

        console.log("Regenerated system overview visualizations and tables.");
    } catch (error) {
        console.error("Error regenerating system overview content:", error);
        // Optionally display an error message to the user in the UI
    }
    // --- *** End Show and Regenerate Overview Content *** ---


     // --- Manage Button Visibility ---
     const backButton = document.getElementById('backToSystemViewButton');
     const returnHomeButton = document.getElementById('returnHomeButton');
     // We are IN system overview, so hide the "Back" button
     if (backButton) backButton.style.display = 'none';
     // Keep "Return Home" button visible (since a system is loaded)
     if (returnHomeButton) returnHomeButton.style.display = 'block';
     // -----------------------------

     console.log("System overview displayed.");
}

// Make it globally accessible (if not already done)
window.showSystemOverview = showSystemOverview;

// Make it globally accessible
window.showSystemOverview = showSystemOverview;

/** REVISED (v8) Shows the Yearly Planning View - Hides nav/title/desc, Shows Back button */
function showPlanningView() {
    console.log("Switching to Yearly Planning View (Focus Mode)...");
    currentMode = Modes.PLANNING; // Set mode

    // --- Hide elements NOT needed in focused planning view ---
    const mainNavBar = document.querySelector('.edit-menu');
    const pageTitleH1 = document.getElementById('pageTitle');
    const systemDescP = document.getElementById('systemDescription');
    if (mainNavBar) mainNavBar.style.display = 'none'; else console.warn("Could not find .edit-menu to hide.");
    if (pageTitleH1) pageTitleH1.style.display = 'none'; else console.warn("Could not find #pageTitle to hide.");
    if (systemDescP) systemDescP.style.display = 'none'; else console.warn("Could not find #systemDescription to hide.");
    // ---------------------------------------------------------

    // --- Hide ALL other main view sections ---
    const viewsToHide = [
        'systemEditForm', 'visualization', 'teamVisualization', 'teamBreakdown',
        'serviceRelationshipsVisualization', 'dependencyVisualization', 'serviceDependenciesTable',
        'organogramView', 'engineerTableView'
        // NOTE: Do NOT hide 'planningView' itself here
    ];
    viewsToHide.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.style.display = 'none';
    });
    const mainMenu = document.querySelector('.menu'); // Ensure main menu is hidden too
    if (mainMenu) mainMenu.style.display = 'none';
    // ----------------------------------------

    // --- Show the Planning View ---
    const planningViewDiv = document.getElementById('planningView');
    if (planningViewDiv) {
        planningViewDiv.style.display = 'block';
        // Update title based on loaded system
        const planningTitle = document.getElementById('planningViewTitle');
        if (planningTitle && currentSystemData && currentSystemData.systemName) {
            planningTitle.innerText = `Yearly Planning View: ${currentSystemData.systemName}`;
        } else if (planningTitle) {
            planningTitle.innerText = `Yearly Planning View (No System Loaded)`;
        }

        // Generate the table content
        generatePlanningTable(); // This also generates the summary table now

        // --- Populate Team Select & Attach Listeners ---
        populateTeamSelect();
        // Add listeners only once (using data attribute check)
        const addAssignButton = document.getElementById('addTeamAssignmentButton');
        if (addAssignButton && !addAssignButton.hasAttribute('data-listener-attached')) {
            addAssignButton.addEventListener('click', handleAddTeamAssignment);
            addAssignButton.setAttribute('data-listener-attached', 'true');
        }
        const addInitButton = document.getElementById('addInitiativeButton');
        if (addInitButton && !addInitButton.hasAttribute('data-listener-attached')) {
            addInitButton.addEventListener('click', handleAddInitiative);
            addInitButton.setAttribute('data-listener-attached', 'true');
        }
        // NOTE: Listener for savePlanButton is now attached within generatePlanningTable

        // Adjust table height AFTER view is visible
        adjustPlanningTableHeight();

    } else {
        console.error("Planning view container not found!");
    }
    // ---------------------------

    // --- Manage Button Visibility ---
    const returnHomeBtn = document.getElementById('returnHomeButton');
    const backButton = document.getElementById('backToSystemViewButton');
    if(returnHomeBtn) returnHomeBtn.style.display = 'block'; // Keep Return Home visible
    if(backButton) backButton.style.display = 'block'; // *** SHOW the Back button ***
    // -----------------------------
}

// --- Add New Initiative Logic ---

// Store temporary assignments before adding the initiative
let tempAssignments = [];

/** Populates the team selection dropdown in the 'Add Initiative' section */
function populateTeamSelect() {
    const select = document.getElementById('newInitiativeTeamSelect');
    if (!select) return;

    // Clear existing options except the placeholder
    select.length = 1; // Keep only the "-- Select Team --" option

    (currentSystemData.teams || []).forEach(team => {
        const option = document.createElement('option');
        option.value = team.teamId;
        option.textContent = team.teamIdentity || team.teamName || team.teamId;
        select.appendChild(option);
    });
}

/** Updates the display area showing temporary team assignments */
function displayTempAssignments() {
    const displayDiv = document.getElementById('newInitiativeAssignmentsDisplay');
    if (!displayDiv) return;
    displayDiv.innerHTML = ''; // Clear current display

    tempAssignments.forEach((assignment, index) => {
        const team = (currentSystemData.teams || []).find(t => t.teamId === assignment.teamId);
        const teamName = team ? (team.teamIdentity || team.teamName) : assignment.teamId;
        const assignmentDiv = document.createElement('div');
        assignmentDiv.style.marginBottom = '3px';
        assignmentDiv.textContent = `${teamName}: ${assignment.sdeYears.toFixed(2)} SDE Years `;

        const removeButton = document.createElement('button');
        removeButton.textContent = 'Remove';
        removeButton.style.marginLeft = '10px';
        removeButton.style.fontSize = '0.8em';
        removeButton.onclick = () => {
            tempAssignments.splice(index, 1); // Remove from array
            displayTempAssignments(); // Refresh display
        };
        assignmentDiv.appendChild(removeButton);
        displayDiv.appendChild(assignmentDiv);
    });
}

/** Handles clicking the 'Add Assignment' button */
function handleAddTeamAssignment() {
    const teamSelect = document.getElementById('newInitiativeTeamSelect');
    const sdeYearsInput = document.getElementById('newInitiativeSdeYears');
    const teamId = teamSelect.value;
    const sdeYears = parseFloat(sdeYearsInput.value);

    // Validation
    if (!teamId) {
        alert('Please select a team.');
        return;
    }
    if (isNaN(sdeYears) || sdeYears <= 0) {
        alert('Please enter a valid positive number for SDE Years.');
        return;
    }

    // Check if team already assigned in temp list
    const existingIndex = tempAssignments.findIndex(a => a.teamId === teamId);
    if (existingIndex > -1) {
        // Update existing assignment
        tempAssignments[existingIndex].sdeYears = sdeYears;
        console.log(`Updated assignment for team ${teamId} to ${sdeYears}`);
    } else {
        // Add new assignment
        tempAssignments.push({ teamId: teamId, sdeYears: sdeYears });
        console.log(`Added assignment for team ${teamId}: ${sdeYears}`);
    }

    // Refresh display and clear inputs
    displayTempAssignments();
    teamSelect.selectedIndex = 0; // Reset dropdown
    sdeYearsInput.value = '';
}

/** Handles clicking the 'Add Initiative to Plan' button */
function handleAddInitiative() {
    const titleInput = document.getElementById('newInitiativeTitle');
    const descriptionInput = document.getElementById('newInitiativeDescription');
    const goalIdInput = document.getElementById('newInitiativeGoalId');

    const title = titleInput.value.trim();
    const description = descriptionInput.value.trim();
    const goalId = goalIdInput.value.trim() || null; // Use null if empty

    // Validation
    if (!title) {
        alert('Initiative Title cannot be empty.');
        return;
    }
    if (tempAssignments.length === 0) {
        alert('Please add at least one team assignment.');
        return;
    }

    // Create new initiative object
    const newInitiative = {
        initiativeId: 'init-' + Date.now() + '-' + Math.floor(Math.random() * 1000), // Simple unique ID
        title: title,
        description: description,
        relatedBusinessGoalId: goalId,
        isProtected: false, // New initiatives are not protected by default
        assignments: [...tempAssignments] // Copy the temporary assignments
    };

    // Add to main data structure
    if (!currentSystemData.yearlyInitiatives) {
        currentSystemData.yearlyInitiatives = [];
    }
    currentSystemData.yearlyInitiatives.push(newInitiative);
    console.log("Added new initiative:", newInitiative);

    // Clear form and temporary data
    titleInput.value = '';
    descriptionInput.value = '';
    goalIdInput.value = '';
    tempAssignments = [];
    displayTempAssignments(); // Clear display area

    // Refresh the main planning table
    generatePlanningTable();
}

/** Handles clicking the 'Save Current Plan' button */
function handleSavePlan() {
    console.log("Attempting to save plan from planning view...");

    if (!currentSystemData || !currentSystemData.systemName) {
        alert("Cannot save plan: No system data loaded or system name is missing.");
        return;
    }

    // --- Perform Pre-Save Actions ---
    // Ensure global platform dependencies reflect assignments before saving
    buildGlobalPlatformDependencies();
    // Validate engineer assignments (important if edits happened elsewhere)
    if (!validateEngineerAssignments()) {
        // Validation function already shows an alert
        return;
    }
    // Add any other planning-specific validations here if needed later
    // --- End Pre-Save Actions ---


    // --- Save the ENTIRE currentSystemData object to Local Storage ---
    // The yearlyInitiatives array within currentSystemData should reflect the current order and estimates.
    try {
        const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
        const systemNameKey = currentSystemData.systemName; // Use the name stored in the data

        // Save the current data under its name
        systems[systemNameKey] = currentSystemData;
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

        alert(`Plan for system "${systemNameKey}" saved successfully.`);
        console.log('System changes saved to local storage via Save Plan button.');

    } catch (error) {
        console.error("Error saving system to local storage:", error);
        alert("An error occurred while trying to save the plan. Please check the console for details.");
    }
    // ---------------------------------------------------------------
}


// Attach functions to the global window object
window.showSavedSystems = showSavedSystems;
window.createNewSystem = createNewSystem;
window.resetToDefaults = resetToDefaults;
window.returnToHome = returnToHome;
window.showPlanningView = showPlanningView;

// --- Window Resize Listener for Planning Table Height ---
let resizeTimeout;
window.addEventListener('resize', () => {
    // Debounce resize events to avoid excessive calculations
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        // Only adjust if the planning view is currently visible
        const planningViewDiv = document.getElementById('planningView');
        if (planningViewDiv && planningViewDiv.style.display !== 'none') {
            adjustPlanningTableHeight();
        }
    }, 150); // Adjust timeout (milliseconds) as needed
});
// -----------------------------------------------------

</script>

</body>
</html>
