<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Architecture Visualization Tool</title>
    <!-- Include D3.js for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Basic styling */
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { text-align: center; }
        .menu, .edit-menu { text-align: center; margin-bottom: 20px; }
        .menu button, .edit-menu button { margin: 5px; padding: 10px 20px; font-size: 16px; }
        #visualization, #teamVisualization { max-width: 800px; margin: 20px auto; }
        svg { width: 100%; height: 600px; border: 1px solid #ccc; }
        #teamTable { width: 100%; border-collapse: collapse; margin-top: 20px; }
        #teamTable th, #teamTable td { border: 1px solid #ccc; padding: 8px; text-align: left; vertical-align: top; }
        .node text { pointer-events: none; font-size: 12px; }
        .tooltip { position: absolute; text-align: left; width: auto; max-width: 300px; padding: 5px; font: 12px sans-serif; background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; pointer-events: none; }
        .legend { font-size: 12px; display: flex; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; margin-right: 15px; margin-bottom: 5px; }
        .team-edit {margin-bottom: 15px;padding: 10px;border: 1px solid #ccc;}
    
          #returnHomeButton {
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 10px 15px;
          font-size: 14px;
          z-index: 1000;
          }
          .team-edit {
              margin-bottom: 15px;
              border: 1px solid #ccc;
          }
          
          .team-edit h4 {
              margin: 0;
              padding: 10px;
              background-color: #f2f2f2;
          }
          
          .team-details {
              padding: 10px;
              display: none;
          }
          .service-edit {
              margin-bottom: 15px;
              border: 1px solid #ccc;
          }
          
          .service-edit h4 {
              margin: 0;
              padding: 10px;
              background-color: #e6f7ff;
              cursor: pointer;
          }
          
          .service-details {
              padding: 10px;
              display: none;
          }
          
          .api-edit {
              margin-left: 20px;
              margin-bottom: 10px;
              border: 1px solid #ddd;
              padding: 10px;
          }    
          /* Adjust SVG size for service visualization */
          #serviceSvg {
              width: 100%;
              height: 600px;
              border: 1px solid #ccc;
          }
          
          /* Adjust tooltip styling if necessary */
          .tooltip {
              position: absolute;
              text-align: left;
              width: auto;
              max-width: 300px;
              padding: 5px;
              font: 12px sans-serif;
              background: rgba(255, 255, 255, 0.9);
              border: 1px solid #ccc;
              pointer-events: none;
              z-index: 1000;
          }
          /* Dependency visualization styles */
          .node circle {
              fill: #fff;
              stroke: steelblue;
              stroke-width: 2px;
          }
          
          .node text {
              font: 12px sans-serif;
          }
          
          .link {
              fill: none;
              stroke: #ccc;
              stroke-width: 2px;
          }
          
          .tooltip {
              position: absolute;
              text-align: left;
              width: auto;
              max-width: 300px;
              padding: 10px;
              font: 12px sans-serif;
              background: rgba(255, 255, 255, 0.9);
              border: 1px solid #ccc;
              border-radius: 5px;
              pointer-events: none;
              z-index: 1000;
          }
          #serviceDependenciesTable {
              margin-top: 20px;
          }
          
          #serviceDependenciesTable table {
              width: 100%;
              border-collapse: collapse;
          }
          
          #serviceDependenciesTable th, #serviceDependenciesTable td {
              border: 1px solid #ccc;
              padding: 8px;
              text-align: left;
          }
          
          #serviceDependenciesTable th {
              background-color: #f2f2f2;
          }
          
          #serviceDependenciesTable tr:nth-child(even) {
              background-color: #f9f9f9;
          }
          
          #serviceDependenciesTable tr:hover {
              background-color: #e9e9e9;
          }          
          .platform-deps-container {
              display: flex;
              align-items: center;
          }
          .current-deps, .other-deps {
              flex: 1;
              margin: 0 10px;
          }
          .platform-deps-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          .platform-deps-buttons button {
              margin: 5px 0;
          }
          .platform-deps-container select {
              width: 100%;
              min-height: 100px;
          }          
          .service-deps-container {
              display: flex;
              align-items: center;
              margin-bottom: 10px;
          }
          
          .current-service-deps, .other-services {
              flex: 1;
              margin: 0 10px;
          }
          
          .service-deps-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          
          .service-deps-buttons button {
              margin: 5px 0;
          }
          
          .service-deps-container select {
              width: 100%;
              min-height: 100px;
          }
          /* Styles for Dependent APIs */
          .dependent-apis-container {
              display: flex;
              align-items: center;
              margin-bottom: 10px;
          }
          
          .current-dependent-apis, .other-apis {
              flex: 1;
              margin: 0 10px;
          }
          
          .dependent-apis-buttons {
              display: flex;
              flex-direction: column;
              align-items: center;
          }
          
          .dependent-apis-buttons button {
              margin: 5px 0;
          }
          
          .dependent-apis-container select {
              width: 100%;
              min-height: 100px;
          }          
          /* Add any additional styles as needed */          
    </style>
</head>
<body>

<!-- Updated Heading with ID -->
<h1 id="pageTitle">Architecture Visualization Tool</h1>
<p id="systemDescription">Load a previously saved system or create a new system</p>

<!-- Menu for loading systems 
<div class="menu">
    <button onclick="showSavedSystems()">Load Saved System</button>
</div>
-->

<!-- Edit System Button -->
<div class="edit-menu" style="display: none;">
    <button id="editSystemButton" onclick="enterEditMode()">Edit System</button>
    <button id="deleteSystemButton" onclick="deleteSystem()">Delete System</button>   
</div>

<!-- Visualization Section -->
<div id="visualization" style="display:none;">
    <h2>System Visualization</h2>
    <svg id="systemSvg" style="width: 800px; height: 800px;"></svg>
    <!-- Legend -->
    <div id="legend"></div>
</div>

<!-- Team Relationships Visualization -->
<div id="teamVisualization" style="display:none;">
    <h2>Team Relationships Visualization</h2>
    <svg id="teamSvg" style="width: 800px; height: 800px;"></svg>
    <!-- Legend -->
    <div id="teamLegend"></div>
</div>

<!-- Service Relationships Visualization -->
<div id="serviceRelationshipsVisualization" style="display:none;">
    <h2>Service Relationships Visualization</h2>
    <select id="serviceSelection" onchange="updateServiceVisualization()">
        <!-- Options will be populated dynamically -->
    </select>
    <svg id="serviceSvg"></svg>
    <!-- Legend -->
    <div id="serviceLegend"></div>
</div>

<!-- Upstream/Downstream Visualization -->
<div id="dependencyVisualization" style="display:none;">
    <h2>Service Dependency Visualization</h2>
    <select id="dependencyServiceSelection" onchange="updateDependencyVisualization()">
        <!-- Options will be populated dynamically -->
    </select>
    <svg id="dependencySvg" style="width: 800px; height: 600px;"></svg>
    <!-- Legend -->
    <div id="dependencyLegend"></div>
</div>

<!-- Team Breakdown Table -->
<div id="teamBreakdown" style="display:none;">
    <h2>Team Breakdown</h2>
    <table id="teamTable">
        <tr>
            <th>SDM</th>
            <th>Team Identity</th>
            <th>Team Name</th>
            <th>PMT</th>
            <th>Size of Team</th>
            <th>Engineer Names</th>
            <th>Services Owned</th>
        </tr>
    </table>
</div>

<div id="serviceDependenciesTable" style="display:none;">
    <h2>Service Dependencies Table</h2>
    <table>
        <thead>
        <tr>
            <th>Service Name</th>
            <th>Description</th>
            <th>Owning Team</th>
            <th>Upstream Dependencies (Services Depended On)</th>
            <th>Platform Dependencies</th>
            <th>Downstream Dependencies (Services That Depend On This Service)</th>
        </tr>
        </thead>
        <tbody>
            <!-- Rows will be populated dynamically -->
        </tbody>
    </table>
</div>


<!-- System Edit Form -->
<div id="systemEditForm" style="display:none;">
    <h2>Edit System</h2>
    <form id="editSystemForm">
        <label>System Name:</label><br>
        <input type="text" id="systemNameInput"><br><br>
        <label>System Description:</label><br>
        <textarea id="systemDescriptionInput" rows="3" cols="50"></textarea><br><br>
        <button type="button" onclick="saveSystemDetails()">Save System Details</button>
    </form>

    <!-- Services Management Section -->
    <h3>Services</h3>
    <div id="editServicesManagement">
        <!-- Services will be listed here -->
    </div>
    <button type="button" onclick="addNewService()">Add New Service</button><br><br>
    
    <!-- Teams Management Section -->
    <h3>Teams</h3>
    <div id="teamsManagement">
        <!-- Teams will be listed here -->
    </div>
    <button id="addNewTeamButton" type="button" onclick="addNewTeam()">Add New Team</button><br><br>

    <!-- Buttons to Save or Cancel -->
    <button type="button" onclick="saveAllChanges()">Save All Changes</button>
    <button type="button" onclick="exitEditMode()">Cancel</button>
</div>

<!-- 09/28 Added code for Create New system workflow -->
<!-- Menu for loading systems and creating new systems -->
<div class="menu">
    <button onclick="showSavedSystems()">Load Saved System</button>
    <button onclick="createNewSystem()">Create New Software System</button>
    <!-- Add the Reset to Defaults button -->
    <button onclick="resetToDefaults()">Reset to Defaults</button>    
</div>

<!-- System Creation Form -->
<div id="systemCreationForm" style="display:none;">
    <h2>Create New Software System</h2>
    <form id="createSystemForm">
        <label>System Name:</label><br>
        <input type="text" id="newSystemNameInput"><br><br>
        <label>System Description:</label><br>
        <textarea id="newSystemDescriptionInput" rows="3" cols="50"></textarea><br><br>
        <button type="button" onclick="createNewSystem()">Create System</button>
    </form>
</div>

<!-- Return to Home Button -->
<button id="returnHomeButton" onclick="returnToHome()">Return to Home</button>

<script>
/* JavaScript Code */
/* global variables */
/** Define a unique key for local storage **/
const LOCAL_STORAGE_KEY = 'architectureVisualization_systems';
let currentSystemData = null;
let newServiceData = {};
let uniqueEngineers = [];
const Modes = {
    NAVIGATION: 'navigation',
    BROWSING: 'browsing',
    EDITING: 'editing',
    CREATING: 'creating'
};
let currentMode = Modes.NAVIGATION;

/** Sample Data for StreamView **/

const sampleTeamsDataStreamView = [
    {
        teamId: 'team1',
        teamName: 'User Experience Team',
        teamIdentity: 'UX Avengers',
        sizeOfTeam: 5,
        engineerNames: 'Alice Johnson, Mark Evans, Sophia Lee, John Doe, Emma Davis',
        sdmId: 'sdm1',
        pmtId: 'pmt1'
    },
    {
        teamId: 'team2',
        teamName: 'Streaming Team',
        teamIdentity: 'Stream Spartans',
        sizeOfTeam: 4,
        engineerNames: 'Emily Clark, Daniel Thompson, Olivia Brown, Liam Wilson',
        sdmId: 'sdm2',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team3',
        teamName: 'Content Team',
        teamIdentity: 'Content Crusaders',
        sizeOfTeam: 3,
        engineerNames: 'Carol Davis, Kevin Moore, Isabella Martinez',
        sdmId: 'sdm3',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team4',
        teamName: 'Recommendation Team',
        teamIdentity: 'Recommenders of Olympus',
        sizeOfTeam: 4,
        engineerNames: 'Grace Lee, Ethan Harris, Mia Turner, Noah Walker',
        sdmId: 'sdm4',
        pmtId: 'pmt3'
    },
    {
        teamId: 'team5',
        teamName: 'Finance Team',
        teamIdentity: 'Finance Falcons',
        sizeOfTeam: 3,
        engineerNames: 'Ian Turner, Charlotte Adams, Benjamin Scott',
        sdmId: 'sdm5',
        pmtId: 'pmt3'
    },
    {
        teamId: 'team6',
        teamName: 'Communication Team',
        teamIdentity: 'Notification Ninjas',
        sizeOfTeam: 2,
        engineerNames: 'Karen Adams, Lucas Wright',
        sdmId: 'sdm6',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team7',
        teamName: 'Analytics Team',
        teamIdentity: 'Data Dragons',
        sizeOfTeam: 3,
        engineerNames: 'Natalie Green, Andrew Hall, Ella Young',
        sdmId: 'sdm7',
        pmtId: 'pmt4'
    },
    {
        teamId: 'team8',
        teamName: 'Search Team',
        teamIdentity: 'Search Spartans',
        sizeOfTeam: 2,
        engineerNames: 'Zoe King, Michael Baker',
        sdmId: 'sdm8',
        pmtId: 'pmt1'
    }
];

const sampleSDMsDataStreamView = [
    { sdmId: 'sdm1', sdmName: 'Alice Johnson' },
    { sdmId: 'sdm2', sdmName: 'Emily Clark' },
    { sdmId: 'sdm3', sdmName: 'Carol Davis' },
    { sdmId: 'sdm4', sdmName: 'Grace Lee' },
    { sdmId: 'sdm5', sdmName: 'Ian Turner' },
    { sdmId: 'sdm6', sdmName: 'Karen Adams' },
    { sdmId: 'sdm7', sdmName: 'Natalie Green' },
    { sdmId: 'sdm8', sdmName: 'Zoe King' }
];

const samplePMTsDataStreamView = [
    { pmtId: 'pmt1', pmtName: 'Bob Smith' },
    { pmtId: 'pmt2', pmtName: 'Frank Thompson' },
    { pmtId: 'pmt3', pmtName: 'Jane Parker' },
    { pmtId: 'pmt4', pmtName: 'Owen Clark' }
];

//Service Name
//Upstreams: List of services the current service depends on.
//Downstreams: List of services that depend on the current service.
//Platform Dependencies: List of platforms the current service depends on.
//Upstreams: For a given service, upstreams are the services listed in its serviceDependencies.
//Downstreams: For a given service, downstreams are the services that include its name in their serviceDependencies.	

const sampleServicesDataStreamView = [
    {
      serviceName: 'User Management Service',
      serviceDescription: 'Handles user registration, authentication, profiles, and account settings.',
      owningTeamId: 'team1',
      apis: [
          {
              apiName: 'Register API',
              apiDescription: 'Allows new users to sign up.',
              dependentApis: []
          },
          {
              apiName: 'Login API',
              apiDescription: 'Authenticates users and starts a session.',
              dependentApis: []
          },
          {
              apiName: 'Profile API',
              apiDescription: 'Manages user profiles and account settings.',
              dependentApis: []
          },
          {
              apiName: 'Logout API',
              apiDescription: 'Ends the user session.',
              dependentApis: []
          }
      ],
      serviceDependencies: [],
      platformDependencies: ['Auth0', 'AWS DynamoDB']
  },
  {
      serviceName: 'Content Delivery Service',
      serviceDescription: 'Manages content streaming and delivery to users.',
      owningTeamId: 'team2',
      apis: [
          {
              apiName: 'Stream Content API',
              apiDescription: 'Streams selected content to the user.',
              dependentApis: ['Subscription API', 'Profile API']
          },
          {
              apiName: 'Adaptive Bitrate API',
              apiDescription: 'Adjusts streaming quality based on network conditions.',
              dependentApis: []
          },
          {
              apiName: 'Content Caching API',
              apiDescription: 'Manages caching of frequently accessed content.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['Content Management Service', 'User Management Service', 'Billing and Subscription Service'],
      platformDependencies: ['AWS CloudFront', 'AWS S3']
  },
  {
      serviceName: 'Content Management Service',
      serviceDescription: 'Handles content ingestion, metadata, and catalog management.',
      owningTeamId: 'team3',
      apis: [
          {
              apiName: 'Content Ingestion API',
              apiDescription: 'Ingests new content into the platform.',
              dependentApis: []
          },
          {
              apiName: 'Metadata API',
              apiDescription: 'Manages content metadata like titles, descriptions, genres.',
              dependentApis: []
          },
          {
              apiName: 'Catalog API',
              apiDescription: 'Provides the catalog of available content.',
              dependentApis: []
          }
      ],
      serviceDependencies: [],
      platformDependencies: ['AWS S3', 'AWS Lambda']
  },
  {
      serviceName: 'Recommendation Engine Service',
      serviceDescription: 'Provides personalized content recommendations to users based on viewing history and preferences.',
      owningTeamId: 'team4',
      apis: [
          {
              apiName: 'Recommendations API',
              apiDescription: 'Retrieves recommended content for a user.',
              dependentApis: ['User Behavior Tracking API', 'Metadata API']
          },
          {
              apiName: 'User Behavior Tracking API',
              apiDescription: 'Tracks user interactions and viewing history.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Content Management Service', 'Analytics Service'],
      platformDependencies: ['AWS Machine Learning', 'Apache Spark']
  },
  {
      serviceName: 'Billing and Subscription Service',
      serviceDescription: 'Manages user subscriptions, billing, and payment processing.',
      owningTeamId: 'team5',
      apis: [
          {
              apiName: 'Subscription API',
              apiDescription: 'Manages user subscription plans.',
              dependentApis: []
          },
          {
              apiName: 'Payment Processing API',
              apiDescription: 'Processes payments securely.',
              dependentApis: ['Email Notification API']
          },
          {
              apiName: 'Invoice API',
              apiDescription: 'Generates invoices and billing statements.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Notification Service'],
      platformDependencies: ['Stripe API', 'AWS RDS']
  },
  {
      serviceName: 'Notification Service',
      serviceDescription: 'Sends notifications, emails, and in-app messages to users.',
      owningTeamId: 'team6',
      apis: [
          {
              apiName: 'Email Notification API',
              apiDescription: 'Sends email notifications to users.',
              dependentApis: []
          },
          {
              apiName: 'Push Notification API',
              apiDescription: 'Sends push notifications to user devices.',
              dependentApis: ['Profile API']
          },
          {
              apiName: 'In-App Messaging API',
              apiDescription: 'Displays messages within the app.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Billing and Subscription Service'],
      platformDependencies: ['AWS SNS', 'Firebase Cloud Messaging']
  },
  {
      serviceName: 'Analytics Service',
      serviceDescription: 'Collects and analyzes data on user engagement, content performance, and platform metrics.',
      owningTeamId: 'team7',
      apis: [
          {
              apiName: 'Data Collection API',
              apiDescription: 'Collects data from various services.',
              dependentApis: []
          },
          {
              apiName: 'Reporting API',
              apiDescription: 'Provides analytical reports and dashboards.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['User Management Service', 'Content Delivery Service', 'Recommendation Engine Service'],
      platformDependencies: ['AWS Redshift', 'Tableau']
  },
  {
      serviceName: 'Search Service',
      serviceDescription: 'Enables users to search for content across the platform.',
      owningTeamId: 'team8',
      apis: [
          {
              apiName: 'Search API',
              apiDescription: 'Allows users to search for content by title, genre, etc.',
              dependentApis: []
          },
          {
              apiName: 'Autocomplete API',
              apiDescription: 'Provides search suggestions as users type.',
              dependentApis: []
          }
      ],
      serviceDependencies: ['Content Management Service', 'User Management Service'],
      platformDependencies: ['Elasticsearch']
  }
];

const sampleSystemDataStreamView = {
    systemName: 'StreamView',
    systemDescription: 'StreamView is a video streaming platform that provides personalized content to users worldwide.',
    teams: sampleTeamsDataStreamView,
    sdms: sampleSDMsDataStreamView,
    pmts: samplePMTsDataStreamView,
    services: sampleServicesDataStreamView,
    //platformDependencies: [] // Initialize as empty array
};

/** Sample Data for ConnectPro **/

const contactCenterSDMsData = [
    { sdmId: 'sdm1', sdmName: 'Alex Johnson' },         // Manages team1 and team2
    { sdmId: 'sdm2', sdmName: 'Matthew Jackson' },      // Manages team3 and team4
    { sdmId: 'sdm3', sdmName: 'Ryan King' },            // Manages team5 and team6
    { sdmId: 'sdm4', sdmName: 'Laura Turner' }          // Manages team7 and team8
];

const contactCenterPMTsData = [
    { pmtId: 'pmt1', pmtName: 'Karen Davis' },          // Shared between team1 and team8
    { pmtId: 'pmt2', pmtName: 'Patricia Thompson' },    // Shared among team2, team3, team6
    { pmtId: 'pmt3', pmtName: 'Angela Green' },         // Shared between team4 and team5
    { pmtId: 'pmt4', pmtName: 'Stephanie Roberts' }     // PMT for team7
];

const contactCenterTeamsData = [
    {
        teamId: 'team1',
        teamName: 'Customer Experience Team',
        teamIdentity: 'CX Warriors',
        sizeOfTeam: 5,
        engineerNames: 'Alex Johnson, Emily Smith, David Lee, Sarah Brown, Michael Wilson',
        sdmId: 'sdm1',
        pmtId: 'pmt1'
    },
    {
        teamId: 'team2',
        teamName: 'Case Management Team',
        teamIdentity: 'Case Titans',
        sizeOfTeam: 4,
        engineerNames: 'Jessica Taylor, Daniel Moore, Amy Anderson, James Thomas',
        sdmId: 'sdm1',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team3',
        teamName: 'Routing and Agent Tools Team',
        teamIdentity: 'Routing Rangers',
        sizeOfTeam: 7,
        engineerNames: 'Matthew Jackson, Ashley White, Joshua Harris, Andrew Garcia, Megan Clark, Steven Lewis, Nicole Young',
        sdmId: 'sdm2',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team4',
        teamName: 'Agent Tools Team',
        teamIdentity: 'Agent Aces',
        sizeOfTeam: 4,
        engineerNames: 'Andrew Garcia, Megan Clark, Steven Lewis, Nicole Young',
        sdmId: 'sdm2',
        pmtId: 'pmt3'
    },
    {
        teamId: 'team5',
        teamName: 'Communication Channels Team',
        teamIdentity: 'Comm Mandalorians',
        sizeOfTeam: 5,
        engineerNames: 'Ryan King, Samantha Wright, Brandon Lopez, Rachel Hill, Justin Scott',
        sdmId: 'sdm3',
        pmtId: 'pmt3'
    },
    {
        teamId: 'team6',
        teamName: 'Skills Management Team',
        teamIdentity: 'Skill Masters',
        sizeOfTeam: 2,
        engineerNames: 'Kimberly Adams, Jonathan Baker',
        sdmId: 'sdm3',
        pmtId: 'pmt2'
    },
    {
        teamId: 'team7',
        teamName: 'Analytics and Configuration Team',
        teamIdentity: 'Data Wizards',
        sizeOfTeam: 5,
        engineerNames: 'Jason Carter, Melissa Mitchell, Kevin Perez, Laura Turner, Eric Phillips',
        sdmId: 'sdm4',
        pmtId: 'pmt4'
    },
    {
        teamId: 'team8',
        teamName: 'Configuration Team',
        teamIdentity: 'Config Ninjas',
        sizeOfTeam: 2,
        engineerNames: 'Laura Turner, Eric Phillips',
        sdmId: 'sdm4',
        pmtId: 'pmt1'
    }
];

const sampleServicesDataConnectPro = [
    {
        serviceName: 'Customer Portal Service',
        serviceDescription: 'Allows customers to raise support tickets and track their status.',
        owningTeamId: 'team1',
        apis: [
            {
                apiName: 'Ticket Submission API',
                apiDescription: 'Enables customers to submit support tickets.',
                dependentApis: []
            },
            {
                apiName: 'Ticket Tracking API',
                apiDescription: 'Allows customers to check the status of their tickets.',
                dependentApis: []
            }
        ],
        serviceDependencies: [],
        platformDependencies: ['AWS Cognito', 'AWS S3']
    },
    {
        serviceName: 'Case Management Service',
        serviceDescription: 'Manages the lifecycle of support tickets within the system.',
        owningTeamId: 'team2',
        apis: [
            {
                apiName: 'Case Creation API',
                apiDescription: 'Creates a new case in the system.',
                dependentApis: []
            },
            {
                apiName: 'Case Update API',
                apiDescription: 'Updates case details and status.',
                dependentApis: []
            },
            {
                apiName: 'Case Assignment API',
                apiDescription: 'Assigns cases to agents based on skills and availability.',
                dependentApis: ['Skills Assignment API']
            }
        ],
        serviceDependencies: ['Customer Portal Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS DynamoDB']
    },
    {
        serviceName: 'Routing Service',
        serviceDescription: 'Routes incoming interactions to appropriate agents.',
        owningTeamId: 'team3', // Owned by team3
        apis: [
            {
                apiName: 'Interaction Routing API',
                apiDescription: 'Routes voice, email, and chat interactions.',
                dependentApis: ['Skill Matching API', 'Agent Login API']
            },
            {
                apiName: 'Skill Matching API',
                apiDescription: 'Matches interactions to agents based on skills.',
                dependentApis: ['Skills Evaluation API']
            }
        ],
        serviceDependencies: ['Communication Channels Service', 'Skills Management Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS Lambda']
    },
    {
        serviceName: 'Agent Desktop Service',
        serviceDescription: 'Provides agents with tools to handle customer interactions.',
        owningTeamId: 'team4', 
        apis: [
            {
                apiName: 'Agent Login API',
                apiDescription: 'Authenticates agents and starts their session.',
                dependentApis: []
            },
            {
                apiName: 'Interaction Handling API',
                apiDescription: 'Manages ongoing interactions with customers.',
                dependentApis: ['Case Retrieval API']
            },
            {
                apiName: 'Case Retrieval API',
                apiDescription: 'Retrieves case details for agents.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service'],
        platformDependencies: ['AWS AppSync']
    },
    {
        serviceName: 'Communication Channels Service',
        serviceDescription: 'Handles voice calls, emails, and chat messages.',
        owningTeamId: 'team5',
        apis: [
            {
                apiName: 'Voice Call API',
                apiDescription: 'Manages voice call connections.',
                dependentApis: []
            },
            {
                apiName: 'Email Processing API',
                apiDescription: 'Processes incoming and outgoing emails.',
                dependentApis: []
            },
            {
                apiName: 'Chat Messaging API',
                apiDescription: 'Manages live chat sessions.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Routing Service', 'Agent Desktop Service'],
        platformDependencies: ['Amazon Connect', 'AWS SES', 'Amazon Lex']
    },
    {
        serviceName: 'Skills Management Service',
        serviceDescription: 'Manages agent skills and competencies.',
        owningTeamId: 'team6',
        apis: [
            {
                apiName: 'Skills Assignment API',
                apiDescription: 'Assigns skills to agents.',
                dependentApis: []
            },
            {
                apiName: 'Skills Evaluation API',
                apiDescription: 'Evaluates agent performance in skills.',
                dependentApis: []
            }
        ],
        serviceDependencies: [],
        platformDependencies: ['AWS Machine Learning']
    },
    {
        serviceName: 'Reporting and Analytics Service',
        serviceDescription: 'Provides reports on contact center performance.',
        owningTeamId: 'team7',
        apis: [
            {
                apiName: 'Performance Metrics API',
                apiDescription: 'Retrieves metrics on agent and center performance.',
                dependentApis: []
            },
            {
                apiName: 'Historical Data API',
                apiDescription: 'Accesses historical interaction data.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service', 'Agent Desktop Service'],
        platformDependencies: ['AWS Redshift', 'Amazon QuickSight']
    },
    {
        serviceName: 'Business Configuration Service',
        serviceDescription: 'Allows administrators to configure business rules and settings.',
        owningTeamId: 'team8', 
        apis: [
            {
                apiName: 'Settings API',
                apiDescription: 'Manages system-wide settings.',
                dependentApis: []
            },
            {
                apiName: 'Rules Engine API',
                apiDescription: 'Defines routing and assignment rules.',
                dependentApis: []
            }
        ],
        serviceDependencies: ['Case Management Service', 'Routing Service', 'Agent Desktop Service', 'Communication Channels Service', 'Skills Management Service'],
        platformDependencies: ['AWS CloudFormation']
    }
];

const sampleSystemDataContactCenter = {
    systemName: 'ConnectPro',
    systemDescription: 'ConnectPro is a cloud-based contact center solution that streamlines customer interactions across multiple channels.',    
    teams: contactCenterTeamsData,
    sdms: contactCenterSDMsData,
    pmts: contactCenterPMTsData,
    services: sampleServicesDataConnectPro,
    //platformDependencies: [] // Initialize as empty array
};

window.onload = function() {
    console.log("!!! Window on load !!!!");
    
    currentMode = Modes.NAVIGATION;
    // Initialize UI accordingly
};

/** Save Sample Systems to Local Storage **/

function saveSampleSystemsToLocalStorage() {
    if (!localStorage.getItem(LOCAL_STORAGE_KEY)) {
        const systems = {
            'StreamView': sampleSystemDataStreamView,
            'ConnectPro': sampleSystemDataContactCenter
        };
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));
    }
}


// Call the function to save sample systems on page load
saveSampleSystemsToLocalStorage();

/** Show Saved Systems **/

function showSavedSystems() {
    // Retrieve the systems from local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    const systemNames = Object.keys(systems);

    // If no systems are saved, alert the user
    if (systemNames.length === 0) {
        alert('No saved systems found.');
        return;
    }

    // Create a list of systems for the user to select from
    let systemListHtml = '<h2>Select a System to Load</h2><ul>';
    systemNames.forEach(systemName => {
        systemListHtml += `<li><a href="#" onclick="loadSavedSystem('${systemName}')">${systemName}</a></li>`;
    });
    systemListHtml += '</ul>';

    // Display the list in a modal or in a div
    let systemListDiv = document.createElement('div');
    systemListDiv.id = 'systemListDiv';
    systemListDiv.innerHTML = systemListHtml;

    // Add a close button
    let closeButton = document.createElement('button');
    closeButton.innerText = 'Close';
    closeButton.onclick = function() {
        document.body.removeChild(systemListDiv);
    };
    systemListDiv.appendChild(closeButton);

    // Style the div
    systemListDiv.style.position = 'fixed';
    systemListDiv.style.top = '50%';
    systemListDiv.style.left = '50%';
    systemListDiv.style.transform = 'translate(-50%, -50%)';
    systemListDiv.style.backgroundColor = '#fff';
    systemListDiv.style.padding = '20px';
    systemListDiv.style.border = '1px solid #ccc';
    systemListDiv.style.zIndex = '1000';

    // Append the div to the body
    document.body.appendChild(systemListDiv);
}

function buildGlobalPlatformDependencies() {
    const platformDepsSet = new Set();

    // Iterate over services to collect platform dependencies
    currentSystemData.services.forEach(service => {
        if (service.platformDependencies) {
            service.platformDependencies.forEach(dep => {
                platformDepsSet.add(dep);
            });
        }
    });

    // Convert the set to an array and assign to currentSystemData
    currentSystemData.platformDependencies = Array.from(platformDepsSet);
}

/** Load Saved System **/

function loadSavedSystem(systemName) {
    currentMode = Modes.BROWSING;
    
    // Retrieve the systems from local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    const systemData = systems[systemName];

    // **Add console log to see what's in local storage**
    console.log('Loaded systems from local storage:', systems);
    
    if (!systemData) {
        alert('System not found.');
        return;
    }

    // **Add console log to verify currentSystemData**
    console.log('Loaded currentSystemData:', currentSystemData);
    
    // Remove the system list div
    const systemListDiv = document.getElementById('systemListDiv');
    if (systemListDiv) {
        document.body.removeChild(systemListDiv);
    }

    // Clear previous content
    d3.selectAll('.tooltip').remove(); // Remove any existing tooltips
    document.getElementById('teamTable').innerHTML = `
        <tr>
            <th>SDM</th>
            <th>Team Identity</th>
            <th>Team Name</th>
            <th>PMT</th>
            <th>Size of Team</th>
            <th>Engineer Names</th>
            <th>Services Owned</th>
        </tr>
    `;
    document.getElementById('legend').innerHTML = '';
    document.getElementById('teamLegend').innerHTML = '';

    currentSystemData = systemData; // Store the current system data

    // **Add console log to verify currentSystemData**
    console.log('Selected system to load:', currentSystemData);
    
    // Re-initialize uniqueEngineers based on currentSystemData
    uniqueEngineers = [];
    currentSystemData.teams.forEach(team => {
        const engineers = team.engineerNames ? team.engineerNames.split(',').map(name => name.trim()) : [];
        engineers.forEach(engineerName => {
            uniqueEngineers.push({ engineerName, teamId: team.teamId });
        });
    });


   // Ensure platformDependencies is initialized
   if (!currentSystemData.platformDependencies) {
       currentSystemData.platformDependencies = [];
   }
    // Build global platform dependencies list
    buildGlobalPlatformDependencies();
    
    // Update the page title and description
    document.getElementById('pageTitle').innerText = currentSystemData.systemName;
    document.getElementById('systemDescription').innerText = currentSystemData.systemDescription || '';
    
    
    
    // Hide the menu
    document.querySelector('.menu').style.display = 'none';

    // Show the "Edit System" button
    document.querySelector('.edit-menu').style.display = 'block';

    // Display visualization and team breakdown sections
    document.getElementById('visualization').style.display = 'block';
    document.getElementById('teamVisualization').style.display = 'block';
    document.getElementById('teamBreakdown').style.display = 'block';

    // ** Show the new service relationships visualization **
    document.getElementById('serviceRelationshipsVisualization').style.display = 'block';

    // Show the new dependency visualization section
    document.getElementById('dependencyVisualization').style.display = 'block';    

    // Populate the service selection drop-down
    populateServiceSelection();
    
    // Generate the network graph
    generateVisualization(systemData);
    // Generate the team relationships visualization
    generateTeamVisualization(systemData);
    // Generate the team breakdown table
    generateTeamTable(systemData);

    // Generate the initial service relationships visualization (All Services View)
    updateServiceVisualization();

    // Populate the service selection for the dependency visualization
    populateDependencyServiceSelection();

    // Generate the initial dependency visualization
    updateDependencyVisualization();    
    
    //show the services dependency table
    generateServiceDependenciesTable();
    // Show the Service Dependencies Table
    document.getElementById('serviceDependenciesTable').style.display = 'block';    
    
    // Debugging: Log currentSystemData after loading
    console.log('Loaded currentSystemData:', currentSystemData);
    
}


/** Generate System Visualization **/

function generateVisualization(systemData) {
    let svg = d3.select('#systemSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // Set SVG dimensions
    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    // Append a group element that will contain all the graph elements
    let graphGroup = svg.append('g');

    // Define the zoom behavior
    let zoom = d3.zoom()
        .scaleExtent([0.5, 5])
        .on('zoom', zoomed);

    // Apply the zoom behavior to the SVG
    svg.call(zoom);

    // Define the zoomed function
    function zoomed(event) {
        graphGroup.attr('transform', event.transform);
    }

    // Define node radius
    const radius = 10;

    // Prepare nodes and links data
    let nodes = [];
    let links = [];
    let nodeMap = {};

    // Create a color scale based on teams
    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = systemData.teams.map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Create nodes for services and APIs
    systemData.services.forEach(service => {
        let teamId = service.owningTeamId || 'unassigned';
        let nodeColor = teamColorScale(teamId);

        nodes.push({ id: service.serviceName, type: 'service', teamId: teamId, color: nodeColor });
        nodeMap[service.serviceName] = { id: service.serviceName, type: 'service' };

        service.apis.forEach(api => {
            nodes.push({ id: api.apiName, type: 'api', teamId: teamId, color: nodeColor });
            nodeMap[api.apiName] = { id: api.apiName, type: 'api' };
            // Link API to its service
            links.push({
                source: api.apiName,
                target: service.serviceName,
                type: 'api-service'
            });
        });
    });

    // Add platform dependencies as nodes
    systemData.services.forEach(service => {
        service.platformDependencies.forEach(platform => {
            if (!nodeMap[platform]) {
                nodes.push({ id: platform, type: 'platform', color: '#a04040' }); // Platforms have their own color
                nodeMap[platform] = { id: platform, type: 'platform' };
            }
            // Link service to platform
            links.push({
                source: service.serviceName,
                target: platform,
                type: 'platform-dependency'
            });
        });
    });

    // Create links based on service dependencies
    systemData.services.forEach(service => {
        // Service dependencies
        service.serviceDependencies.forEach(dependency => {
            if (nodeMap[dependency]) {
                links.push({
                    source: service.serviceName,
                    target: dependency,
                    type: 'service-dependency'
                });
            }
        });
        // API dependencies
        service.apis.forEach(api => {
            api.dependentApis.forEach(depApi => {
                if (nodeMap[depApi]) {
                    links.push({
                        source: api.apiName,
                        target: depApi,
                        type: 'api-dependency'
                    });
                }
            });
        });
    });

    // Calculate the number of nodes
    const nodeCount = nodes.length;

    // Adjust force strengths based on node count
    let chargeStrength = -300;
    let linkDistance = 100;

    if (nodeCount > 100) {
        chargeStrength = -100;
        linkDistance = 30;
    } else if (nodeCount > 50) {
        chargeStrength = -200;
        linkDistance = 50;
    }

    // Set up the simulation
    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(linkDistance))
        .force('charge', d3.forceManyBody().strength(chargeStrength))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 20));

    // Add links to the graphGroup
    let link = graphGroup.append('g')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-dasharray', d => {
            if (d.type === 'api-service') return '2,2';
            else if (d.type === 'service-dependency') return '5,5';
            else if (d.type === 'platform-dependency') return '10,5';
            else if (d.type === 'api-dependency') return '3,3';
            else return '1,0';
        })
        .attr('stroke-width', 1.5);

    // Add nodes to the graphGroup
    let node = graphGroup.append('g')
        .attr('stroke', '#fff')
        .attr('stroke-width', 1.5)
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', radius)
        .attr('fill', d => d.color)
        .call(drag(simulation));

    // Add labels to the graphGroup
    let labels = graphGroup.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 12)
        .attr('dy', 4)
        .text(d => d.id);

    // Tooltip
    let tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let info = '';
        if (d.type === 'service') {
            let service = systemData.services.find(s => s.serviceName === d.id);
            let team = systemData.teams.find(t => t.teamId === service.owningTeamId);
            info = `<strong>Service Name:</strong> ${service.serviceName}<br>
                    <strong>Description:</strong> ${service.serviceDescription}<br>
                    <strong>Team:</strong> ${team ? `${team.teamName} (${team.teamIdentity})` : 'Unassigned'}`;
        } else if (d.type === 'api') {
            let api;
            let serviceName;
            systemData.services.forEach(service => {
                service.apis.forEach(a => {
                    if (a.apiName === d.id) {
                        api = a;
                        serviceName = service.serviceName;
                    }
                });
            });
            info = `<strong>API Name:</strong> ${api.apiName}<br>
                    <strong>Description:</strong> ${api.apiDescription}<br>
                    <strong>Service:</strong> ${serviceName}`;
        } else if (d.type === 'platform') {
            info = `<strong>Platform Dependency:</strong> ${d.id}`;
        }
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5);
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    // Add legend for teams
    let legendData = systemData.teams.map(team => ({
        teamIdentity: team.teamIdentity,
        color: teamColorScale(team.teamId)
    }));

    let legend = d3.select('#legend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item');

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
}
/** Generate Team Relationships Visualization **/

function generateTeamVisualization(systemData) {
    let svg = d3.select('#teamSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // Set SVG dimensions
    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    // Define node radius
    const radius = 20;
    
    // Prepare nodes and links data
    let nodes = [];
    let links = [];
    let nodeMap = {};

    // Create a color scale for teams
    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = systemData.teams.map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Map teamId to services
    let teamServicesMap = {};
    systemData.services.forEach(service => {
        let teamId = service.owningTeamId;
        if (teamId) { // Ensure teamId is valid
            if (!teamServicesMap[teamId]) {
                teamServicesMap[teamId] = [];
            }
            teamServicesMap[teamId].push(service.serviceName);
        }
    });

    // Create nodes for teams
    systemData.teams.forEach(team => {
        if (team.teamId) { // Ensure teamId is valid
            nodes.push({
                id: team.teamId,
                name: team.teamIdentity,
                type: 'team',
                color: teamColorScale(team.teamId),
                services: teamServicesMap[team.teamId] || []
            });
            nodeMap[team.teamId] = { id: team.teamId };
        }
    });

    // Create links based on service dependencies
    let teamDependencies = {};

    systemData.services.forEach(service => {
        let owningTeamId = service.owningTeamId;
        if (owningTeamId && systemData.teams.some(t => t.teamId === owningTeamId)) { // Ensure owningTeamId is valid
            if (service.serviceDependencies.length > 0) {
                service.serviceDependencies.forEach(dependentServiceName => {
                    let dependentService = systemData.services.find(s => s.serviceName === dependentServiceName);
                    if (dependentService) {
                        let dependentTeamId = dependentService.owningTeamId;
                        if (dependentTeamId && owningTeamId !== dependentTeamId && systemData.teams.some(t => t.teamId === dependentTeamId)) {
                            let linkKey = owningTeamId + '-' + dependentTeamId;
                            if (!teamDependencies[linkKey]) {
                                teamDependencies[linkKey] = true;
                                links.push({
                                    source: owningTeamId,
                                    target: dependentTeamId,
                                    type: 'team-dependency'
                                });
                            }
                        }
                    }
                });
            }
        }
    });

    // Set up the simulation
    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 30));

    // Add links to the SVG
    let link = svg.append('g')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-width', 2);

    // Add nodes to the SVG
    let node = svg.append('g')
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', 20)
        .attr('fill', d => d.color)
        .call(drag(simulation));

    // Add labels to nodes
    let labels = svg.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 0)
        .attr('dy', 4)
        .attr('text-anchor', 'middle')
        .text(d => d.name);

    // Tooltip
    let tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let team = systemData.teams.find(t => t.teamId === d.id);
        let sdm = systemData.sdms.find(s => s.sdmId === team.sdmId);
        let pmt = systemData.pmts.find(p => p.pmtId === team.pmtId);
        let services = d.services.join(', ') || 'None';
        let info = `<strong>Team Identity:</strong> ${team.teamIdentity}<br>
                    <strong>Team Name:</strong> ${team.teamName}<br>
                    <strong>SDM:</strong> ${sdm ? sdm.sdmName : 'N/A'}<br>
                    <strong>PMT:</strong> ${pmt ? pmt.pmtName : 'N/A'}<br>
                    <strong>Size of Team:</strong> ${team.sizeOfTeam}<br>
                    <strong>Engineer Names:</strong> ${team.engineerNames}<br>
                    <strong>Services Owned:</strong> ${services}`;
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5);
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    // Add legend for teams
    let legendData = systemData.teams.map(team => ({
        teamIdentity: team.teamIdentity,
        color: teamColorScale(team.teamId)
    }));

    let legend = d3.select('#teamLegend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item');

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
}

//** Generate Team Breakdown Table **/

function generateTeamTable(systemData) {
    let teamTable = document.getElementById('teamTable');
    // Clear existing rows except header
    teamTable.innerHTML = `
        <tr>
            <th>SDM</th>
            <th>Team Identity</th>
            <th>Team Name</th>
            <th>PMT</th>
            <th>Size of Team</th>
            <th>Engineer Names</th>
            <th>Services Owned</th>
        </tr>
    `;

    // Map teamId to services
    let teamServicesMap = {};
    systemData.services.forEach(service => {
        let teamId = service.owningTeamId;
        if (!teamServicesMap[teamId]) {
            teamServicesMap[teamId] = [];
        }
        teamServicesMap[teamId].push(service.serviceName);
    });

    // Group teams by SDM
    let sdmTeamsMap = {};
    systemData.teams.forEach(team => {
        let sdmId = team.sdmId;
        if (!sdmTeamsMap[sdmId]) {
            sdmTeamsMap[sdmId] = [];
        }
        sdmTeamsMap[sdmId].push(team);
    });

    // Populate the table grouped by SDM
    for (let sdmId in sdmTeamsMap) {
        let sdm = systemData.sdms.find(s => s.sdmId === sdmId);
        let teams = sdmTeamsMap[sdmId];
        teams.forEach((team, index) => {
            let row = teamTable.insertRow();

            // For the first team under the SDM, insert the SDM cell with rowspan
            if (index === 0) {
                let sdmCell = row.insertCell();
                sdmCell.innerText = sdm ? sdm.sdmName : 'N/A';
                sdmCell.rowSpan = teams.length;
                sdmCell.style.verticalAlign = 'top';
            }
            // Do not insert any cell in the SDM column for subsequent teams

            // Insert cells for team data
            row.insertCell().innerText = team.teamIdentity;
            row.insertCell().innerText = team.teamName;
            let pmt = systemData.pmts.find(p => p.pmtId === team.pmtId);
            row.insertCell().innerText = pmt ? pmt.pmtName : 'N/A';
            row.insertCell().innerText = team.sizeOfTeam;
            row.insertCell().innerText = team.engineerNames;
            row.insertCell().innerText = teamServicesMap[team.teamId] ? teamServicesMap[team.teamId].join(', ') : 'None';
            // Modify the code that populates the 'Services Owned' cell
            //row.insertCell().innerText = team.servicesOwned ? team.servicesOwned.join(', ') : 'None';            
        });
    }
}

/** Enter Edit Mode **/

function enterEditMode(creatingNewSystem) {
     if (creatingNewSystem === true) {
          currentMode = Modes.CREATING;
     }
      else {
        currentMode = Modes.EDITNG;
     }
     
    // Show the system edit form
    showSystemEditForm(currentSystemData);
}

/** Show System Edit Form **/

function showSystemEditForm(systemData) {
    // Show the form
    document.getElementById('systemEditForm').style.display = 'block';
    // Hide other sections
    document.getElementById('visualization').style.display = 'none';
    document.getElementById('teamVisualization').style.display = 'none';
    document.getElementById('teamBreakdown').style.display = 'none';
    document.querySelector('.edit-menu').style.display = 'none';
    document.querySelector('.menu').style.display = 'none'; 
    document.getElementById('serviceRelationshipsVisualization').style.display = 'none';
    document.getElementById('dependencyVisualization').style.display = 'none';    
    document.getElementById('serviceDependenciesTable').style.display = 'none';    

    // Populate system name and description
    document.getElementById('systemNameInput').value = systemData.systemName || '';
    console.log("*** 0 document.getElementById('systemNameInput').value",document.getElementById('systemNameInput').value);
    
    document.getElementById('systemDescriptionInput').value = systemData.systemDescription || '';

    // Populate services
    displayServicesForEditing(systemData.services || [], 'editServicesManagement');

    // Populate teams
    displayTeamsForEditing(systemData.teams || []);
    
}

/** Display Teams for Editing **/

function displayTeamsForEditing(teams, expandedIndex = -1) {
    const teamsDiv = document.getElementById('teamsManagement');
    teamsDiv.innerHTML = ''; // Clear existing content

    // Get existing SDMs and PMTs
    const sdmNames = currentSystemData.sdms.map(sdm => sdm.sdmName);
    const pmtNames = currentSystemData.pmts.map(pmt => pmt.pmtName);

    // Get list of all services and their owning teams
    const allServices = currentSystemData.services.map(service => ({
        serviceName: service.serviceName,
        owningTeamId: service.owningTeamId || null
    }));

    // Get list of all engineers and their assigned teams
    const allEngineers = [];
    currentSystemData.teams.forEach(team => {
        const engineers = team.engineerNames ? team.engineerNames.split(',').map(name => name.trim()) : [];
        engineers.forEach(engineer => {
            allEngineers.push({ engineerName: engineer, teamId: team.teamId });
        });
    });

    // Ensure unique engineers
    const uniqueEngineers = [...new Set(allEngineers.map(e => e.engineerName))].map(name => ({
        engineerName: name,
        teamId: allEngineers.find(e => e.engineerName === name).teamId
    }));

    teams.forEach((team, index) => {
        let teamDiv = document.createElement('div');
        teamDiv.className = 'team-edit';

        // Header
        let teamHeader = document.createElement('h4');
        teamHeader.style.cursor = 'pointer';

        let indicator = document.createElement('span');
        indicator.innerText = (index === expandedIndex) ? '- ' : '+ ';
        teamHeader.appendChild(indicator);
        teamHeader.appendChild(document.createTextNode(`Team: ${team.teamIdentity || 'New Team'}`));

        // Details
        let teamDetails = document.createElement('div');
        teamDetails.className = 'team-details';
        teamDetails.style.display = (index === expandedIndex) ? 'block' : 'none';

        // Toggle Functionality
        teamHeader.onclick = () => {
            const isCollapsed = teamDetails.style.display === 'none' || teamDetails.style.display === '';
            teamDetails.style.display = isCollapsed ? 'block' : 'none';
            indicator.innerText = isCollapsed ? '- ' : '+ ';
        };

        // **Team Identity**
        let teamIdentityLabel = document.createElement('label');
        teamIdentityLabel.innerText = 'Team Identity:';
        let teamIdentityInput = document.createElement('input');
        teamIdentityInput.type = 'text';
        teamIdentityInput.value = team.teamIdentity || '';
        teamIdentityInput.setAttribute('data-team-index', index);
        teamIdentityInput.setAttribute('data-field', 'teamIdentity');

        teamDetails.appendChild(teamIdentityLabel);
        teamDetails.appendChild(document.createElement('br'));
        teamDetails.appendChild(teamIdentityInput);
        teamDetails.appendChild(document.createElement('br'));

        // **Team Name**
        let teamNameLabel = document.createElement('label');
        teamNameLabel.innerText = 'Team Name:';
        let teamNameInput = document.createElement('input');
        teamNameInput.type = 'text';
        teamNameInput.value = team.teamName || '';
        teamNameInput.setAttribute('data-team-index', index);
        teamNameInput.setAttribute('data-field', 'teamName');

        teamDetails.appendChild(teamNameLabel);
        teamDetails.appendChild(document.createElement('br'));
        teamDetails.appendChild(teamNameInput);
        teamDetails.appendChild(document.createElement('br'));

        // **Services Owned - Dual Lists**
        // Create container for services
        let servicesContainer = document.createElement('div');
        servicesContainer.className = 'services-container';

        // Left-hand list: Current services
        let currentServicesDiv = document.createElement('div');
        currentServicesDiv.className = 'current-services';

        let currentServicesLabel = document.createElement('label');
        currentServicesLabel.innerText = 'Current Services Owned:';
        currentServicesDiv.appendChild(currentServicesLabel);
        currentServicesDiv.appendChild(document.createElement('br'));

        let currentServicesSelect = document.createElement('select');
        currentServicesSelect.setAttribute('data-team-index', index);
        currentServicesSelect.setAttribute('data-field', 'currentServices');
        currentServicesSelect.multiple = true;
        currentServicesSelect.size = 5;

        // Populate current services
        allServices.forEach(service => {
            if (service.owningTeamId === team.teamId) {
                let option = document.createElement('option');
                option.value = service.serviceName;
                option.text = service.serviceName;
                currentServicesSelect.appendChild(option);
            }
        });

        currentServicesDiv.appendChild(currentServicesSelect);

        // Buttons container
        let servicesButtonsDiv = document.createElement('div');
        servicesButtonsDiv.className = 'services-buttons';
        servicesButtonsDiv.style.display = 'flex';
        servicesButtonsDiv.style.flexDirection = 'column';
        servicesButtonsDiv.style.alignItems = 'center';
        servicesButtonsDiv.style.justifyContent = 'center';

        // Remove Service Button
        let removeServiceButton = document.createElement('button');
        removeServiceButton.type = 'button';
        removeServiceButton.innerText = '> Remove Service';
        removeServiceButton.onclick = () => {
            // Move selected options from currentServicesSelect to availableServicesSelect
            Array.from(currentServicesSelect.selectedOptions).forEach(option => {
                // Remove from currentServicesSelect
                currentServicesSelect.removeChild(option);
                // Add to availableServicesSelect
                availableServicesSelect.appendChild(option);
                // Update service's owningTeamId in currentSystemData
                const service = currentSystemData.services.find(s => s.serviceName === option.value);
                if (service) {
                    service.owningTeamId = null;
                }
            });
        };

        servicesButtonsDiv.appendChild(removeServiceButton);

        // Spacer
        servicesButtonsDiv.appendChild(document.createElement('br'));

        // Add Service Button
        let addServiceButton = document.createElement('button');
        addServiceButton.type = 'button';
        addServiceButton.innerText = '< Add Service';
        addServiceButton.onclick = () => {
            // Move selected options from availableServicesSelect to currentServicesSelect
            Array.from(availableServicesSelect.selectedOptions).forEach(option => {
                // Remove from availableServicesSelect
                availableServicesSelect.removeChild(option);
                // Add to currentServicesSelect
                currentServicesSelect.appendChild(option);
        
                // Update service's owningTeamId
                const service = currentSystemData.services.find(s => s.serviceName === option.value);
                if (service) {
                    // Remove service from previous team's UI
                    if (service.owningTeamId && service.owningTeamId !== team.teamId) {
                        removeServiceFromPreviousTeam(service.serviceName, service.owningTeamId);
                    }
                    // Update service's owningTeamId
                    service.owningTeamId = team.teamId;
                }
            });
        };

        servicesButtonsDiv.appendChild(addServiceButton);

        // Right-hand list: Available services
        let availableServicesDiv = document.createElement('div');
        availableServicesDiv.className = 'available-services';

        let availableServicesLabel = document.createElement('label');
        availableServicesLabel.innerText = 'Available Services:';
        availableServicesDiv.appendChild(availableServicesLabel);
        availableServicesDiv.appendChild(document.createElement('br'));

        let availableServicesSelect = document.createElement('select');
        availableServicesSelect.setAttribute('data-team-index', index);
        availableServicesSelect.setAttribute('data-field', 'availableServices');
        availableServicesSelect.multiple = true;
        availableServicesSelect.size = 5;

        // Populate available services (services not owned by this team)
        allServices.forEach(service => {
            if (service.owningTeamId !== team.teamId) {
                let option = document.createElement('option');
                option.value = service.serviceName;
                option.text = service.serviceName;
                availableServicesSelect.appendChild(option);
            }
        });

        availableServicesDiv.appendChild(availableServicesSelect);

        // Assemble the container
        servicesContainer.style.display = 'flex';
        servicesContainer.style.alignItems = 'center';
        servicesContainer.appendChild(currentServicesDiv);
        servicesContainer.appendChild(servicesButtonsDiv);
        servicesContainer.appendChild(availableServicesDiv);

        teamDetails.appendChild(servicesContainer);
        teamDetails.appendChild(document.createElement('br'));

        // **SDM Assignment**
        /*** Begin SDM Assignment dual lists ***/
        
        // Create container for SDM assignment
        let sdmsContainer = document.createElement('div');
        sdmsContainer.className = 'sdms-container';
        
        // Left-hand list: Current SDM
        let currentSdmDiv = document.createElement('div');
        currentSdmDiv.className = 'current-sdm';
        
        let currentSdmLabel = document.createElement('label');
        currentSdmLabel.innerText = 'Current SDM:';
        currentSdmDiv.appendChild(currentSdmLabel);
        currentSdmDiv.appendChild(document.createElement('br'));
        
        let currentSdmSelect = document.createElement('select');
        currentSdmSelect.setAttribute('data-team-index', index);
        currentSdmSelect.setAttribute('data-field', 'currentSdm');
        currentSdmSelect.size = 5; // Adjust size as needed
        
        // Since only one SDM can be assigned, no 'multiple' attribute
        
        // Get the assigned SDM based on sdmId
        let assignedSdm = currentSystemData.sdms.find(sdm => sdm.sdmId === team.sdmId);
        
        if (assignedSdm) {
            let option = document.createElement('option');
            option.value = assignedSdm.sdmId;
            option.text = assignedSdm.sdmName;
            currentSdmSelect.appendChild(option);
        }
        
        currentSdmDiv.appendChild(currentSdmSelect);
        
        // Buttons container
        let sdmsButtonsDiv = document.createElement('div');
        sdmsButtonsDiv.className = 'sdms-buttons';
        sdmsButtonsDiv.style.display = 'flex';
        sdmsButtonsDiv.style.flexDirection = 'column';
        sdmsButtonsDiv.style.alignItems = 'center';
        sdmsButtonsDiv.style.justifyContent = 'center';
        
        // Remove SDM Button
        let removeSdmButton = document.createElement('button');
        removeSdmButton.type = 'button';
        removeSdmButton.innerText = '> Remove SDM';
        removeSdmButton.onclick = () => {
            let option = currentSdmSelect.options[0];
            if (option) {
                currentSdmSelect.removeChild(option);
                availableSdmsSelect.appendChild(option);
                // Update team.sdmId
                team.sdmId = null;
            }
        };
        
        sdmsButtonsDiv.appendChild(removeSdmButton);
        
        // Spacer
        sdmsButtonsDiv.appendChild(document.createElement('br'));
        
        // Add SDM Button
        let addSdmButton = document.createElement('button');
        addSdmButton.type = 'button';
        addSdmButton.innerText = '< Add SDM';
        addSdmButton.onclick = () => {
            let selectedOption = availableSdmsSelect.options[availableSdmsSelect.selectedIndex];
            if (selectedOption) {
                // Remove any existing SDM from currentSdmSelect
                while (currentSdmSelect.firstChild) {
                    let existingOption = currentSdmSelect.firstChild;
                    currentSdmSelect.removeChild(existingOption);
                    availableSdmsSelect.appendChild(existingOption);
                }
        
                // Remove from availableSdmsSelect
                availableSdmsSelect.removeChild(selectedOption);
                // Add to currentSdmSelect
                currentSdmSelect.appendChild(selectedOption);
        
                // Update team.sdmId
                team.sdmId = selectedOption.value;
            }
        };
        
        sdmsButtonsDiv.appendChild(addSdmButton);
        
        // Right-hand list: Available SDMs
        let availableSdmsDiv = document.createElement('div');
        availableSdmsDiv.className = 'available-sdms';
        
        let availableSdmsLabel = document.createElement('label');
        availableSdmsLabel.innerText = 'Available SDMs:';
        availableSdmsDiv.appendChild(availableSdmsLabel);
        availableSdmsDiv.appendChild(document.createElement('br'));
        
        let availableSdmsSelect = document.createElement('select');
        availableSdmsSelect.setAttribute('data-team-index', index);
        availableSdmsSelect.setAttribute('data-field', 'availableSdms');
        availableSdmsSelect.size = 5;
        
        // Populate available SDMs (SDMs not assigned to this team)
        currentSystemData.sdms.forEach(sdm => {
            if (sdm.sdmId !== team.sdmId) {
                let option = document.createElement('option');
                option.value = sdm.sdmId;
                option.text = sdm.sdmName;
                availableSdmsSelect.appendChild(option);
            }
        });
        
        availableSdmsDiv.appendChild(availableSdmsSelect);
        
        // Input to add new SDM
        let newSdmInputLabel = document.createElement('label');
        newSdmInputLabel.innerText = 'Add New SDM:';
        let newSdmInputContainer = document.createElement('div');
        newSdmInputContainer.style.display = 'flex';
        newSdmInputContainer.style.alignItems = 'center';
        
        let newSdmInput = document.createElement('input');
        newSdmInput.type = 'text';
        newSdmInput.placeholder = 'Enter SDM name';
        newSdmInput.setAttribute('data-team-index', index);
        newSdmInput.setAttribute('data-field', 'newSdmName');
        
        let addNewSdmButton = document.createElement('button');
        addNewSdmButton.type = 'button';
        addNewSdmButton.innerText = 'Add';
        addNewSdmButton.onclick = () => {
            const sdmName = newSdmInput.value.trim();
            if (sdmName !== '') {
                // Check if SDM already exists
                let existingSdm = currentSystemData.sdms.find(sdm => sdm.sdmName === sdmName);
                if (!existingSdm) {
                    // Add to currentSystemData.sdms
                    const newSdmId = 'sdm' + (currentSystemData.sdms.length + 1);
                    const newSdm = { sdmId: newSdmId, sdmName: sdmName };
                    currentSystemData.sdms.push(newSdm);
        
                    // Remove any existing SDM from currentSdmSelect
                    while (currentSdmSelect.firstChild) {
                        let existingOption = currentSdmSelect.firstChild;
                        currentSdmSelect.removeChild(existingOption);
                        availableSdmsSelect.appendChild(existingOption);
                    }
        
                    // Add new SDM to currentSdmSelect
                    let option = document.createElement('option');
                    option.value = newSdm.sdmId;
                    option.text = newSdm.sdmName;
                    currentSdmSelect.appendChild(option);
        
                    // Update team.sdmId
                    team.sdmId = newSdm.sdmId;
                } else {
                    alert(`SDM "${sdmName}" already exists.`);
                }
        
                // Clear the input
                newSdmInput.value = '';
            }
        };
        
        newSdmInputContainer.appendChild(newSdmInput);
        newSdmInputContainer.appendChild(addNewSdmButton);
        
        // Assemble the SDMs container
        sdmsContainer.style.display = 'flex';
        sdmsContainer.style.alignItems = 'center';
        sdmsContainer.appendChild(currentSdmDiv);
        sdmsContainer.appendChild(sdmsButtonsDiv);
        sdmsContainer.appendChild(availableSdmsDiv);
        
        teamDetails.appendChild(sdmsContainer);
        teamDetails.appendChild(document.createElement('br'));
        teamDetails.appendChild(newSdmInputLabel);
        teamDetails.appendChild(document.createElement('br'));
        teamDetails.appendChild(newSdmInputContainer);
        teamDetails.appendChild(document.createElement('br'));
        /*** End SDM Assignment - Dual Lists ***/

        // **PMT Assignment**
        /*** Begin PMT Assignment ***/
        
        // Create container for PMT assignment
        let pmtsContainer = document.createElement('div');
        pmtsContainer.className = 'pmts-container';
        
        // Left-hand list: Current PMT
        let currentPmtDiv = document.createElement('div');
        currentPmtDiv.className = 'current-pmt';
        
        let currentPmtLabel = document.createElement('label');
        currentPmtLabel.innerText = 'Current PMT:';
        currentPmtDiv.appendChild(currentPmtLabel);
        currentPmtDiv.appendChild(document.createElement('br'));
        
        let currentPmtSelect = document.createElement('select');
        currentPmtSelect.setAttribute('data-team-index', index);
        currentPmtSelect.setAttribute('data-field', 'currentPmt');
        currentPmtSelect.size = 5; // Adjust size as needed
        
        // Since only one PMT can be assigned, no 'multiple' attribute
        
        // Get the assigned PMT based on pmtId
        let assignedPmt = currentSystemData.pmts.find(pmt => pmt.pmtId === team.pmtId);
        
        if (assignedPmt) {
            let option = document.createElement('option');
            option.value = assignedPmt.pmtId;
            option.text = assignedPmt.pmtName;
            currentPmtSelect.appendChild(option);
        }
        
        currentPmtDiv.appendChild(currentPmtSelect);
        
        // Buttons container
        let pmtsButtonsDiv = document.createElement('div');
        pmtsButtonsDiv.className = 'pmts-buttons';
        pmtsButtonsDiv.style.display = 'flex';
        pmtsButtonsDiv.style.flexDirection = 'column';
        pmtsButtonsDiv.style.alignItems = 'center';
        pmtsButtonsDiv.style.justifyContent = 'center';
        
        // Remove PMT Button
        let removePmtButton = document.createElement('button');
        removePmtButton.type = 'button';
        removePmtButton.innerText = '> Remove PMT';
        removePmtButton.onclick = () => {
            let option = currentPmtSelect.options[0];
            if (option) {
                currentPmtSelect.removeChild(option);
                availablePmtsSelect.appendChild(option);
                // Update team.pmtId
                team.pmtId = null;
            }
        };
        
        pmtsButtonsDiv.appendChild(removePmtButton);
        
        // Spacer
        pmtsButtonsDiv.appendChild(document.createElement('br'));
        
        // Add PMT Button
        let addPmtButton = document.createElement('button');
        addPmtButton.type = 'button';
        addPmtButton.innerText = '< Add PMT';
        addPmtButton.onclick = () => {
            let selectedOption = availablePmtsSelect.options[availablePmtsSelect.selectedIndex];
            if (selectedOption) {
                // Remove any existing PMT from currentPmtSelect
                while (currentPmtSelect.firstChild) {
                    let existingOption = currentPmtSelect.firstChild;
                    currentPmtSelect.removeChild(existingOption);
                    availablePmtsSelect.appendChild(existingOption);
                }
        
                // Remove from availablePmtsSelect
                availablePmtsSelect.removeChild(selectedOption);
                // Add to currentPmtSelect
                currentPmtSelect.appendChild(selectedOption);
        
                // Update team.pmtId
                team.pmtId = selectedOption.value;
            }
        };
        
        pmtsButtonsDiv.appendChild(addPmtButton);
        
        // Right-hand list: Available PMTs
        let availablePmtsDiv = document.createElement('div');
        availablePmtsDiv.className = 'available-pmts';
        
        let availablePmtsLabel = document.createElement('label');
        availablePmtsLabel.innerText = 'Available PMTs:';
        availablePmtsDiv.appendChild(availablePmtsLabel);
        availablePmtsDiv.appendChild(document.createElement('br'));
        
        let availablePmtsSelect = document.createElement('select');
        availablePmtsSelect.setAttribute('data-team-index', index);
        availablePmtsSelect.setAttribute('data-field', 'availablePmts');
        availablePmtsSelect.size = 5;
        
        // Populate available PMTs (PMTs not assigned to this team)
        currentSystemData.pmts.forEach(pmt => {
            if (pmt.pmtId !== team.pmtId) {
                let option = document.createElement('option');
                option.value = pmt.pmtId;
                option.text = pmt.pmtName;
                availablePmtsSelect.appendChild(option);
            }
        });
        
        availablePmtsDiv.appendChild(availablePmtsSelect);
        
        // Input to add new PMT
        let newPmtInputLabel = document.createElement('label');
        newPmtInputLabel.innerText = 'Add New PMT:';
        let newPmtInputContainer = document.createElement('div');
        newPmtInputContainer.style.display = 'flex';
        newPmtInputContainer.style.alignItems = 'center';
        
        let newPmtInput = document.createElement('input');
        newPmtInput.type = 'text';
        newPmtInput.placeholder = 'Enter PMT name';
        newPmtInput.setAttribute('data-team-index', index);
        newPmtInput.setAttribute('data-field', 'newPmtName');
        
        let addNewPmtButton = document.createElement('button');
        addNewPmtButton.type = 'button';
        addNewPmtButton.innerText = 'Add';
        addNewPmtButton.onclick = () => {
            const pmtName = newPmtInput.value.trim();
            if (pmtName !== '') {
                // Check if PMT already exists
                let existingPmt = currentSystemData.pmts.find(p => p.pmtName === pmtName);
                if (!existingPmt) {
                    // Add to currentSystemData.pmts
                    const newPmtId = 'pmt' + (currentSystemData.pmts.length + 1);
                    const newPmt = { pmtId: newPmtId, pmtName: pmtName };
                    currentSystemData.pmts.push(newPmt);
        
                    // Remove any existing PMT from currentPmtSelect
                    while (currentPmtSelect.firstChild) {
                        let existingOption = currentPmtSelect.firstChild;
                        currentPmtSelect.removeChild(existingOption);
                        availablePmtsSelect.appendChild(existingOption);
                    }
        
                    // Add new PMT to currentPmtSelect
                    let option = document.createElement('option');
                    option.value = newPmt.pmtId;
                    option.text = newPmt.pmtName;
                    currentPmtSelect.appendChild(option);
        
                    // Update team.pmtId
                    team.pmtId = newPmt.pmtId;
                } else {
                    alert(`PMT "${pmtName}" already exists.`);
                }
        
                // Clear the input
                newPmtInput.value = '';
            }
        };
        
        newPmtInputContainer.appendChild(newPmtInput);
        newPmtInputContainer.appendChild(addNewPmtButton);
        
        // Assemble the PMTs container
        pmtsContainer.style.display = 'flex';
        pmtsContainer.style.alignItems = 'center';
        pmtsContainer.appendChild(currentPmtDiv);
        pmtsContainer.appendChild(pmtsButtonsDiv);
        pmtsContainer.appendChild(availablePmtsDiv);
        
        teamDetails.appendChild(pmtsContainer);
        teamDetails.appendChild(document.createElement('br'));
        teamDetails.appendChild(newPmtInputLabel);
        teamDetails.appendChild(document.createElement('br'));
        teamDetails.appendChild(newPmtInputContainer);
        teamDetails.appendChild(document.createElement('br'));
        /*** End PMT Assignment ***/        
        
        // **Size of Team**
        let sizeLabel = document.createElement('label');
        sizeLabel.innerText = 'Size of Team:';
        let sizeInput = document.createElement('input');
        sizeInput.type = 'number';
        sizeInput.value = team.sizeOfTeam || 1;
        sizeInput.setAttribute('data-team-index', index);
        sizeInput.setAttribute('data-field', 'sizeOfTeam');

        teamDetails.appendChild(sizeLabel);
        teamDetails.appendChild(document.createElement('br'));
        teamDetails.appendChild(sizeInput);
        teamDetails.appendChild(document.createElement('br'));

        // **Engineer Assignment - Dual Lists**
        // Create container for engineers
        let engineersContainer = document.createElement('div');
        engineersContainer.className = 'engineers-container';

        // Left-hand list: Current engineers
        let currentEngineersDiv = document.createElement('div');
        currentEngineersDiv.className = 'current-engineers';

        let currentEngineersLabel = document.createElement('label');
        currentEngineersLabel.innerText = 'Current Engineers:';
        currentEngineersDiv.appendChild(currentEngineersLabel);
        currentEngineersDiv.appendChild(document.createElement('br'));

        let currentEngineersSelect = document.createElement('select');
        currentEngineersSelect.setAttribute('data-team-index', index);
        currentEngineersSelect.setAttribute('data-field', 'currentEngineers');
        currentEngineersSelect.multiple = true;
        currentEngineersSelect.size = 5;

        // Populate current engineers
        const teamEngineers = team.engineerNames ? team.engineerNames.split(',').map(name => name.trim()) : [];
        teamEngineers.forEach(engineerName => {
            let option = document.createElement('option');
            option.value = engineerName;
            option.text = engineerName;
            currentEngineersSelect.appendChild(option);
        });

        currentEngineersDiv.appendChild(currentEngineersSelect);

        // Buttons container
        let engineersButtonsDiv = document.createElement('div');
        engineersButtonsDiv.className = 'engineers-buttons';
        engineersButtonsDiv.style.display = 'flex';
        engineersButtonsDiv.style.flexDirection = 'column';
        engineersButtonsDiv.style.alignItems = 'center';
        engineersButtonsDiv.style.justifyContent = 'center';

        // Remove Engineer Button
        let removeEngineerButton = document.createElement('button');
        removeEngineerButton.type = 'button';
        removeEngineerButton.innerText = '> Remove Engineer';
        removeEngineerButton.onclick = () => {
            // Move selected options from currentEngineersSelect to availableEngineersSelect
            Array.from(currentEngineersSelect.selectedOptions).forEach(option => {
                // Remove from currentEngineersSelect
                currentEngineersSelect.removeChild(option);
                // Add to availableEngineersSelect
                availableEngineersSelect.appendChild(option);
        
              // Update engineer's team assignment
              const engineerName = option.value;
              const engineer = uniqueEngineers.find(e => e.engineerName === engineerName);
              if (engineer) {
                  engineer.teamId = null;
              }
      
              // **Update team.engineerNames in currentSystemData**
              if (team.engineerNames) {
                  let engineerList = team.engineerNames.split(',').map(name => name.trim());
                  engineerList = engineerList.filter(name => name !== engineerName);
                  team.engineerNames = engineerList.join(', ');
              }
      
              // Update team size
              updateTeamSize(index, currentEngineersSelect.options.length);
          });
        
            // **Recalculate and Update Team Size**
            updateTeamSize(index, currentEngineersSelect.options.length);
        };

        engineersButtonsDiv.appendChild(removeEngineerButton);

        // Spacer
        engineersButtonsDiv.appendChild(document.createElement('br'));

        // Add Engineer Button
        let addEngineerButton = document.createElement('button');
        addEngineerButton.type = 'button';
        addEngineerButton.innerText = '< Add Engineer';
        addEngineerButton.onclick = () => {
            // Move selected options from availableEngineersSelect to currentEngineersSelect
            Array.from(availableEngineersSelect.selectedOptions).forEach(option => {
                // Remove from availableEngineersSelect
                availableEngineersSelect.removeChild(option);
                // Add to currentEngineersSelect
                currentEngineersSelect.appendChild(option);
        
                // Update engineer's team assignment
                const engineerName = option.value;
                const engineer = uniqueEngineers.find(e => e.engineerName === engineerName);
                if (engineer) {
                    // Remove engineer from previous team's UI...
                    engineer.teamId = team.teamId;
                } else {
                    uniqueEngineers.push({ engineerName: engineerName, teamId: team.teamId });
                }
        
                // **Update team.engineerNames in currentSystemData**
                if (!team.engineerNames) {
                    team.engineerNames = engineerName;
                } else {
                    const engineerList = team.engineerNames.split(',').map(name => name.trim());
                    if (!engineerList.includes(engineerName)) {
                        engineerList.push(engineerName);
                        team.engineerNames = engineerList.join(', ');
                    }
                }
        
                // Update team size
                updateTeamSize(index, currentEngineersSelect.options.length);
            });
        
            // **Recalculate and Update Team Size**
            updateTeamSize(index, currentEngineersSelect.options.length);
        };

        engineersButtonsDiv.appendChild(addEngineerButton);

        // Right-hand list: Available engineers
        let availableEngineersDiv = document.createElement('div');
        availableEngineersDiv.className = 'available-engineers';

        let availableEngineersLabel = document.createElement('label');
        availableEngineersLabel.innerText = 'Available Engineers:';
        availableEngineersDiv.appendChild(availableEngineersLabel);
        availableEngineersDiv.appendChild(document.createElement('br'));

        let availableEngineersSelect = document.createElement('select');
        availableEngineersSelect.setAttribute('data-team-index', index);
        availableEngineersSelect.setAttribute('data-field', 'availableEngineers');
        availableEngineersSelect.multiple = true;
        availableEngineersSelect.size = 5;

        // Populate available engineers (not assigned to this team)
        uniqueEngineers.forEach(engineer => {
            if (engineer.teamId !== team.teamId) {
                let option = document.createElement('option');
                option.value = engineer.engineerName;
                option.text = engineer.engineerName;
                availableEngineersSelect.appendChild(option);
            }
        });

        availableEngineersDiv.appendChild(availableEngineersSelect);

        // Input to add new engineer
        let newEngineerInputLabel = document.createElement('label');
        newEngineerInputLabel.innerText = 'Add New Engineer:';
        let newEngineerInputContainer = document.createElement('div');
        newEngineerInputContainer.style.display = 'flex';
        newEngineerInputContainer.style.alignItems = 'center';

        let newEngineerInput = document.createElement('input');
        newEngineerInput.type = 'text';
        newEngineerInput.placeholder = 'Enter engineer name';
        newEngineerInput.setAttribute('data-team-index', index);
        newEngineerInput.setAttribute('data-field', 'newEngineerName');

        let addNewEngineerButton = document.createElement('button');
        addNewEngineerButton.type = 'button';
        addNewEngineerButton.innerText = 'Add';
        addNewEngineerButton.onclick = () => {
        const engineerName = newEngineerInput.value.trim();
        if (engineerName !== '') {
            // Check if engineer already exists
            const existingEngineer = uniqueEngineers.find(e => e.engineerName === engineerName);
            if (existingEngineer) {
                alert(`Engineer "${engineerName}" already exists.`);
                newEngineerInput.value = '';
                return;
            }
    
            // Add to uniqueEngineers
            uniqueEngineers.push({ engineerName: engineerName, teamId: team.teamId });
    
            // Add to currentEngineersSelect
            let option = document.createElement('option');
            option.value = engineerName;
            option.text = engineerName;
            currentEngineersSelect.appendChild(option);
    
            // **Update team.engineerNames in currentSystemData**
            if (!team.engineerNames) {
                team.engineerNames = engineerName;
            } else {
                const engineerList = team.engineerNames.split(',').map(name => name.trim());
                engineerList.push(engineerName);
                team.engineerNames = engineerList.join(', ');
            }
    
            // Update team size
            updateTeamSize(index, currentEngineersSelect.options.length);
    
            // Update available engineers in other teams...
            updateAvailableEngineersInOtherTeams(engineerName, team.teamId);
    
            // Clear the input
            newEngineerInput.value = '';
        }
    };

        newEngineerInputContainer.appendChild(newEngineerInput);
        newEngineerInputContainer.appendChild(addNewEngineerButton);

        // Assemble the container
        engineersContainer.style.display = 'flex';
        engineersContainer.style.alignItems = 'center';
        engineersContainer.appendChild(currentEngineersDiv);
        engineersContainer.appendChild(engineersButtonsDiv);
        engineersContainer.appendChild(availableEngineersDiv);

        teamDetails.appendChild(engineersContainer);
        teamDetails.appendChild(document.createElement('br'));
        teamDetails.appendChild(newEngineerInputLabel);
        teamDetails.appendChild(document.createElement('br'));
        teamDetails.appendChild(newEngineerInputContainer);
        teamDetails.appendChild(document.createElement('br'));

        // **Save and Delete Buttons**
        // Save Team Changes Button
        let saveButton = document.createElement('button');
        saveButton.type = 'button';
        saveButton.innerText = 'Save Team Changes';
        saveButton.onclick = () => saveTeamChanges(index, teamHeader, team, uniqueEngineers);

        teamDetails.appendChild(saveButton);

        // Delete Team Button
        let deleteButton = document.createElement('button');
        deleteButton.type = 'button';
        deleteButton.innerText = 'Delete Team';
        deleteButton.onclick = () => deleteTeam(index);

        teamDetails.appendChild(deleteButton);

        // Append to DOM
        teamDiv.appendChild(teamHeader);
        teamDiv.appendChild(teamDetails);
        teamsDiv.appendChild(teamDiv);
    });

    // Event Listeners for Inputs
    const inputs = teamsDiv.querySelectorAll('input, textarea, select');
    inputs.forEach(input => {
        input.addEventListener('change', (event) => {
            const index = event.target.getAttribute('data-team-index');
            const field = event.target.getAttribute('data-field');
            let value = event.target.value;

            if (field === 'sizeOfTeam') {
                value = parseInt(value, 10) || 1;
            }

            currentSystemData.teams[index][field] = value;
        });
    });
}

function updateTeamSize(teamIndex, newSize) {
    currentSystemData.teams[teamIndex].sizeOfTeam = newSize;

    // Update the UI element for "Size of Team"
    const teamDiv = document.querySelectorAll('.team-edit')[teamIndex];
    const sizeInput = teamDiv.querySelector('input[data-field="sizeOfTeam"]');
    sizeInput.value = newSize;

    // **Update sizeOfTeam in currentSystemData**
    currentSystemData.teams[teamIndex].sizeOfTeam = newSize;
}

function updateAvailableEngineersInOtherTeams(engineerName, assignedTeamId) {
    // Loop through all teams
    currentSystemData.teams.forEach((team, idx) => {
        // Skip the team where the engineer was just added or removed
        if (team.teamId === assignedTeamId) {
            return;
        }

        const teamDiv = document.querySelectorAll('.team-edit')[idx];
        const availableEngineersSelect = teamDiv.querySelector('select[data-field="availableEngineers"]');
        const currentEngineersSelect = teamDiv.querySelector('select[data-field="currentEngineers"]');

        if (assignedTeamId) {
            // Remove from availableEngineersSelect
            const option = Array.from(availableEngineersSelect.options).find(opt => opt.value === engineerName);
            if (option) {
                availableEngineersSelect.removeChild(option);
            }
        } else {
            // Add to availableEngineersSelect if not already present
            const optionExists = Array.from(availableEngineersSelect.options).some(opt => opt.value === engineerName);
            const inCurrentEngineers = Array.from(currentEngineersSelect.options).some(opt => opt.value === engineerName);
            if (!optionExists && !inCurrentEngineers) {
                let option = document.createElement('option');
                option.value = engineerName;
                option.text = engineerName;
                availableEngineersSelect.appendChild(option);
            }
        }
    });
}

function updateAvailableServicesInOtherTeams(serviceName, assignedTeamId) {
    // Loop through all teams
    currentSystemData.teams.forEach((team, idx) => {
        // Skip the team where the service was just added or removed
        if (team.teamId === assignedTeamId) {
            return;
        }

        const teamDiv = document.querySelectorAll('.team-edit')[idx];
        const availableServicesSelect = teamDiv.querySelector('select[data-field="availableServices"]');
        const currentServicesSelect = teamDiv.querySelector('select[data-field="currentServices"]');

        if (assignedTeamId) {
            // Remove from availableServicesSelect
            const option = Array.from(availableServicesSelect.options).find(opt => opt.value === serviceName);
            if (option) {
                availableServicesSelect.removeChild(option);
            }
        } else {
            // Add to availableServicesSelect if not already present
            const optionExists = Array.from(availableServicesSelect.options).some(opt => opt.value === serviceName);
            const inCurrentServices = Array.from(currentServicesSelect.options).some(opt => opt.value === serviceName);
            if (!optionExists && !inCurrentServices) {
                let option = document.createElement('option');
                option.value = serviceName;
                option.text = serviceName;
                availableServicesSelect.appendChild(option);
            }
        }
    });
}

function removeServiceFromPreviousTeam(serviceName, prevTeamId) {
    const prevTeamIndex = currentSystemData.teams.findIndex(t => t.teamId === prevTeamId);
    if (prevTeamIndex !== -1) {
        const prevTeamDiv = document.querySelectorAll('.team-edit')[prevTeamIndex];
        const prevCurrentServicesSelect = prevTeamDiv.querySelector('select[data-field="currentServices"]');
        const prevOption = Array.from(prevCurrentServicesSelect.options).find(opt => opt.value === serviceName);
        if (prevOption) {
            prevCurrentServicesSelect.removeChild(prevOption);
            // Add to availableServicesSelect of previous team
            const prevAvailableServicesSelect = prevTeamDiv.querySelector('select[data-field="availableServices"]');
            prevAvailableServicesSelect.appendChild(prevOption.cloneNode(true));
        }
    }
}

function removeEngineerFromPreviousTeam(engineerName, prevTeamId) {
    const prevTeamIndex = currentSystemData.teams.findIndex(t => t.teamId === prevTeamId);
    if (prevTeamIndex !== -1) {
        const prevTeamDiv = document.querySelectorAll('.team-edit')[prevTeamIndex];
        const prevCurrentEngineersSelect = prevTeamDiv.querySelector('select[data-field="currentEngineers"]');
        const prevOption = Array.from(prevCurrentEngineersSelect.options).find(opt => opt.value === engineerName);
        if (prevOption) {
            prevCurrentEngineersSelect.removeChild(prevOption);
            // Update uniqueEngineers
            const engineer = uniqueEngineers.find(e => e.engineerName === engineerName);
            if (engineer) engineer.teamId = null;
        }
    }
}

function validateTeamChanges() {
    // Check for engineers assigned to multiple teams
    const engineerAssignments = {};
    currentSystemData.teams.forEach(team => {
        const teamEngineers = team.engineerNames ? team.engineerNames.split(',').map(name => name.trim()) : [];
        teamEngineers.forEach(engineerName => {
            if (engineerName) {
                if (engineerAssignments[engineerName]) {
                    engineerAssignments[engineerName].push(team.teamName || team.teamIdentity || 'Unnamed Team');
                } else {
                    engineerAssignments[engineerName] = [team.teamName || team.teamIdentity || 'Unnamed Team'];
                }
            }
        });
    });

    const conflictingEngineers = Object.entries(engineerAssignments).filter(([_, teams]) => teams.length > 1);

    // Check for services owned by multiple teams
    const serviceAssignments = {};
    currentSystemData.services.forEach(service => {
        if (service.owningTeamId) {
            if (serviceAssignments[service.serviceName]) {
                serviceAssignments[service.serviceName].push(service.owningTeamId);
            } else {
                serviceAssignments[service.serviceName] = [service.owningTeamId];
            }
        }
    });

    const conflictingServices = Object.entries(serviceAssignments).filter(([_, teams]) => teams.length > 1);

    let validationErrors = '';

    if (conflictingEngineers.length > 0) {
        validationErrors += 'The following engineers are assigned to multiple teams:\n';
        conflictingEngineers.forEach(([engineerName, teams]) => {
            validationErrors += `- ${engineerName}: ${teams.join(', ')}\n`;
        });
    }

    if (conflictingServices.length > 0) {
        validationErrors += 'The following services are owned by multiple teams:\n';
        conflictingServices.forEach(([serviceName, teamIds]) => {
            const teamNames = teamIds.map(teamId => {
                const team = currentSystemData.teams.find(t => t.teamId === teamId);
                return team ? (team.teamName || team.teamIdentity || 'Unnamed Team') : 'Unknown Team';
            });
            validationErrors += `- ${serviceName}: ${teamNames.join(', ')}\n`;
        });
    }

    if (validationErrors) {
        alert('Validation Errors:\n' + validationErrors);
        return false;
    }

    return true;
}


function saveTeamChanges(index, teamHeader, team, uniqueEngineers) {
  if (currentMode === Modes.CREATING || currentMode === Modes.EDITING) {
      // Validate required fields
      if (!team.teamIdentity || !team.teamName) {
          alert('Team Identity and Team Name are required.');
          return;
      }
  
      // SDM assignment is already handled in the UI interactions
      // Verify that team.sdmId corresponds to an existing SDM
      if (team.sdmId) {
          let sdm = currentSystemData.sdms.find(s => s.sdmId === team.sdmId);
          if (!sdm) {
              alert(`Assigned SDM with ID "${team.sdmId}" not found.`);
              return;
          }
      }
  
      // Handle new PMT
      // PMT assignment is already handled in the UI interactions
      // Verify that team.pmtId corresponds to an existing PMT
      if (team.pmtId) {
          let pmt = currentSystemData.pmts.find(p => p.pmtId === team.pmtId);
          if (!pmt) {
              alert(`Assigned PMT with ID "${team.pmtId}" not found.`);
              return;
          }
      } else {
          // No PMT assigned
          team.pmtId = null;
      }
  
      const teamDiv = document.querySelectorAll('.team-edit')[index];
      // Update services owned
      const currentServicesSelect = teamDiv.querySelector('select[data-field="currentServices"]');
      const teamServices = Array.from(currentServicesSelect.options).map(option => option.value);
  
      // Update owningTeamId for services in currentSystemData.services
      currentSystemData.services.forEach(service => {
          if (teamServices.includes(service.serviceName)) {
              service.owningTeamId = team.teamId;
          }
      });
      
      // Update engineer names
      const currentEngineersSelect = teamDiv.querySelector('select[data-field="currentEngineers"]');
      const teamEngineers = Array.from(currentEngineersSelect.options).map(option => option.value);
      team.engineerNames = teamEngineers.join(', ');
  
      // Update team size
      team.sizeOfTeam = teamEngineers.length;
  
      // Update the header to reflect any changes in team identity
      teamHeader.childNodes[1].nodeValue = `Team: ${team.teamIdentity}`;
  
      // **Save currentSystemData to local storage**
      const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
      systems[currentSystemData.systemName] = currentSystemData;
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));
  
      alert('Team changes saved.');
  
      // **Update the Team Breakdown and Service Dependencies Tables**
      generateTeamTable(currentSystemData);
      generateServiceDependenciesTable();
      
      // Refresh the teams editing interface to reflect changes
      displayTeamsForEditing(currentSystemData.teams, index);
  } else {
      alert('Cannot save team changes in the current mode.');
  }
}



/** Display Services for Editing **/

function displayServicesForEditing(services, containerId, expandedIndex = -1) {
    const servicesDiv = document.getElementById(containerId);
    servicesDiv.innerHTML = ''; // Clear existing content

    // Get a list of existing teams for the owning team selection
    const teamOptions = currentSystemData.teams.map(team => ({
        teamId: team.teamId,
        teamIdentity: team.teamIdentity
    }));

   // Ensure platformDependencies is initialized
   if (!currentSystemData.platformDependencies) {
       currentSystemData.platformDependencies = [];
   }
    
    // Build global platform dependencies list
    buildGlobalPlatformDependencies();
    
services.forEach((service, index) => {
    let serviceDiv = document.createElement('div');
    serviceDiv.className = 'service-edit';

    // Create the header for the collapsible section
    let serviceHeader = document.createElement('h4');
    serviceHeader.innerText = `Service: ${service.serviceName || 'New Service'}`;
    serviceHeader.style.cursor = 'pointer';
    let indicator = document.createElement('span');
    indicator.innerText = '+ '; // Starts with collapsed state
    serviceHeader.insertBefore(indicator, serviceHeader.firstChild);
    serviceHeader.onclick = () => {
        // Toggle the visibility of the service details
        const content = serviceDiv.querySelector('.service-details');
        const isCollapsed = content.style.display === 'none';
        content.style.display = isCollapsed ? 'block' : 'none';
        indicator.innerText = isCollapsed ? '- ' : '+ ';

        if (isCollapsed) {
            // Service is being expanded
            // Refresh Available Platform Dependencies
            const otherDepsSelect = content.querySelector('select[data-field="availablePlatformDependencies"]');
            const currentDepsSelect = content.querySelector('select[data-field="currentPlatformDependencies"]');

            // Get the current dependencies
            const currentDeps = Array.from(currentDepsSelect.options).map(option => option.value);

            // Clear the otherDepsSelect options
            otherDepsSelect.innerHTML = '';

            // Populate other dependencies (platform dependencies not in current service)
            currentSystemData.platformDependencies.forEach(dep => {
                if (!currentDeps.includes(dep)) {
                    let option = document.createElement('option');
                    option.value = dep;
                    option.text = dep;
                    otherDepsSelect.appendChild(option);
                }
            });

            // Refresh Available Service Dependencies
            const otherServicesSelect = content.querySelector('select[data-field="availableServiceDependencies"]');
            const currentServicesSelect = content.querySelector('select[data-field="currentServiceDependencies"]');

            // Get the current service dependencies
            const currentServiceDeps = Array.from(currentServicesSelect.options).map(option => option.value);

            // Clear the otherServicesSelect options
            otherServicesSelect.innerHTML = '';

            // Populate other services (excluding the current service and current dependencies)
            currentSystemData.services.forEach((otherService) => {
                if (
                    otherService.serviceName !== service.serviceName &&
                    !currentServiceDeps.includes(otherService.serviceName)
                ) {
                    let option = document.createElement('option');
                    option.value = otherService.serviceName;
                    option.text = otherService.serviceName;
                    otherServicesSelect.appendChild(option);
                }
            }); // <-- Added closing brace for forEach loop

            // **Refresh Available APIs for Each API in the Service**
            const apisContainer = content.querySelector('.apis-container');
            const apiEditDivs = apisContainer ? apisContainer.querySelectorAll('.api-edit') : [];

            service.apis.forEach((api, apiIndex) => {
                const apiDiv = apiEditDivs[apiIndex];

                // Get the select elements
                const currentDependentApisSelect = apiDiv.querySelector('select[data-field="currentDependentApis"]');
                const otherApisSelect = apiDiv.querySelector('select[data-field="availableApis"]');

                // Get current dependent APIs
                const currentDependentApis = Array.from(currentDependentApisSelect.options).map(option => option.value);

                // Clear the otherApisSelect options
                otherApisSelect.innerHTML = '';

                // Collect all APIs across all services
                let allApis = [];
                currentSystemData.services.forEach(srv => {
                    srv.apis.forEach(apiItem => {
                        allApis.push(apiItem.apiName);
                    });
                });

                // Populate other APIs (excluding the current API and current dependencies)
                allApis.forEach(apiName => {
                    if (
                        apiName !== api.apiName &&
                        !currentDependentApis.includes(apiName)
                    ) {
                        let option = document.createElement('option');
                        option.value = apiName;
                        option.text = apiName;
                        otherApisSelect.appendChild(option);
                    }
                });
            });
        } // <-- Added closing brace for 'if (isCollapsed)' block
    }; // <-- Added closing parenthesis and semicolon for 'serviceHeader.onclick' function


        // Create the container for service details
        let serviceDetails = document.createElement('div');
        serviceDetails.className = 'service-details';
        // Set the display based on whether it's the expanded index
        serviceDetails.style.display = (index === expandedIndex) ? 'block' : 'none';

        // Service Name
        let nameLabel = document.createElement('label');
        nameLabel.innerText = 'Service Name:';
        let nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = service.serviceName || '';
        nameInput.setAttribute('data-service-index', index);
        nameInput.setAttribute('data-field', 'serviceName');

        serviceDetails.appendChild(nameLabel);
        serviceDetails.appendChild(document.createElement('br'));
        serviceDetails.appendChild(nameInput);
        serviceDetails.appendChild(document.createElement('br'));

        // Service Description
        let descLabel = document.createElement('label');
        descLabel.innerText = 'Service Description:';
        let descTextarea = document.createElement('textarea');
        descTextarea.value = service.serviceDescription || '';
        descTextarea.setAttribute('data-service-index', index);
        descTextarea.setAttribute('data-field', 'serviceDescription');

        serviceDetails.appendChild(descLabel);
        serviceDetails.appendChild(document.createElement('br'));
        serviceDetails.appendChild(descTextarea);
        serviceDetails.appendChild(document.createElement('br'));

        // Platform Dependencies - Two Lists Side by Side

        // Create container div for platform dependencies
        let platformDepsContainer = document.createElement('div');
        platformDepsContainer.className = 'platform-deps-container';

        // Left-hand list: Current dependencies
        let currentDepsDiv = document.createElement('div');
        currentDepsDiv.className = 'current-deps';

        // Heading for current dependencies
        let currentDepsLabel = document.createElement('label');
        currentDepsLabel.innerText = 'Current Platform Dependencies:';
        currentDepsDiv.appendChild(currentDepsLabel);
        currentDepsDiv.appendChild(document.createElement('br'));

        // Select element for current dependencies
        let currentDepsSelect = document.createElement('select');
        currentDepsSelect.setAttribute('data-service-index', index);
        currentDepsSelect.setAttribute('data-field', 'currentPlatformDependencies');
        currentDepsSelect.multiple = true;
        currentDepsSelect.size = 5; // Adjust size as needed

        // Populate current dependencies
        (service.platformDependencies || []).forEach(dep => {
            let option = document.createElement('option');
            option.value = dep;
            option.text = dep;
            currentDepsSelect.appendChild(option);
        });

        currentDepsDiv.appendChild(currentDepsSelect);

        // Buttons container
        let buttonsDiv = document.createElement('div');
        buttonsDiv.className = 'platform-deps-buttons';
        buttonsDiv.style.display = 'flex';
        buttonsDiv.style.flexDirection = 'column';
        buttonsDiv.style.alignItems = 'center';
        buttonsDiv.style.justifyContent = 'center';

        // Remove Dependency Button
        let removeDepButton = document.createElement('button');
        removeDepButton.type = 'button';
        removeDepButton.innerText = '> Remove Dependency';
        removeDepButton.onclick = () => {
            // Move selected options from currentDepsSelect to otherDepsSelect
            Array.from(currentDepsSelect.selectedOptions).forEach(option => {
                // Remove from currentDepsSelect
                currentDepsSelect.removeChild(option);
                // Add to otherDepsSelect
                otherDepsSelect.appendChild(option);
            });
        };

        buttonsDiv.appendChild(removeDepButton);

        // Spacer
        buttonsDiv.appendChild(document.createElement('br'));

        // Add Dependency Button
        let addDepButton = document.createElement('button');
        addDepButton.type = 'button';
        addDepButton.innerText = '< Add Dependency';
        addDepButton.onclick = () => {
            // Move selected options from otherDepsSelect to currentDepsSelect
            Array.from(otherDepsSelect.selectedOptions).forEach(option => {
                // Remove from otherDepsSelect
                otherDepsSelect.removeChild(option);
                // Add to currentDepsSelect
                currentDepsSelect.appendChild(option);
            });
        };

        buttonsDiv.appendChild(addDepButton);

        // Right-hand list: Other platform dependencies
        let otherDepsDiv = document.createElement('div');
        otherDepsDiv.className = 'other-deps';

        // Heading for other dependencies
        let otherDepsLabel = document.createElement('label');
        otherDepsLabel.innerText = 'Available Platform Dependencies:';
        otherDepsDiv.appendChild(otherDepsLabel);
        otherDepsDiv.appendChild(document.createElement('br'));

        // Select element for other dependencies
        let otherDepsSelect = document.createElement('select');
        otherDepsSelect.setAttribute('data-service-index', index);
        otherDepsSelect.setAttribute('data-field', 'availablePlatformDependencies');
        otherDepsSelect.multiple = true;
        otherDepsSelect.size = 5; // Adjust size as needed

        // Populate other dependencies (platform dependencies not in current service)
        currentSystemData.platformDependencies.forEach(dep => {
            if (!service.platformDependencies || !service.platformDependencies.includes(dep)) {
                let option = document.createElement('option');
                option.value = dep;
                option.text = dep;
                otherDepsSelect.appendChild(option);
            }
        });

        otherDepsDiv.appendChild(otherDepsSelect);

        // Assemble the container
        platformDepsContainer.style.display = 'flex';
        platformDepsContainer.style.alignItems = 'center';
        platformDepsContainer.appendChild(currentDepsDiv);
        platformDepsContainer.appendChild(buttonsDiv);
        platformDepsContainer.appendChild(otherDepsDiv);

        serviceDetails.appendChild(platformDepsContainer);
        serviceDetails.appendChild(document.createElement('br'));

        // Input to add new platform dependency
        let newPlatformInputLabel = document.createElement('label');
        newPlatformInputLabel.innerText = 'Add New Platform Dependency:';
        let newPlatformInputContainer = document.createElement('div');
        newPlatformInputContainer.style.display = 'flex';
        newPlatformInputContainer.style.alignItems = 'center';

        let newPlatformInput = document.createElement('input');
        newPlatformInput.type = 'text';
        newPlatformInput.placeholder = 'Enter new platform dependency';
        newPlatformInput.setAttribute('data-service-index', index);
        newPlatformInput.setAttribute('data-field', 'newPlatformDependency');

        let addNewPlatformButton = document.createElement('button');
        addNewPlatformButton.type = 'button';
        addNewPlatformButton.innerText = 'Add';
        addNewPlatformButton.onclick = () => {
            const newDep = newPlatformInput.value.trim();
            if (newDep !== '') {
                // Add to global platform dependencies if not already present
                if (!currentSystemData.platformDependencies.includes(newDep)) {
                    currentSystemData.platformDependencies.push(newDep);
                     // Save the updated currentSystemData to localStorage
                      const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
                      systems[currentSystemData.systemName] = currentSystemData;
                      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));
                      // Update other services' available dependencies
                    updateAvailablePlatformDependencies(newDep);
                }
                // Add to current service's dependencies
                let option = document.createElement('option');
                option.value = newDep;
                option.text = newDep;
                currentDepsSelect.appendChild(option);

                // Remove from otherDepsSelect if present
                let existingOption = Array.from(otherDepsSelect.options).find(opt => opt.value === newDep);
                if (existingOption) {
                    otherDepsSelect.removeChild(existingOption);
                }

                // Clear the input
                newPlatformInput.value = '';
            }
        };

        newPlatformInputContainer.appendChild(newPlatformInput);
        newPlatformInputContainer.appendChild(addNewPlatformButton);

        serviceDetails.appendChild(newPlatformInputLabel);
        serviceDetails.appendChild(document.createElement('br'));
        serviceDetails.appendChild(newPlatformInputContainer);
        serviceDetails.appendChild(document.createElement('br'));

        // Event listener for adding new platform dependency
        newPlatformInput.addEventListener('change', (event) => {
            const newDep = event.target.value.trim();
            if (newDep !== '') {
                // Add to global platform dependencies if not already present
                if (!currentSystemData.platformDependencies.includes(newDep)) {
                    currentSystemData.platformDependencies.push(newDep);
                }
                // Add to current service's dependencies
                let option = document.createElement('option');
                option.value = newDep;
                option.text = newDep;
                currentDepsSelect.appendChild(option);

                // Remove from otherDepsSelect if present
                let existingOption = Array.from(otherDepsSelect.options).find(opt => opt.value === newDep);
                if (existingOption) {
                    otherDepsSelect.removeChild(existingOption);
                }

                // Clear the input
                event.target.value = '';
            }
        });

        // **Service Dependencies - Two Lists Side by Side**

        // Create container div for service dependencies
        let serviceDepsContainer = document.createElement('div');
        serviceDepsContainer.className = 'service-deps-container';

        // Left-hand list: Current service dependencies
        let currentServiceDepsDiv = document.createElement('div');
        currentServiceDepsDiv.className = 'current-service-deps';

        // Heading for current service dependencies
        let currentServiceDepsLabel = document.createElement('label');
        currentServiceDepsLabel.innerText = 'Current Service Dependencies:';
        currentServiceDepsDiv.appendChild(currentServiceDepsLabel);
        currentServiceDepsDiv.appendChild(document.createElement('br'));

        // Select element for current service dependencies
        let currentServiceDepsSelect = document.createElement('select');
        currentServiceDepsSelect.setAttribute('data-service-index', index);
        currentServiceDepsSelect.setAttribute('data-field', 'currentServiceDependencies');
        currentServiceDepsSelect.multiple = true;
        currentServiceDepsSelect.size = 5; // Adjust size as needed

        // Populate current service dependencies
        (service.serviceDependencies || []).forEach(depServiceName => {
            let option = document.createElement('option');
            option.value = depServiceName;
            option.text = depServiceName;
            currentServiceDepsSelect.appendChild(option);
        });

        currentServiceDepsDiv.appendChild(currentServiceDepsSelect);

        // Buttons container
        let serviceDepsButtonsDiv = document.createElement('div');
        serviceDepsButtonsDiv.className = 'service-deps-buttons';
        serviceDepsButtonsDiv.style.display = 'flex';
        serviceDepsButtonsDiv.style.flexDirection = 'column';
        serviceDepsButtonsDiv.style.alignItems = 'center';
        serviceDepsButtonsDiv.style.justifyContent = 'center';

        // Remove Dependency Button
        let removeServiceDepButton = document.createElement('button');
        removeServiceDepButton.type = 'button';
        removeServiceDepButton.innerText = '> Remove Dependency';
        removeServiceDepButton.onclick = () => {
            // Move selected options from currentServiceDepsSelect to otherServicesSelect
            Array.from(currentServiceDepsSelect.selectedOptions).forEach(option => {
                // Remove from currentServiceDepsSelect
                currentServiceDepsSelect.removeChild(option);
                // Add to otherServicesSelect
                otherServicesSelect.appendChild(option);
            });
        };

        serviceDepsButtonsDiv.appendChild(removeServiceDepButton);

        // Spacer
        serviceDepsButtonsDiv.appendChild(document.createElement('br'));

        // Add Dependency Button
        let addServiceDepButton = document.createElement('button');
        addServiceDepButton.type = 'button';
        addServiceDepButton.innerText = '< Add Dependency';
        addServiceDepButton.onclick = () => {
            // Move selected options from otherServicesSelect to currentServiceDepsSelect
            Array.from(otherServicesSelect.selectedOptions).forEach(option => {
                // Remove from otherServicesSelect
                otherServicesSelect.removeChild(option);
                // Add to currentServiceDepsSelect
                currentServiceDepsSelect.appendChild(option);
            });
        };

        serviceDepsButtonsDiv.appendChild(addServiceDepButton);

        // Right-hand list: Other services
        let otherServicesDiv = document.createElement('div');
        otherServicesDiv.className = 'other-services';

        // Heading for other services
        let otherServicesLabel = document.createElement('label');
        otherServicesLabel.innerText = 'Available Services:';
        otherServicesDiv.appendChild(otherServicesLabel);
        otherServicesDiv.appendChild(document.createElement('br'));

        // Select element for other services
        let otherServicesSelect = document.createElement('select');
        otherServicesSelect.setAttribute('data-service-index', index);
        otherServicesSelect.setAttribute('data-field', 'availableServiceDependencies');
        otherServicesSelect.multiple = true;
        otherServicesSelect.size = 5; // Adjust size as needed

        // Populate other services (excluding the current service and current dependencies)
        currentSystemData.services.forEach((otherService) => {
            if (
                otherService.serviceName !== service.serviceName &&
                !(service.serviceDependencies || []).includes(otherService.serviceName)
            ) {
                let option = document.createElement('option');
                option.value = otherService.serviceName;
                option.text = otherService.serviceName;
                otherServicesSelect.appendChild(option);
            }
        });

        otherServicesDiv.appendChild(otherServicesSelect);

        // Assemble the container
        serviceDepsContainer.style.display = 'flex';
        serviceDepsContainer.style.alignItems = 'center';
        serviceDepsContainer.appendChild(currentServiceDepsDiv);
        serviceDepsContainer.appendChild(serviceDepsButtonsDiv);
        serviceDepsContainer.appendChild(otherServicesDiv);

        serviceDetails.appendChild(serviceDepsContainer);
        serviceDetails.appendChild(document.createElement('br'));


        // **APIs Section**
        // Create container for APIs
        let apisContainer = document.createElement('div');
        apisContainer.className = 'apis-container';

        // Heading for APIs
        let apisLabel = document.createElement('h5');
        apisLabel.innerText = 'APIs:';
        apisContainer.appendChild(apisLabel);

        // Iterate over APIs
        (service.apis || []).forEach((api, apiIndex) => {
            let apiDiv = document.createElement('div');
            apiDiv.className = 'api-edit';

            // API Name
            let apiNameLabel = document.createElement('label');
            apiNameLabel.innerText = 'API Name:';
            let apiNameInput = document.createElement('input');
            apiNameInput.type = 'text';
            apiNameInput.value = api.apiName || '';
            apiNameInput.setAttribute('data-service-index', index);
            apiNameInput.setAttribute('data-api-index', apiIndex);
            apiNameInput.setAttribute('data-field', 'apiName');

            apiDiv.appendChild(apiNameLabel);
            apiDiv.appendChild(document.createElement('br'));
            apiDiv.appendChild(apiNameInput);
            apiDiv.appendChild(document.createElement('br'));

            // API Description
            let apiDescLabel = document.createElement('label');
            apiDescLabel.innerText = 'API Description:';
            let apiDescTextarea = document.createElement('textarea');
            apiDescTextarea.value = api.apiDescription || '';
            apiDescTextarea.setAttribute('data-service-index', index);
            apiDescTextarea.setAttribute('data-api-index', apiIndex);
            apiDescTextarea.setAttribute('data-field', 'apiDescription');

            apiDiv.appendChild(apiDescLabel);
            apiDiv.appendChild(document.createElement('br'));
            apiDiv.appendChild(apiDescTextarea);
            apiDiv.appendChild(document.createElement('br'));

            // **Dependent APIs - Two Lists Side by Side**

            // Create container div for dependent APIs
            let dependentApisContainer = document.createElement('div');
            dependentApisContainer.className = 'dependent-apis-container';

            // Left-hand list: Current dependent APIs
            let currentDependentApisDiv = document.createElement('div');
            currentDependentApisDiv.className = 'current-dependent-apis';

            // Heading for current dependent APIs
            let currentDependentApisLabel = document.createElement('label');
            currentDependentApisLabel.innerText = 'Current Dependent APIs:';
            currentDependentApisDiv.appendChild(currentDependentApisLabel);
            currentDependentApisDiv.appendChild(document.createElement('br'));

            // Select element for current dependent APIs
            let currentDependentApisSelect = document.createElement('select');
            currentDependentApisSelect.setAttribute('data-service-index', index);
            currentDependentApisSelect.setAttribute('data-api-index', apiIndex);
            currentDependentApisSelect.setAttribute('data-field', 'currentDependentApis');
            currentDependentApisSelect.multiple = true;
            currentDependentApisSelect.size = 5; // Adjust size as needed

            // Populate current dependent APIs
            (api.dependentApis || []).forEach(depApiName => {
                let option = document.createElement('option');
                option.value = depApiName;
                option.text = depApiName;
                currentDependentApisSelect.appendChild(option);
            });

            currentDependentApisDiv.appendChild(currentDependentApisSelect);

            // Buttons container
            let dependentApisButtonsDiv = document.createElement('div');
            dependentApisButtonsDiv.className = 'dependent-apis-buttons';
            dependentApisButtonsDiv.style.display = 'flex';
            dependentApisButtonsDiv.style.flexDirection = 'column';
            dependentApisButtonsDiv.style.alignItems = 'center';
            dependentApisButtonsDiv.style.justifyContent = 'center';

            // Remove Dependency Button
            let removeApiDepButton = document.createElement('button');
            removeApiDepButton.type = 'button';
            removeApiDepButton.innerText = '> Remove Dependency';
            removeApiDepButton.onclick = () => {
                // Move selected options from currentDependentApisSelect to otherApisSelect
                Array.from(currentDependentApisSelect.selectedOptions).forEach(option => {
                    // Remove from currentDependentApisSelect
                    currentDependentApisSelect.removeChild(option);
                    // Add to otherApisSelect
                    otherApisSelect.appendChild(option);
                });
            };

            dependentApisButtonsDiv.appendChild(removeApiDepButton);

            // Spacer
            dependentApisButtonsDiv.appendChild(document.createElement('br'));

            // Add Dependency Button
            let addApiDepButton = document.createElement('button');
            addApiDepButton.type = 'button';
            addApiDepButton.innerText = '< Add Dependency';
            addApiDepButton.onclick = () => {
                // Move selected options from otherApisSelect to currentDependentApisSelect
                Array.from(otherApisSelect.selectedOptions).forEach(option => {
                    // Remove from otherApisSelect
                    otherApisSelect.removeChild(option);
                    // Add to currentDependentApisSelect
                    currentDependentApisSelect.appendChild(option);
                });
            };

            dependentApisButtonsDiv.appendChild(addApiDepButton);

            // Right-hand list: Other APIs
            let otherApisDiv = document.createElement('div');
            otherApisDiv.className = 'other-apis';

            // Heading for other APIs
            let otherApisLabel = document.createElement('label');
            otherApisLabel.innerText = 'Available APIs:';
            otherApisDiv.appendChild(otherApisLabel);
            otherApisDiv.appendChild(document.createElement('br'));

            // Select element for other APIs
            let otherApisSelect = document.createElement('select');
            otherApisSelect.setAttribute('data-service-index', index);
            otherApisSelect.setAttribute('data-api-index', apiIndex);
            otherApisSelect.setAttribute('data-field', 'availableApis');
            otherApisSelect.multiple = true;
            otherApisSelect.size = 5; // Adjust size as needed

            // Populate other APIs (excluding the current API and current dependencies)
            // Collect all APIs across all services
            let allApis = [];
            currentSystemData.services.forEach(srv => {
                srv.apis.forEach(apiItem => {
                    allApis.push(apiItem.apiName);
                });
            });

            // Exclude current API and current dependencies
            allApis.forEach(apiName => {
                if (
                    apiName !== api.apiName &&
                    !(api.dependentApis || []).includes(apiName)
                ) {
                    let option = document.createElement('option');
                    option.value = apiName;
                    option.text = apiName;
                    otherApisSelect.appendChild(option);
                }
            });

            otherApisDiv.appendChild(otherApisSelect);

            // Assemble the container
            dependentApisContainer.style.display = 'flex';
            dependentApisContainer.style.alignItems = 'center';
            dependentApisContainer.appendChild(currentDependentApisDiv);
            dependentApisContainer.appendChild(dependentApisButtonsDiv);
            dependentApisContainer.appendChild(otherApisDiv);

            apiDiv.appendChild(dependentApisContainer);
            apiDiv.appendChild(document.createElement('br'));

            // Delete API Button
            let deleteApiButton = document.createElement('button');
            deleteApiButton.type = 'button';
            deleteApiButton.innerText = 'Delete API';
            deleteApiButton.onclick = () => deleteApi(index, apiIndex, containerId);

            apiDiv.appendChild(deleteApiButton);

            apisContainer.appendChild(apiDiv);
        });

        // Add New API Button
        let addApiButton = document.createElement('button');
        addApiButton.type = 'button';
        addApiButton.innerText = 'Add New API';
        addApiButton.onclick = () => addNewApi(index, containerId);

        serviceDetails.appendChild(apisContainer);
        serviceDetails.appendChild(addApiButton);
        serviceDetails.appendChild(document.createElement('br'));

        // Delete Service Button
        let deleteServiceButton = document.createElement('button');
        deleteServiceButton.type = 'button';
        deleteServiceButton.innerText = 'Delete Service';
        deleteServiceButton.onclick = () => {
            if (confirm('Are you sure you want to delete this service?')) {
                deleteService(index, containerId);
            }
        };

        serviceDetails.appendChild(deleteServiceButton);
        
        //Save Service button
        let saveServiceButton = document.createElement('button');
        saveServiceButton.type = 'button';
        saveServiceButton.innerText = 'Save Service Changes';
        saveServiceButton.onclick = () => saveServiceChanges(index);
        
        serviceDetails.appendChild(saveServiceButton);        

        // Append header and details to serviceDiv
        serviceDiv.appendChild(serviceHeader);
        serviceDiv.appendChild(serviceDetails);
        servicesDiv.appendChild(serviceDiv);
    });

    // Function to update other services' available dependencies when a new platform dependency is added
    function updateAvailablePlatformDependencies(newDep) {
        // For each service (excluding the current one), add the new dependency to the available list if not already present
        services.forEach((service, index) => {
            // Skip if the service is already being edited (current service)
            const serviceEditDivs = servicesDiv.querySelectorAll('.service-edit');
            const currentServiceDiv = serviceEditDivs[index];
            const otherDepsSelect = currentServiceDiv.querySelector('select[data-field="availablePlatformDependencies"]');

            // Check if the new dependency is already in current dependencies
            const currentDepsSelect = currentServiceDiv.querySelector('select[data-field="currentPlatformDependencies"]');
            const isInCurrentDeps = Array.from(currentDepsSelect.options).some(opt => opt.value === newDep);

            if (!isInCurrentDeps) {
                // Add to available dependencies if not already present
                const isInAvailableDeps = Array.from(otherDepsSelect.options).some(opt => opt.value === newDep);
                if (!isInAvailableDeps) {
                    let option = document.createElement('option');
                    option.value = newDep;
                    option.text = newDep;
                    otherDepsSelect.appendChild(option);
                }
            }
        });
    }

    // Add event listeners for input changes (excluding platform dependencies, which are handled separately)
    const inputs = servicesDiv.querySelectorAll('input, textarea, select');
    inputs.forEach(input => {
        if (input.getAttribute('data-field') !== 'currentPlatformDependencies' && input.getAttribute('data-field') !== 'availablePlatformDependencies') {
            input.addEventListener('change', (event) => {
                const serviceIndex = parseInt(event.target.getAttribute('data-service-index'));
                const apiIndex = event.target.getAttribute('data-api-index');
                const field = event.target.getAttribute('data-field');
                const value = event.target.value;

                if (apiIndex !== null) {
                    // Update API data
                    if (field === 'dependentApis') {
                        currentSystemData.services[serviceIndex].apis[apiIndex][field] = value.split(',').map(s => s.trim());
                    } else {
                        currentSystemData.services[serviceIndex].apis[apiIndex][field] = value;
                    }
                } else if (field === 'serviceName') {
                    // Update service name and header
                    currentSystemData.services[serviceIndex][field] = value;
                    const serviceHeader = servicesDiv.querySelectorAll('.service-edit')[serviceIndex].querySelector('h4');
                    serviceHeader.innerText = `Service: ${value || 'New Service'}`;
                    serviceHeader.insertBefore(serviceHeader.querySelector('span'), serviceHeader.firstChild);
                } else if (field === 'serviceDependencies') {
                    // Get selected options
                    const selectedOptions = Array.from(event.target.selectedOptions).map(option => option.value);
                    currentSystemData.services[serviceIndex][field] = selectedOptions;
                } else {
                    currentSystemData.services[serviceIndex][field] = value;
                }
            });
        }
    });
}

function saveServiceChanges(serviceIndex) {
    // Perform validation (optional)
    const service = currentSystemData.services[serviceIndex];
    if (!service.serviceName || service.serviceName.trim() === '') {
        alert('Service name cannot be empty.');
        return;
    }

    const serviceEditDivs = document.querySelectorAll('.service-edit');
    const currentServiceDiv = serviceEditDivs[serviceIndex];

    // Update Platform Dependencies
    const currentDepsSelect = currentServiceDiv.querySelector('select[data-field="currentPlatformDependencies"]');
    const selectedDependencies = Array.from(currentDepsSelect.options).map(option => option.value);
    service.platformDependencies = selectedDependencies;

    // Update Service Dependencies
    const currentServiceDepsSelect = currentServiceDiv.querySelector('select[data-field="currentServiceDependencies"]');
    const selectedServiceDependencies = Array.from(currentServiceDepsSelect.options).map(option => option.value);
    service.serviceDependencies = selectedServiceDependencies;

    // **Update APIs and their Dependent APIs**
    const apisContainer = currentServiceDiv.querySelector('.apis-container');
    const apiEditDivs = apisContainer.querySelectorAll('.api-edit');

    service.apis.forEach((api, apiIndex) => {
        const apiDiv = apiEditDivs[apiIndex];

        // Update API fields
        const apiNameInput = apiDiv.querySelector('input[data-field="apiName"]');
        api.apiName = apiNameInput.value;

        const apiDescTextarea = apiDiv.querySelector('textarea[data-field="apiDescription"]');
        api.apiDescription = apiDescTextarea.value;

        // Update Dependent APIs
        const currentDependentApisSelect = apiDiv.querySelector('select[data-field="currentDependentApis"]');
        const selectedDependentApis = Array.from(currentDependentApisSelect.options).map(option => option.value);
        api.dependentApis = selectedDependentApis;
    });

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    systems[currentSystemData.systemName] = currentSystemData;
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    alert('Service changes saved.');

    // **Update the Team Breakdown and Service Dependencies Tables**
    generateTeamTable(currentSystemData);
    generateServiceDependenciesTable();
    
    // Optionally collapse the service details or provide additional feedback
}

/** Add New Service in Edit Form **/
function addNewEditService() {
    // Create a new service object with default values
    const newService = {
        serviceName: 'New Service',
        serviceDescription: '',
        owningTeamId: '',
        apis: [],
        serviceDependencies: [],
        platformDependencies: []
    };

    // Add to the system data
    if (!currentSystemData.services) {
        currentSystemData.services = [];
    }
    currentSystemData.services.push(newService);

    // Refresh the service editing display for the edit form
    displayServicesForEditing(currentSystemData.services, 'editServicesManagement');
}

/** Add New Service **/

function addNewService() {
    // Create a new service object with default values
    const newService = {
        serviceName: 'New Service',
        serviceDescription: '',
        owningTeamId: '',
        apis: [],
        serviceDependencies: [],
        platformDependencies: []
    };

    // Add to the system data
    if (!currentSystemData.services) {
        currentSystemData.services = [];
    }
    currentSystemData.services.push(newService);
    
    // Get the index of the newly added service
    const newServiceIndex = currentSystemData.services.length - 1;

    // Refresh the service editing display and expand the new service
    displayServicesForEditing(currentSystemData.services, 'editServicesManagement', newServiceIndex);
}

/** Delete Service **/

function deleteService(serviceIndex, containerId) {
    // Remove the service from the system data
    currentSystemData.services.splice(serviceIndex, 1);

    // **Update the Team Breakdown and Service Dependencies Tables**
    generateTeamTable(currentSystemData);
    generateServiceDependenciesTable();
    
    // Refresh the service editing display
    displayServicesForEditing(currentSystemData.services, containerId,serviceIndex);
}

/** Add New API **/

function addNewApi(serviceIndex) {
    // Create a new API object with default values
    const newApi = {
        apiName: 'New API',
        apiDescription: '',
        dependentApis: []
    };

    // Add to the service's APIs
    currentSystemData.services[serviceIndex].apis.push(newApi);

    // Refresh the service editing display
    displayServicesForEditing(currentSystemData.services, 'editServicesManagement', serviceIndex);
}

/** Delete API **/

function deleteApi(serviceIndex, apiIndex, containerId) {
    // Remove the API from the service's APIs
    currentSystemData.services[serviceIndex].apis.splice(apiIndex, 1);

    // Refresh the service editing display
    displayServicesForEditing(currentSystemData.services, containerId, serviceIndex);
}


/** Add New Team **/

function addNewTeam() {
    // Generate a unique teamId
    const teamIds = currentSystemData.teams.map(team => team.teamId);
    let newTeamId;
    let idCounter = 1; // Start from 1 if no teams exist
    do {
        newTeamId = 'team' + idCounter++;
    } while (teamIds.includes(newTeamId));

    // Create a new team object with default values
    const newTeam = {
        teamId: newTeamId,
        teamName: '',
        teamIdentity: '',
        sizeOfTeam: 0,
        engineerNames: '',
        sdmId: '',
        sdmName: '',
        pmtId: '',
        pmtName: ''
    };

    // Add to the system data
    currentSystemData.teams.push(newTeam);

    // Get the index of the newly added team
    const newTeamIndex = currentSystemData.teams.length - 1;

    // Refresh the team editing display and expand the new team
    displayTeamsForEditing(currentSystemData.teams, newTeamIndex);
}

/** Delete Team **/

function deleteTeam(index) {
    const team = currentSystemData.teams[index];
    const confirmDelete = confirm(`Are you sure you want to delete the team "${team.teamName}"? This action cannot be undone.`);
    if (confirmDelete) {
        // Remove the team from currentSystemData.teams
        currentSystemData.teams.splice(index, 1);

        // Update services that reference this team
        currentSystemData.services.forEach(service => {
            if (service.owningTeamId === team.teamId) {
                service.owningTeamId = null;
            }
        });

        // Update uniqueEngineers array
        uniqueEngineers = uniqueEngineers.filter(engineer => engineer.teamId !== team.teamId);

        // Update team assignments in engineers
        currentSystemData.teams.forEach(t => {
            if (t.teamId !== team.teamId) {
                const engineers = t.engineerNames ? t.engineerNames.split(',').map(name => name.trim()) : [];
                t.engineerNames = engineers.filter(name => {
                    const engineer = uniqueEngineers.find(e => e.engineerName === name);
                    return engineer && engineer.teamId === t.teamId;
                }).join(', ');
            }
        });

        // Save changes to local storage
        saveSystemChanges();
        
        // Notify the user
        alert(`Team "${team.teamName}" has been deleted.`);

        // Refresh the teams editing interface
        displayTeamsForEditing(currentSystemData.teams);

        // Update other UI components
        generateTeamTable(currentSystemData);
        generateTeamVisualization(currentSystemData);
        generateServiceDependenciesTable();
        populateServiceSelection();
        populateDependencyServiceSelection();
        updateServiceVisualization();
        updateDependencyVisualization();
    }
}

/** Save System Details **/

function saveSystemDetails() {
    // Get updated system name and description
    console.log("*** 1 document.getElementById('systemNameInput').value",document.getElementById('systemNameInput').value);    
    console.log("*** 2 document.getElementById('systemDescriptionInput'",document.getElementById('systemDescriptionInput').value);    
    
    const systemNameInput = document.getElementById('systemNameInput');
    const systemDescriptionTextarea = document.getElementById('systemDescriptionInput');

    console.log("*** 3 systemNameInput = ", systemNameInput.value);
    console.log("*** 4 systemDescriptionTextarea = ", systemDescriptionTextarea.value);  
  
    const oldSystemName = currentSystemData.systemName;
    const newSystemName = systemNameInput.value.trim();

    if (!newSystemName) {
        alert('System name cannot be empty.');
        return;
    }

    currentSystemData.systemName = newSystemName;
    currentSystemData.systemDescription = systemDescriptionTextarea.value.trim();

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');

    systems[newSystemName] = currentSystemData;

    console.log('Saving to local storage:', systems);

    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    alert('System details saved, please continue to update the services and teams. Note: If you changed the system name, it is treated as a new system');

    if (currentMode == Modes.EDITING) {
      // Update UI components
      generateTeamTable(currentSystemData);
      generateServiceDependenciesTable();
      updateServiceVisualization();
      updateDependencyVisualization();
    }
}

/** Save All Changes **/

function saveAllChanges() {
    if (currentMode === Modes.CREATING || currentMode === Modes.EDITING) {
        // Validate required fields
        if (!currentSystemData.systemName || !currentSystemData.systemDescription) {
            alert('Please enter the System Name and System Description before saving.');
            return;
        }

          //Save System Details just in Case
          saveSystemDetails();
          
      // Update team data from inputs
          const inputs = document.querySelectorAll('#teamsManagement input, #teamsManagement textarea, #teamsManagement select');
          inputs.forEach(input => {
              const index = input.getAttribute('data-team-index');
              const field = input.getAttribute('data-field');
              const value = input.value;
      
              if (field === 'sizeOfTeam') {
                  currentSystemData.teams[index][field] = parseInt(value);
              } else if (field === 'sdmName' || field === 'newSdmName') {
                  // Handle SDM Name
                  let sdmName = value.trim();
                  if (sdmName !== '') {
                      currentSystemData.teams[index]['sdmName'] = sdmName;
      
                      // Add to SDMs list if new
                      if (!currentSystemData.sdms.some(sdm => sdm.sdmName === sdmName)) {
                          const newSdmId = 'sdm' + (currentSystemData.sdms.length + 1);
                          currentSystemData.sdms.push({ sdmId: newSdmId, sdmName: sdmName });
                          currentSystemData.teams[index]['sdmId'] = newSdmId;
                      } else {
                          // Find existing SDM ID
                          const existingSdm = currentSystemData.sdms.find(sdm => sdm.sdmName === sdmName);
                          currentSystemData.teams[index]['sdmId'] = existingSdm.sdmId;
                      }
                  }
              } else if (field === 'pmtName' || field === 'newPmtName') {
                  // Handle PMT Name
                  let pmtName = value.trim();
                  if (pmtName !== '') {
                      currentSystemData.teams[index]['pmtName'] = pmtName;
      
                      // Add to PMTs list if new
                      if (!currentSystemData.pmts.some(pmt => pmt.pmtName === pmtName)) {
                          const newPmtId = 'pmt' + (currentSystemData.pmts.length + 1);
                          currentSystemData.pmts.push({ pmtId: newPmtId, pmtName: pmtName });
                          currentSystemData.teams[index]['pmtId'] = newPmtId;
                      } else {
                          // Find existing PMT ID
                          const existingPmt = currentSystemData.pmts.find(pmt => pmt.pmtName === pmtName);
                          currentSystemData.teams[index]['pmtId'] = existingPmt.pmtId;
                      }
                  }
              } else {
                  currentSystemData.teams[index][field] = value;
              }
          });
      
          // Optional: Update service data from inputs (if necessary)
          // If event listeners are reliable, this may not be needed.
          // Save changes to local storage
          saveSystemChanges();    
      
          // Save the updated system to local storage
          const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
          systems[currentSystemData.systemName] = currentSystemData;
          localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));
      
          // If the system name has changed, handle renaming in local storage
          const oldSystemName = currentSystemData.oldSystemName || currentSystemData.systemName;
          if (oldSystemName && oldSystemName !== currentSystemData.systemName) {
              delete systems[oldSystemName];
          }
      
          systems[currentSystemData.systemName] = currentSystemData;
          localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));
      
          alert('All changes saved.');

      } else {
        alert('No changes to save!');
    }
}

/** Exit Edit Mode **/

function exitEditMode() {
    if (currentMode === Modes.CREATING) {
        if (confirm('Are you sure you want to cancel creating the new system? All unsaved changes will be lost.')) {
            currentMode = Modes.NAVIGATION;
            currentSystemData = null;
            // Clear the UI and return to navigation mode
            returnToHome();
        }
    } else {
      // Hide the edit form
      document.getElementById('systemEditForm').style.display = 'none';
  
      // Show the visualizations
      document.getElementById('visualization').style.display = 'block';
      document.getElementById('teamVisualization').style.display = 'block';
      document.getElementById('teamBreakdown').style.display = 'block';
  
      // Update the page title and description
      document.getElementById('pageTitle').innerText = currentSystemData.systemName;
      document.getElementById('systemDescription').innerText = currentSystemData.systemDescription || '';
      
      // Show the "Edit System" button
      document.querySelector('.edit-menu').style.display = 'block';
  
      loadSavedSystem(currentSystemData.systemName);    
      currentMode = Modes.BROWSING;
    }
}

/** 09/28 Worked on CreateNewSystem workflows **/
/** Function to handle "Create New Software System" button click **/

function createNewSystem() {
  currentMode = Modes.CREATING;  
  
  // Default SDMs Data
  const defaultSDMsData = [
      { sdmId: 'sdm1', sdmName: 'Enter SDM Name Here' }
  ];
  
  // Default PMTs Data
  const defaultPMTsData = [
      { pmtId: 'pmt1', pmtName: 'Enter PMT Name Here' }
  ];
  
  // Default Teams Data
  const defaultTeamsData = [
      {
          teamId: 'team1',
          teamName: 'Enter Team Name Here',
          teamIdentity: 'Enter Team Identity Here',
          teamDescription: 'Enter Team Description Here...',
          sizeOfTeam: 1, // Placeholder for team size
          engineerNames: 'Enter Engineer Names Here...',
          sdmId: 'sdm1', // Reference to the default SDM
          pmtId: 'pmt1'  // Reference to the default PMT
      }
  ];
  
  // Default Services Data
  const defaultServicesData = [
      {
          serviceName: 'Enter Service Name Here',
          serviceDescription: 'Enter Service Description Here...',
          owningTeamId: 'team1', // Reference to the default Team
          apis: [
              {
                  apiName: 'Enter API Name Here',
                  apiDescription: 'Enter API Description Here...',
                  dependentApis: []
              }
          ],
          serviceDependencies: [],
          platformDependencies: ['Enter Platform Dependency Here']
      }
  ];

  // Default System Data
  const defaultSystemData = {
      systemName: 'Enter System Name Here',
      systemDescription: 'Enter System Description Here...',
      sdms: defaultSDMsData,
      pmts: defaultPMTsData,
      teams: defaultTeamsData,
      services: defaultServicesData,
      platformDependencies: ['Enter Platform Dependency Here']
  };
  
  // Assign to currentSystemData
  currentSystemData = defaultSystemData;

    // Clear the page title and description
    document.getElementById('pageTitle').innerText = 'Create New Software System';
    document.getElementById('systemDescription').innerText = '';

    // Hide the menu and other sections
    document.querySelector('.menu').style.display = 'none';
    document.getElementById('visualization').style.display = 'none';
    document.getElementById('teamVisualization').style.display = 'none';
    document.getElementById('teamBreakdown').style.display = 'none';
    document.querySelector('.edit-menu').style.display = 'none';
    document.getElementById('systemEditForm').style.display = 'none';

    // Display the system information for editing
   enterEditMode(true);
    
}

function returnToHome() {
    currentMode = Modes.NAVIGATION;
    
    // Hide all sections
    document.getElementById('systemCreationForm').style.display = 'none';
    document.getElementById('systemEditForm').style.display = 'none';
    document.getElementById('visualization').style.display = 'none';
    document.getElementById('teamVisualization').style.display = 'none';
    document.getElementById('teamBreakdown').style.display = 'none';
    document.getElementById('serviceRelationshipsVisualization').style.display = 'none'; // Hide the new visualization
    document.getElementById('dependencyVisualization').style.display = 'none'; // Corrected ID    
    document.getElementById('serviceDependenciesTable').style.display = 'none'; // Hide the new table
    document.querySelector('.edit-menu').style.display = 'none';

    // Show the main menu
    document.querySelector('.menu').style.display = 'block';

    // Update page title and description
    document.getElementById('pageTitle').innerText = "Architecture Visualization Tool";
    document.getElementById('systemDescription').innerText = "Load a previously saved system or create a new system...";
}

function resetToDefaults() {
    if (confirm('This will erase all your saved systems and restore the default sample systems. Do you want to proceed?')) {
        // Clear the local storage for systems
        localStorage.removeItem(LOCAL_STORAGE_KEY);

        // Re-initialize with sample systems
        const systems = {
            'StreamView': sampleSystemDataStreamView,
            'ConnectPro': sampleSystemDataContactCenter
        };
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

        alert('Systems have been reset to defaults.');

        // Return to the home page
        returnToHome();
    }
}

function populateServiceSelection() {
    const serviceSelection = document.getElementById('serviceSelection');
    serviceSelection.innerHTML = ''; // Clear existing options

    // Add "All Services View" option
    let allServicesOption = document.createElement('option');
    allServicesOption.value = 'all';
    allServicesOption.text = 'All Services View';
    serviceSelection.appendChild(allServicesOption);

    // Add individual services
    currentSystemData.services.forEach(service => {
        let option = document.createElement('option');
        option.value = service.serviceName;
        option.text = service.serviceName;
        serviceSelection.appendChild(option);
    });
}

function getServiceDependencies(service, collectedServices = {}, visitedServices = {}) {
    if (!service || visitedServices[service.serviceName]) {
        return [];
    }
    visitedServices[service.serviceName] = true;
    collectedServices[service.serviceName] = service;

    // Recursively collect dependencies
    service.serviceDependencies.forEach(depName => {
        const depService = currentSystemData.services.find(s => s.serviceName === depName);
        getServiceDependencies(depService, collectedServices, visitedServices);
    });

    return Object.values(collectedServices);
}

function updateServiceVisualization() {
    const selectedService = document.getElementById('serviceSelection').value;

    // Ensure the service selection is populated with the latest data
    populateServiceSelection();
    
    if (selectedService === 'all') {
        generateServiceVisualization(currentSystemData.services, null); // No service is selected
    } else {
        // Find the selected service and its dependencies
        const selectedServiceData = currentSystemData.services.find(service => service.serviceName === selectedService);
        const relatedServices = getServiceDependencies(selectedServiceData);

        generateServiceVisualization(relatedServices, selectedService);
    }
}

function generateServiceVisualization(services, selectedServiceName) {
    let svg = d3.select('#serviceSvg');
    svg.selectAll('*').remove(); // Clear any existing content

    // Prepare nodes and links data
    let nodes = [];
    let links = [];
    let nodeMap = {};
   
    // Set SVG dimensions
    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    // Define node radius
    const radius = 20;
   
    // Create a color scale based on teams
    const teamColorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const teamIds = currentSystemData.teams.map(team => team.teamId);
    teamColorScale.domain(teamIds);

    // Map service names to services for quick lookup
    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    // Create nodes for services
    services.forEach(service => {
        let teamId = service.owningTeamId || 'unassigned';
        let nodeColor = teamColorScale(teamId);

        // Check if this is the selected service
        let isSelected = service.serviceName === selectedServiceName;

        nodes.push({
            id: service.serviceName,
            type: 'service',
            teamId: teamId,
            color: nodeColor,
            isSelected: isSelected
        });
        nodeMap[service.serviceName] = { id: service.serviceName, type: 'service' };
    });

    // Add platform dependencies as nodes
    services.forEach(service => {
        if (service.platformDependencies) {
            service.platformDependencies.forEach(platform => {
                if (!nodeMap[platform]) {
                    nodes.push({ id: platform, type: 'platform', color: '#a04040', isSelected: false }); // Add isSelected property
                    nodeMap[platform] = { id: platform, type: 'platform' };
                }
                // Link service to platform
                links.push({
                    source: service.serviceName,
                    target: platform,
                    type: 'platform-dependency'
                });
            });
        }
    });

    // Create links based on service dependencies
    services.forEach(service => {
        // Service dependencies
        service.serviceDependencies.forEach(dependency => {
            if (nodeMap[dependency]) {
                links.push({
                    source: service.serviceName,
                    target: dependency,
                    type: 'service-dependency'
                });
            }
        });
    });

    // Set up the simulation
    let simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collide', d3.forceCollide(radius + 30));

    // **Corrected Node Creation and Attribute Setting**

    let node = svg.append('g')
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', d => d.isSelected ? 25 : 20) // Increase radius for selected node
        .attr('fill', d => d.color)
        .attr('stroke', d => d.isSelected ? 'red' : '#fff') // Change stroke color to red for selected node
        .attr('stroke-width', d => d.isSelected ? 4 : 2) // Increase stroke width for selected node
        .call(drag(simulation));

    // Add labels to nodes
    let labels = svg.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('dx', 0)
        .attr('dy', 4)
        .attr('text-anchor', 'middle')
        .text(d => d.id)
        .attr('fill', d => d.isSelected ? 'red' : 'black'); // Change text color to red for selected node

    // Tooltip
    let tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    node.on('mouseover', function(event, d) {
        let info = '';
        if (d.type === 'service') {
            let service = serviceMap[d.id];
            let team = currentSystemData.teams.find(t => t.teamId === service.owningTeamId);
            info = `<strong>Service Name:</strong> ${service.serviceName}<br>
                    <strong>Description:</strong> ${service.serviceDescription}<br>
                    <strong>Team:</strong> ${team ? `${team.teamName} (${team.teamIdentity})` : 'Unassigned'}`;
        } else if (d.type === 'platform') {
            info = `<strong>Platform Dependency:</strong> ${d.id}`;
        }
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
        node
            .attr('cx', d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr('cy', d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        labels
            .attr('x', d => d.x)
            .attr('y', d => d.y - radius - 5);
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
    });

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    // **Add links to the SVG after nodes are created**
    let link = svg.append('g')
        .attr('stroke', '#aaa')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke-dasharray', d => {
            if (d.type === 'service-dependency') return '5,5';
            else if (d.type === 'platform-dependency') return '10,5';
            else return '1,0';
        })
        .attr('stroke-width', 2);

    // Add legend for teams
    let legendData = currentSystemData.teams.map(team => ({
        teamIdentity: team.teamIdentity,
        color: teamColorScale(team.teamId)
    }));

    let legend = d3.select('#serviceLegend').selectAll('.legend-item')
        .data(legendData)
        .enter().append('div')
        .attr('class', 'legend-item');

    legend.append('div')
        .style('width', '12px')
        .style('height', '12px')
        .style('background-color', d => d.color)
        .style('margin-right', '5px');

    legend.append('span')
        .text(d => d.teamIdentity);
}

//Create a function to populate the dropdown menu with available services.
function populateDependencyServiceSelection() {
    const serviceSelection = document.getElementById('dependencyServiceSelection');
    serviceSelection.innerHTML = ''; // Clear existing options

    // Add individual services
    currentSystemData.services.forEach(service => {
        let option = document.createElement('option');
        option.value = service.serviceName;
        option.text = service.serviceName;
        serviceSelection.appendChild(option);
    });
}

//We need to build a graph with nodes and links, ensuring that nodes are not duplicated and circular dependencies are handled.
//We use a breadth-first search (BFS) traversal to explore both upstream and downstream services, handling cycles by keeping track of visited services.
//We build nodes and links without duplicating nodes.
//Ensure the edges are defined in the correct direction (from upstream to downstream).
function buildDependencyGraph(serviceName) {
    const nodes = [];
    const links = [];
    const nodeMap = {};

    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    const queue = [];
    const visited = new Set();

    queue.push(serviceName);
    visited.add(serviceName);

    while (queue.length > 0) {
        const currentServiceName = queue.shift();
        const currentService = serviceMap[currentServiceName];

        if (!nodeMap[currentServiceName]) {
            nodes.push({ id: currentServiceName, type: 'service' });
            nodeMap[currentServiceName] = true;
        }

        // Process upstream dependencies
        currentService.serviceDependencies.forEach(depName => {
            if (!nodeMap[depName]) {
                nodes.push({ id: depName, type: 'service' });
                nodeMap[depName] = true;
            }
            // Edge from dependency to current service
            links.push({
                source: depName,
                target: currentServiceName,
                type: 'service-dependency',
            });
            if (!visited.has(depName)) {
                visited.add(depName);
                queue.push(depName);
            }
        });

        // Process platform dependencies
        if (currentService.platformDependencies) {
            currentService.platformDependencies.forEach(platform => {
                if (!nodeMap[platform]) {
                    nodes.push({ id: platform, type: 'platform' });
                    nodeMap[platform] = true;
                }
                // Edge from platform to current service
                links.push({
                    source: platform,
                    target: currentServiceName,
                    type: 'platform-dependency',
                });
            });
        }

        // Process downstream dependents
        currentSystemData.services.forEach(service => {
            if (service.serviceDependencies.includes(currentServiceName)) {
                const dependentName = service.serviceName;
                if (!nodeMap[dependentName]) {
                    nodes.push({ id: dependentName, type: 'service' });
                    nodeMap[dependentName] = true;
                }
                // Edge from current service to dependent
                links.push({
                    source: currentServiceName,
                    target: dependentName,
                    type: 'service-dependency',
                });
                if (!visited.has(dependentName)) {
                    visited.add(dependentName);
                    queue.push(dependentName);
                }
            }
        });
    }

    return { nodes, links };
}

//Create functions to build the data structure representing upstream and downstream dependencies.
function buildDependencyTree(serviceName) {
    const serviceMap = {};
    currentSystemData.services.forEach(service => {
        serviceMap[service.serviceName] = service;
    });

    // Recursive function to get upstream dependencies
    function getUpstream(service, visited = new Set()) {
        if (!service || visited.has(service.serviceName)) return null;
        visited.add(service.serviceName);

        let dependencies = [];
        service.serviceDependencies.forEach(depName => {
            const depService = serviceMap[depName];
            const upstreamNode = getUpstream(depService, visited);
            if (upstreamNode) {
                dependencies.push(upstreamNode);
            } else if (depService) {
                dependencies.push({ name: depService.serviceName, children: [] });
            }
        });

        return { name: service.serviceName, children: dependencies };
    }

    // Recursive function to get downstream dependencies
    function getDownstream(service, visited = new Set()) {
        if (!service || visited.has(service.serviceName)) return null;
        visited.add(service.serviceName);

        let dependents = [];
        currentSystemData.services.forEach(otherService => {
            if (otherService.serviceDependencies.includes(service.serviceName)) {
                const downstreamNode = getDownstream(otherService, visited);
                if (downstreamNode) {
                    dependents.push(downstreamNode);
                } else {
                    dependents.push({ name: otherService.serviceName, children: [] });
                }
            }
        });

        return { name: service.serviceName, children: dependents };
    }

    const rootService = serviceMap[serviceName];

    const upstreamTree = getUpstream(rootService);
    const downstreamTree = getDownstream(rootService);

    // Combine upstream and downstream trees
    const treeData = {
        name: rootService.serviceName,
        children: []
    };

    if (upstreamTree && upstreamTree.children.length > 0) {
        treeData.children.push({
            name: 'Upstream Dependencies',
            direction: 'upstream',
            children: upstreamTree.children
        });
    }

    if (downstreamTree && downstreamTree.children.length > 0) {
        treeData.children.push({
            name: 'Downstream Dependencies',
            direction: 'downstream',
            children: downstreamTree.children
        });
    }

    return treeData;
}

//The function uses a force-directed graph to display service dependencies, handling circular dependencies by linking back to existing nodes.
//Nodes represent services and platforms.
//Links represent dependencies, with arrowheads to indicate direction.
//The graph is interactive, with zoom/pan and node dragging.
//Labels are added to nodes, and tooltips provide additional information
function generateDependencyForceVisualization(selectedServiceName) {
    const svg = d3.select('#dependencySvg');
    svg.selectAll('*').remove(); // Clear existing content

    const width = parseInt(svg.style('width')) || 800;
    const height = parseInt(svg.style('height')) || 600;

    const { nodes, links } = buildDependencyGraph(selectedServiceName);

    // Assign index to links
    links.forEach((link, index) => {
        link.index = index;
    });

    // Create a color scale
    const color = d3.scaleOrdinal()
        .domain(['service', 'platform'])
        .range(['#1f77b4', '#ff7f0e']); // Customize colors as needed

    // Create simulation
    const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collide', d3.forceCollide(40))
        .on('tick', ticked);

    // Add zoom and pan
    const zoom = d3.zoom()
        .scaleExtent([0.1, 5])
        .on('zoom', (event) => {
            container.attr('transform', event.transform);
        });

    svg.call(zoom);

    // Create container for nodes and links
    const container = svg.append('g');

    // Define arrowheads
    svg.append('defs').selectAll('marker')
        .data(['service-dependency', 'platform-dependency'])
        .enter().append('marker')
        .attr('id', d => `arrow-${d}`)
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 25) // Adjusted for larger arrowhead
        .attr('refY', 0)
        .attr('markerWidth', 10) // Increased size
        .attr('markerHeight', 10) // Increased size
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#999');

    // Define arrowheads for legend
    svg.append('defs').selectAll('marker')
        .data(['arrow-service-dependency', 'arrow-platform-dependency'])
        .enter().append('marker')
        .attr('id', d => d)
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 12)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#999');

    // Add links
    const link = container.append('g')
        .attr('stroke', '#999')
        .attr('stroke-opacity', 0.6)
        .selectAll('line')
        .data(links)
        .enter().append('line')
        .attr('stroke-width', 2)
        .attr('marker-end', d => `url(#arrow-${d.type})`)
        .attr('stroke-dasharray', d => {
            if (d.type === 'platform-dependency') return '5,5';
            else return '0';
        });

    // Add nodes
    const node = container.append('g')
        .attr('stroke', '#fff')
        .selectAll('circle')
        .data(nodes)
        .enter().append('circle')
        .attr('r', d => d.id === selectedServiceName ? 15 : 10)
        .attr('fill', d => {
            if (d.id === selectedServiceName) return 'red'; // Highlight selected service
            else if (d.type === 'service') return color('service');
            else return color('platform');
        })
        .attr('stroke-width', d => d.id === selectedServiceName ? 3 : 1.5)
        .call(drag(simulation));

    // Add labels
    const label = container.append('g')
        .selectAll('text')
        .data(nodes)
        .enter().append('text')
        .attr('dy', -15)
        .attr('text-anchor', 'middle')
        .text(d => d.id)
        .attr('font-weight', d => d.id === selectedServiceName ? 'bold' : 'normal')
        .attr('fill', d => d.id === selectedServiceName ? 'red' : 'black');

    // Tooltip
    const tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    // Variables for highlighting
    let highlightedNodes = new Set();
    let highlightedLinks = new Set();

    // Node mouseover event
    node.on('mouseover', function(event, d) {
        let info = '';
        if (d.type === 'service') {
            const service = currentSystemData.services.find(s => s.serviceName === d.id);
            if (service) {
                // Fetch upstreams and downstreams
                const upstreams = service.serviceDependencies;
                const downstreams = currentSystemData.services
                    .filter(s => s.serviceDependencies.includes(service.serviceName))
                    .map(s => s.serviceName);
                // Fetch platform dependencies
                const platformDeps = service.platformDependencies || [];
    
                // Build the tooltip content
                info = `<strong>Service Name:</strong> ${service.serviceName}<br>`;
                info += `<strong>Upstreams:</strong> ${upstreams.length > 0 ? upstreams.join(', ') : 'None'}<br>`;
                info += `<strong>Downstreams:</strong> ${downstreams.length > 0 ? downstreams.join(', ') : 'None'}<br>`;
                info += `<strong>Platform Dependencies:</strong> ${platformDeps.length > 0 ? platformDeps.join(', ') : 'None'}`;
            }
        } else if (d.type === 'platform') {
            info = `<strong>Platform Dependency:</strong> ${d.id}`;
        }
        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        tooltip.html(info)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    
        // Highlight connected nodes and links
        highlightConnected(d);
    }).on('mouseout', function() {
        tooltip.transition()
            .duration(500)
            .style('opacity', 0);
    
        // Remove highlighting
        unhighlight();
    });

    // Function to highlight connected nodes and links
    function highlightConnected(d) {
        // Clear previous highlights
        highlightedNodes.clear();
        highlightedLinks.clear();

        // Add the hovered node
        highlightedNodes.add(d.id);

        // Highlight upstream nodes and links
        links.forEach(link => {
            if (link.target.id === d.id) {
                highlightedNodes.add(link.source.id);
                highlightedLinks.add(link.index);
            }
        });

        // Highlight downstream nodes and links
        links.forEach(link => {
            if (link.source.id === d.id) {
                highlightedNodes.add(link.target.id);
                highlightedLinks.add(link.index);
            }
        });

        // Update node styles
        node.style('opacity', n => highlightedNodes.has(n.id) ? 1 : 0.1);
        label.style('opacity', n => highlightedNodes.has(n.id) ? 1 : 0.1);

        // Update link styles
        link.style('opacity', l => highlightedLinks.has(l.index) ? 1 : 0.1);
    }

    // Function to remove highlighting
    function unhighlight() {
        node.style('opacity', 1);
        label.style('opacity', 1);
        link.style('opacity', 1);
    }

    // Add legend
    const legendData = [
        { label: 'Selected Service', color: 'red', shape: 'circle' },
        { label: 'Service', color: color('service'), shape: 'circle' },
        { label: 'Platform', color: color('platform'), shape: 'circle' },
        { label: 'Service Dependency', color: '#999', type: 'line', marker: 'arrow-service-dependency', dash: '0' },
        { label: 'Platform Dependency', color: '#999', type: 'line', marker: 'arrow-platform-dependency', dash: '5,5' }
    ];

    // Create a legend container
    const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', `translate(${20},${20})`);

    // Add legend items
    legendData.forEach((item, index) => {
        const legendRow = legend.append('g')
            .attr('transform', `translate(0, ${index * 20})`);

        if (item.shape === 'circle') {
            // Draw circle
            legendRow.append('circle')
                .attr('r', 6)
                .attr('fill', item.color)
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .attr('cx', 0)
                .attr('cy', 0);
        } else if (item.type === 'line') {
            // Draw line with arrow
            legendRow.append('line')
                .attr('x1', -10)
                .attr('y1', 0)
                .attr('x2', 10)
                .attr('y2', 0)
                .attr('stroke', item.color)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', item.dash)
                .attr('marker-end', `url(#${item.marker})`);
        }

        // Add text
        legendRow.append('text')
            .attr('x', 20)
            .attr('y', 5)
            .text(item.label)
            .attr('text-anchor', 'start')
            .attr('font-size', '12px');
    });

    // Tick function
    function ticked() {
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);

        node
            .attr('cx', d => d.x)
            .attr('cy', d => d.y);

        label
            .attr('x', d => d.x)
            .attr('y', d => d.y - 15);
    }

    // Drag functions
    function drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }
}


//Create a function to update the visualization when a new service is selected.
function updateDependencyVisualization() {
    const selectedServiceName = document.getElementById('dependencyServiceSelection').value;
    // Ensure the service selection is populated with the latest data
    populateDependencyServiceSelection();
    generateDependencyForceVisualization(selectedServiceName); //forced dependency works best
}


//Create a function to add the legend to the SVG.
//Legend Items: The legend displays the meanings of node colors, shapes, and edge styles.
//Arrowhead Definition: An arrowhead is defined for use in the legend.
function addDependencyLegend(svg) {
    const legendData = [
        { label: 'Selected Service', color: 'red', shape: 'rect' },
        { label: 'Service', color: '#1f77b4', shape: 'rect' },
        { label: 'Platform', color: '#ff7f0e', shape: 'rect' },
        { label: 'Service Dependency', style: 'stroke: #333; stroke-width: 2px;', arrowhead: true },
        { label: 'Platform Dependency', style: 'stroke: #333; stroke-width: 2px; stroke-dasharray: 5,5;', arrowhead: true },
    ];

    const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', 'translate(20, 20)');

    legendData.forEach((item, index) => {
        const legendItem = legend.append('g')
            .attr('transform', `translate(0, ${index * 25})`);

        if (item.shape === 'rect') {
            legendItem.append('rect')
                .attr('x', 0)
                .attr('y', -10)
                .attr('width', 20)
                .attr('height', 20)
                .attr('style', `fill: ${item.color}; stroke: #fff; stroke-width: 1.5px;`);
        } else {
            // Draw line
            const line = legendItem.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', 20)
                .attr('y2', 0)
                .attr('style', item.style);

            if (item.arrowhead) {
                line.attr('marker-end', 'url(#arrowhead)');
            }
        }

        legendItem.append('text')
            .attr('x', 30)
            .attr('y', 5)
            .text(item.label)
            .attr('text-anchor', 'start')
            .attr('font-size', '12px');
    });

    // Define arrowhead for legend lines
    svg.append('defs').append('marker')
        .attr('id', 'arrowhead')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 10)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#333');
}

function generateServiceDependenciesTable() {
    const tbody = document.querySelector('#serviceDependenciesTable tbody');
    tbody.innerHTML = ''; // Clear existing content

    currentSystemData.services.forEach(service => {
        const row = document.createElement('tr');

        // Service Name
        const nameCell = document.createElement('td');
        nameCell.textContent = service.serviceName;
        row.appendChild(nameCell);

        // Description
        const descCell = document.createElement('td');
        descCell.textContent = service.serviceDescription;
        row.appendChild(descCell);

        // Owning Team
        const team = currentSystemData.teams.find(t => t.teamId === service.owningTeamId);
        const teamCell = document.createElement('td');
        teamCell.textContent = team ? team.teamName : 'Unassigned';
        row.appendChild(teamCell);

        // Upstream Dependencies (Services Depended On)
        const upstreamServices = service.serviceDependencies;
        const upstreamCell = document.createElement('td');
        upstreamCell.textContent = upstreamServices.length > 0 ? upstreamServices.join(', ') : 'None';
        row.appendChild(upstreamCell);

        // Platform Dependencies
        const platformDependencies = service.platformDependencies || [];
        const platformCell = document.createElement('td');
        platformCell.textContent = platformDependencies.length > 0 ? platformDependencies.join(', ') : 'None';
        row.appendChild(platformCell);

        // Downstream Dependencies (Services That Depend On This Service)
        const downstreamServices = currentSystemData.services
            .filter(s => s.serviceDependencies.includes(service.serviceName))
            .map(s => s.serviceName);
        const downstreamCell = document.createElement('td');
        downstreamCell.textContent = downstreamServices.length > 0 ? downstreamServices.join(', ') : 'None';
        row.appendChild(downstreamCell);

        tbody.appendChild(row);
    });
}

function saveSystemChanges() {
    // Get updated system name and description
    const systemNameInput = document.getElementById('systemNameInput');
    const systemDescriptionTextarea = document.getElementById('systemDescriptionInput');

    currentSystemData.systemName = systemNameInput.value.trim();
    currentSystemData.systemDescription = systemDescriptionTextarea.value.trim();

    if (!currentSystemData.systemName) {
        alert('System name cannot be empty.');
        return;
    }

    // Save currentSystemData to local storage
    const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    systems[currentSystemData.systemName] = currentSystemData;
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

    alert('System changes saved.');

    // Update UI components
    generateTeamTable(currentSystemData);
    generateServiceDependenciesTable();
    updateServiceVisualization();
    updateDependencyVisualization();
}

// Generate a unique ID for new teams
function generateUniqueId() {
    return 'team-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
}

function deleteSystem() {
    if (currentSystemData && currentSystemData.systemName) {
        // Confirm deletion
        if (confirm(`Are you sure you want to delete the system "${currentSystemData.systemName}"? This action cannot be undone.`)) {
            // Remove from local storage
            const systems = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
            delete systems[currentSystemData.systemName];
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(systems));

            // Optionally, you might want to remove any other related data

            // Clear current system data and reset the mode
            const deletedSystemName = currentSystemData.systemName; // Store the name before clearing
            currentSystemData = null;
            currentMode = Modes.NAVIGATION;

            // Clear the UI and display the main menu
            returnToHome();

            // Notify the user
            alert(`The system "${deletedSystemName}" has been deleted.`);
        }
    } else {
        alert('No system is currently loaded.');
    }
}


// Attach functions to the global window object
window.showSavedSystems = showSavedSystems;
window.createNewSystem = createNewSystem;
window.resetToDefaults = resetToDefaults;
window.returnToHome = returnToHome;
</script>

</body>
</html>
